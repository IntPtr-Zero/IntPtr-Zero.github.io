{"meta":{"title":"IntPtr.Zero","subtitle":"IntPtr.Zero的博客","description":"Code and Learn","author":"IntPtr.Zero","url":"https://intptrzero.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-08-31T14:10:44.186Z","updated":"2019-08-31T14:10:44.186Z","comments":true,"path":"404.html","permalink":"https://intptrzero.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，你访问的页面不存在 前方可能正在施工，你可以在下面报告错误"},{"title":"关于","date":"2019-08-31T14:11:00.661Z","updated":"2019-08-31T14:11:00.661Z","comments":true,"path":"about/index.html","permalink":"https://intptrzero.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 兴趣广泛，专注Windows平台，主要使用C++/.NET，喜欢研究底层。破解爱好者 关于博客本站使用 Hexo 主题 Material X感谢 Github 提供的空间支持以及 Gitalk 评论插件Gitalk表情食用方法：查看Gitalk支持的emoji列表，在评论框输入对应代码即可◕‿-欢迎交流、分享与评论"},{"title":"文章分类","date":"2019-08-31T14:11:14.554Z","updated":"2019-08-31T14:11:14.554Z","comments":true,"path":"categories/index.html","permalink":"https://intptrzero.github.io/categories/index.html","excerpt":"","text":""},{"title":"推荐链接","date":"2019-09-02T03:48:58.510Z","updated":"2019-09-02T03:48:58.510Z","comments":true,"path":"links/index.html","permalink":"https://intptrzero.github.io/links/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-08-31T14:12:04.165Z","updated":"2019-08-31T14:12:04.165Z","comments":true,"path":"tags/index.html","permalink":"https://intptrzero.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CLR - 线程同步","slug":"CLR-MTSync","date":"2019-09-24T11:45:16.000Z","updated":"2019-11-28T15:52:12.348Z","comments":true,"path":"2019/09/24/CLR-MTSync/","link":"","permalink":"https://intptrzero.github.io/2019/09/24/CLR-MTSync/","excerpt":"线程同步构造线程同步总体上分为两种构造：用户模式和内核模式。其中用户模式基于CPU指令，内核模式则基于操作系统内核对象。由于用户模式构造由硬件支持，且不发生用户-内核状态切换，因此效率较高。但线程使用基于用户模式的同步时，操作系统也无法捕捉到该线程上的阻塞。因此该线程在操作系统看来总是处于非阻塞状态，这意味着线程总是参与抢占时间片，导致线程无谓的浪费CPU时间。与之相对的是内核模式构造，线程使用操作系统提供的内核对象进行同步，每当进入同步块时，代码需要切换到内核态运行，导致巨大的性能损失。但优点是操作系统可以检测到等待同步对象的线程并将其阻塞，当同步对象可用时再唤醒线程。如果拥有“锁”的线程一直不释放，基于用户模式构造的等待线程将一直在CPU上无意义的运行，称之为“活锁”。基于内核模式构造的等待线程则一直被操作系统阻塞，称之为“死锁”。总体来说“死锁”优于“活锁”，因为前者不消耗CPU时间。","text":"线程同步构造线程同步总体上分为两种构造：用户模式和内核模式。其中用户模式基于CPU指令，内核模式则基于操作系统内核对象。由于用户模式构造由硬件支持，且不发生用户-内核状态切换，因此效率较高。但线程使用基于用户模式的同步时，操作系统也无法捕捉到该线程上的阻塞。因此该线程在操作系统看来总是处于非阻塞状态，这意味着线程总是参与抢占时间片，导致线程无谓的浪费CPU时间。与之相对的是内核模式构造，线程使用操作系统提供的内核对象进行同步，每当进入同步块时，代码需要切换到内核态运行，导致巨大的性能损失。但优点是操作系统可以检测到等待同步对象的线程并将其阻塞，当同步对象可用时再唤醒线程。如果拥有“锁”的线程一直不释放，基于用户模式构造的等待线程将一直在CPU上无意义的运行，称之为“活锁”。基于内核模式构造的等待线程则一直被操作系统阻塞，称之为“死锁”。总体来说“死锁”优于“活锁”，因为前者不消耗CPU时间。 用户模式构造","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"},{"name":"多线程","slug":"多线程","permalink":"https://intptrzero.github.io/tags/多线程/"}]},{"title":"CLR - 异步I/O","slug":"CLR-Async","date":"2019-08-31T16:19:06.000Z","updated":"2019-11-23T19:11:14.481Z","comments":true,"path":"2019/09/01/CLR-Async/","link":"","permalink":"https://intptrzero.github.io/2019/09/01/CLR-Async/","excerpt":"同步I/O在Windows系统中，应用程序调用I/O函数发起的操作均发生在用户态，而用户态是无法访问I/O硬件设备的，因此Windows把用户态的I/O操作信息打包发送给内核，此时进入内核态访问对应的I/O设备。I/O设备处理请求的操作时，发起I/O请求的线程将被阻塞，只有当I/O操作完成时，才会重新唤醒线程以返回结果。如果在Socket中使用同步I/O操作，当大量客户端请求连接时，将消耗大量线程，造成性能的急剧下降。","text":"同步I/O在Windows系统中，应用程序调用I/O函数发起的操作均发生在用户态，而用户态是无法访问I/O硬件设备的，因此Windows把用户态的I/O操作信息打包发送给内核，此时进入内核态访问对应的I/O设备。I/O设备处理请求的操作时，发起I/O请求的线程将被阻塞，只有当I/O操作完成时，才会重新唤醒线程以返回结果。如果在Socket中使用同步I/O操作，当大量客户端请求连接时，将消耗大量线程，造成性能的急剧下降。 异步I/O异步I/O与同步I/O不同之处在于，当内核向I/O设备发送请求后，线程将直接返回继续执行其它任务。当设备处理完I/O请求后，Windows将处理结果放入任务队列等待线程处理，对于CLR，则是放入线程池任务队列，等待线程池线程处理。CLR异步I/O实际上是对Windows I/O完成端口的封装。 异步方法.NET4.5提供了全新的async和await关键字来取代以前的Beginxxx和Endxxx系列异步方法。一个简单的例子： 1234567891011121314151617181920212223242526272829303132static void Main()&#123;1： Console.WriteLine(\"@Main=====Before async，线程ID:\"+ Thread.CurrentThread.ManagedThreadId);2： Task t = DoWorkAsync();3: Console.WriteLine(\"@Main=====After async，线程ID:\" + Thread.CurrentThread.ManagedThreadId);4: while (!t.IsCompleted) &#123; Console.WriteLine(\"@Main=====Waiting completed...，线程ID:\" + Thread.CurrentThread.ManagedThreadId); Thread.Sleep(200); &#125; Console.Read();&#125;static async Task DoWorkAsync()&#123;5: Console.WriteLine(\"@DoWorkAsync=====Before await，线程ID:\" + Thread.CurrentThread.ManagedThreadId);6: await Task.Run(() =&gt; &#123; Console.WriteLine(\"Doing long-time work，线程ID:\" + Thread.CurrentThread.ManagedThreadId); Thread.Sleep(2000); &#125;);7: Console.WriteLine(\"@DoWorkAsync=====After await，线程ID:\" + Thread.CurrentThread.ManagedThreadId); Console.WriteLine(\"@DoWorkAsync=====Job Done,线程ID:\" + Thread.CurrentThread.ManagedThreadId);&#125;/*输出@Main=====Before async，线程ID:1@DoWorkAsync=====Before await，线程ID:1Doing long-time work，线程ID:3@Main=====After async，线程ID:1@Main=====Waiting completed...，线程ID:1@Main=====Waiting completed...，线程ID:1@Main=====Waiting completed...，线程ID:1@DoWorkAsync=====After await，线程ID:3@DoWorkAsync=====Job Done,线程ID:3*/ 很显然async修饰的方法并不是字面意义上的异步方法，而是被内部的await关键字分裂成为两部分。主线程调用DoWorkAsync时会以同步方式执行到await，然后将await修饰的任务交给线程池处理，并立即返回一个与之关联的Task对象。现在主线程继续执行后面的语句，与此同时耗时任务由线程池线程异步执行。等待耗时任务完成之后，线程池线程继续执行await之后的语句，此时DoWorkAsync才真正执行完毕。用序号表示的执行流程图为： 对于GUI程序而言，情况又有所不同。异步方法总是会使用GUI线程的SynchronizationContext执行await后续部分(CUI程序的同步上下文为null)，因此上述的After await部分将由主线程执行，如果不慎在主线程中以同步方式等待结果，将造成死锁。例: 123456789101112131415class MyForm:Form&#123; MyForm() &#123; string s=GetHttpAsync().Result; //... &#125;&#125;private async GetHttpAsync()&#123; HttpResponseMessage msg=await new HttpClient().GetAsync(\"http://www.baidu.com\"); //===After await=== return await msg.Content.ReadAsStringAsync();&#125; GUI线程以同步方式等待Result，此时线程被阻塞。异步执行完HttpClient().GetAsync()后需要主线程接着执行After await部分以返回结果，然而主线程被阻塞，因此造成死锁。注意例子在CUI环境下正常运行。为了防止死锁，.NET提供了Task.ConfigureAwait(bool)方法，传递false时与CUI环境行为一致。","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"},{"name":"多线程","slug":"多线程","permalink":"https://intptrzero.github.io/tags/多线程/"},{"name":"异步","slug":"异步","permalink":"https://intptrzero.github.io/tags/异步/"}]},{"title":"CLR - Task","slug":"CLR-Task","date":"2019-08-18T11:45:45.000Z","updated":"2019-11-20T15:52:09.235Z","comments":true,"path":"2019/08/18/CLR-Task/","link":"","permalink":"https://intptrzero.github.io/2019/08/18/CLR-Task/","excerpt":"使用Task使用ThreadPool可以方便的发起异步操作，但却无法知道操作在何时完成，且无法直接获取操作的返回值，为此CLR提供了对线程池的再一次包装，即Task类。Task内部实际上也是使用线程池，只不过封装了一些高级功能。","text":"使用Task使用ThreadPool可以方便的发起异步操作，但却无法知道操作在何时完成，且无法直接获取操作的返回值，为此CLR提供了对线程池的再一次包装，即Task类。Task内部实际上也是使用线程池，只不过封装了一些高级功能。 Task支持直接获取任务执行结果，例如： 12345678Task&lt;int&gt; t = new Task&lt;int&gt;(n=&gt;Sum(int n),1000);t.Start();//执行其它操作Thread.Sleep(2000);//显式等待Task完成//t.Wait();//在需要结果的时候访问结果Console.WriteLine(t.Result); 无论是等待还是访问结果，都会阻塞当前线程以等待任务运行完毕。如果此时任务还未被调度给线程池线程执行，则可能会直接分配给当前线程以提高性能。 Task的取消与ThreadPool相似，传递一个CTS即可。不同之处在于Task支持返回结果，因此Task会在取消任务时抛出异常以区别于正常结束任务。为了方便区分，推荐在任务方法中使用CT.ThrowIfCancellationRequested以抛出OperationCanceledException. 123456789101112131415161718192021222324252627CancellationTokenSource cts = new CancellationTokenSource();Task t = new Task&lt;int&gt;(()=&gt;Sum(1000,cts.Token),cts.Token);t.Start();Thread.Sleep(100);cts.Cancel();try&#123; Console.WriteLine(t.Result);&#125;catch (AggregateException ex)&#123; //如果是取消产生的异常，则忽略 x.Handle(ex=&gt;ex is OperationCanceledException; Console.WriteLine(\"操作取消\");&#125;Static int Sum(int n, CancellationToken ct)&#123; int sum=0; for(int i =1;i&lt;=n;i++) &#123; //检查是否已取消并抛出异常 ct.ThrowIfCancellationRequested(); sum+=i; &#125; return sum;&#125; 延续任务Task支持在任务完成后继续执行其它任务，并可指定延续任务的执行条件 12Task&lt;int&gt; t = Task.Run(()=&gt;Sum(1000,cts.Token),cts.Token);t.ContinueWith(task=&gt;Console.WriteLine(task.Result,TaskContinuationOptions); 其中t作为参数被传递到延续任务中 父子任务可以在一个Task中包含若干个子任务，只有在所有子任务完成后父任务才会被标记为完成状态 12345678Task&lt;int[]&gt; parent=new Task&lt;int[]&gt;(()=&gt;&#123; var results=new int[3]; new Task(()=&gt;results[0]=Sum(1000),TaskCreationOptions.AttachedtoParent).Start(); new Task(()=&gt;results[1]=Sum(2000),TaskCreationOptions.AttachedtoParent).Start(); new Task(()=&gt;results[2]=Sum(3000),TaskCreationOptions.AttachedtoParent).Start(); return results; &#125;);parent.Start(); 任务调度器Task在内部使用TaskScheduler进行任务调度，CLR内部使用了两个派生类，分别是基于线程池的线程池调度器和基于同步上下文的上下文调度器。线程池调度器是Task的默认调度器，而同步上下文调度器适用于更新GUI的任务，因为.NET禁止从非GUI线程更新界面。 123456789Class MyForm:Form&#123; public MyForm &#123; Task t=new Task(()=&gt;SomeWork()) t.ContinueWith(task =&gt; Text = \"任务完成\", CancellationToken.None, TaskContinuationOptions.None, TaskScheduler.FromCurrentSynchronizationContext); t.Start(); &#125;&#125;","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"},{"name":"多线程","slug":"多线程","permalink":"https://intptrzero.github.io/tags/多线程/"}]},{"title":"CLR - ThreadPool","slug":"CLR-MT","date":"2019-08-16T07:23:43.000Z","updated":"2019-11-23T18:36:05.081Z","comments":true,"path":"2019/08/16/CLR-MT/","link":"","permalink":"https://intptrzero.github.io/2019/08/16/CLR-MT/","excerpt":"CLR线程池虽然CLR通过System.Threading名称空间提供了对Windows线程API的封装，但直接创建和销毁线程严重影响性能。过多的线程不仅浪费内存，而且会造成频繁的CPU上下文切换，更重要的是线程大部分时间都处于无所事事的状态，浪费宝贵的CPU时间。其次多线程非常容易引发滥用，特别是那些没什么多线程基础的程序员，为了所谓的“性能”无脑使用线程，即使在一些商业软件中这种现象也比比皆是。为了减少这种现象，CLR提供了原生的线程池支持。对于每个CLR，线程池线程将被所有运行中的托管程序集共享。","text":"CLR线程池虽然CLR通过System.Threading名称空间提供了对Windows线程API的封装，但直接创建和销毁线程严重影响性能。过多的线程不仅浪费内存，而且会造成频繁的CPU上下文切换，更重要的是线程大部分时间都处于无所事事的状态，浪费宝贵的CPU时间。其次多线程非常容易引发滥用，特别是那些没什么多线程基础的程序员，为了所谓的“性能”无脑使用线程，即使在一些商业软件中这种现象也比比皆是。为了减少这种现象，CLR提供了原生的线程池支持。对于每个CLR，线程池线程将被所有运行中的托管程序集共享。 线程池调度CLR的初始线程池为空，每当托管程序请求使用线程池线程或执行异步任务，CLR会将程序请求的任务添加到线程池的任务记录，并分配给一个线程执行。如果没有可用线程，则创建一个新线程。与直接使用Thread相比，线程池线程完成任务后并不会销毁，而是进入线程池等待新任务。CLR线程池使用启发式的线程分配策略，当有大量任务请求时会创建较多的线程，而空闲时则销毁多余的线程以节省内存。 执行上下文CLR中每个线程都与一个执行上下文相关联，其中包括运行权限、用户标识以及区域设置等等信息，每当线程被创建时，会从被创建的线程复制一份执行上下文。对于不需要执行上下文信息的线程来说，这一操作明显影响性能。因此CLR提供了ExecutionContext类来对执行上下文进行控制。 12345678910111213public static void main()&#123; //添加自定义信息到逻辑上下文 CallContext.LogicalSetData(\"User\",\"Admin\"); //获取上下文信息--打印Admin ThreadingPool.QueueUserWorkItem((state)=&gt;Console.WriteLine(CallContext.LogicalGetData(\"User\").ToString())); //阻止上下文流动 ExecutionContext.SuppressFlow(); //打印空字符串 ThreadingPool.QueueUserWorkItem((state)=&gt;Console.WriteLine(CallContext.LogicalGetData(\"User\").ToString())); //恢复上下文流动 ExecutionContext.RestoreFlow();&#125; 取消与超时线程池比Thread类更好的一点是支持协作式取消以及任务超时，只需要将一个CancellatinTokenSource对象与任务相关联，即可方便的取消任务。 123456789101112131415161718192021222324public static void main()&#123; CancellationTokenSource cts = new CancellationTokenSource(); ThreadPool.QueueUserWorkItem(state=&gt;Count(cts.Token,1000000)); Console.WriteLine(\"回车键取消...\"); Console.ReadLine(); cts.Cancel(); //超时自动取消 //cts.CancelAfter(1000);&#125;private void Count(CancellationToken token, Int32 count)&#123; for(int i=0;i&lt;=count;i++) &#123; if(token.IsCancellationRequested) &#123; Console.WriteLine(\"已取消\"); break; &#125; Console.WriteLine(i); Thread.Sleep(200); &#125;&#125; CancellationTokenSource类以下是CTS的.NET源代码节选： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class CancellationTokenSource: IDisposable&#123; //信号 private volatile ManualResetEvent m_kernelEvent; //一个类似链表的内部类，记录CTS取消时调用的回调函数 private volatile SparselyPopulatedArray&lt;CancellationCallbackInfo&gt;[] m_registeredCallbacksLists; //CTS状态 private const int CANNOT_BE_CANCELED = 0; private const int NOT_CANCELED = 1; private const int NOTIFYING = 2; private const int NOTIFYINGCOMPLETE = 3; private volatile int m_state; //通过结构体CT暴露方法(轻量化便于传递参数？) public CancellationToken token&#123;get&#125;; public bool IsCancellationRequested &#123; get&#123;return m_state&gt;=NOTIFING;&#125; &#125; //WaitHandle是对WaitForSingleObject API函数的包装 internal WaitHandle WaitHandle &#123; if (m_kernelEvent != null) return m_kernelEvent; ManualResetEvent mre = new ManualResetEvent(false); if (Interlocked.CompareExchange(ref m_kernelEvent, mre, null) != null) &#123; ((IDisposable)mre).Dispose(); &#125; //取消时将发出信号 if (IsCancellationRequested) m_kernelEvent.Set(); return m_kernelEvent; &#125; //取消 public Cancel(bool throwOnFirstException) &#123; ThrowIfDisposed(); NotifyCancellation(throwOnFirstException); &#125; private void NotifyCancellation(bool throwOnFirstException) &#123; if (IsCancellationRequested) return; if (Interlocked.CompareExchange(ref m_state, NOTIFYING, NOT_CANCELED) == NOT_CANCELED) &#123; //销毁内部超时计时器 Timer timer = m_timer; if(timer != null) timer.Dispose(); if (m_kernelEvent != null) m_kernelEvent.Set(); //执行注册到CTS的回调函数 ExecuteCallbackHandlers(throwOnFirstException); &#125; &#125; //创建联合CTS，其中任意CTS取消则该CTS即取消 public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2) &#123; //方法内部调用Register注册回调 &#125; private CancellationTokenRegistration Register(Action&lt;Object&gt; callback, Object state, bool useSynchronizationContext, bool useExecutionContext) &#123; //注册到CTS取消时要调用的回调函数 //可调用返回值的Dispose方法取消回调 &#125;&#125;//轻量化，便于作为参数传递public struct CancellationToken&#123; //对CTS的引用 private CancellationTokenSource m_source; public bool IsCancellationRequested &#123;get//暴露CTS的属性&#125; public WaitHandle WaitHandle &#123;get//暴露CTS的WaitHandle&#125; //暴露CTS方法 public CancellationTokenRegistration Register(Action callback, bool useSyncContext)&#125;","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"},{"name":"多线程","slug":"多线程","permalink":"https://intptrzero.github.io/tags/多线程/"}]},{"title":"STL - Deque","slug":"STL-Deque","date":"2019-07-02T17:26:51.000Z","updated":"2019-10-16T22:26:31.254Z","comments":true,"path":"2019/07/03/STL-Deque/","link":"","permalink":"https://intptrzero.github.io/2019/07/03/STL-Deque/","excerpt":"双端队列简介顾名思义，deque支持在头尾进行插入删除操作。类似于vector和array，deque也是顺序存储结构，没有了解过deque的人在主观上可能会以为deque与vector底层结构类似，实际上为了支持头部插入与删除操作，deque采用分段连续存储的数据结构，因此实现上比vector复杂得多。因为采用分段设计，deque的迭代器效率比vector低。为了管理片段，STL的deque在内部定义了一个_Map成员，_Map底层实际是一个T**，也可以将_Map看作一个数组，每一个数组元素指向内存中的一段连续的元素存储空间","text":"双端队列简介顾名思义，deque支持在头尾进行插入删除操作。类似于vector和array，deque也是顺序存储结构，没有了解过deque的人在主观上可能会以为deque与vector底层结构类似，实际上为了支持头部插入与删除操作，deque采用分段连续存储的数据结构，因此实现上比vector复杂得多。因为采用分段设计，deque的迭代器效率比vector低。为了管理片段，STL的deque在内部定义了一个_Map成员，_Map底层实际是一个T**，也可以将_Map看作一个数组，每一个数组元素指向内存中的一段连续的元素存储空间 123456789//VS2013 deque节选template&lt;class _Ty&gt; struct _Deque_simple_types : public _Simple_types&lt;_Ty&gt; &#123; // wraps types needed by iterators typedef _Ty **_Mapptr; &#125;;_Mapptr _Map; 双端队列的迭代器deque分类上属于顺序存储容器，因此迭代器理所应当提供随机访问迭代器的所有功能。但在内部deque是分段的，因此迭代器需要知道片段的大小以及片段的地址，以在到达片段边缘时跳转到另一个片段。SGI的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859template&lt;typename T,typename Ref,typename Ptr,size_t BufSize&gt;struct _deque_iterator&#123; //省略traits定义 typedef T** map_pointer; typedef _deque_iterator self; //每一个片段的元素容量，如果不指定，默认为512/sizeof(T) static size_t buffer_size()&#123;&#125;; T* cur; //指向片段的当前可插入位置 T* first; //指向片段的头部 T* last; //指向片段的超尾 map_pointer node; //节点 //设置节点 set_node(map_pointer new_node) &#123; node=new_node; first=*new_node; last=first+difference_type(buffer_size()); &#125; //迭代器之间的减法 difference_type operator-(self&amp; x) const &#123; return difference_type(buffer_size())*(node-x.node-1)+(cur-first)+(x.last-x.cur); &#125; self&amp; operator++() &#123; ++cur; if(cur==last) //到达当前片段超尾 &#123; set_node(node+1); //跳转到下一片段 cur=first; //指向头部 &#125; return *this; &#125; //自减操作类似，略过 self&amp; operator+=(difference_type n) &#123; difference_type offset=n+cur-first; //判断是否在同一片段内偏移 if(offset&gt;=0 &amp;&amp; offset&lt;difference_type(buffer_size())) cur+=n; else &#123; difference_type node_offset=offset&gt;0 ? offset/difference(buffer_size()):-difference_type((-offset-1)/buffer_size())-1; set_node(node+node_offset); cur=first+offset-node_offset*difference_type(buffer_size()); &#125; return *this; &#125; //省略其它操作&#125; 双端队列的结构SGI的deque结构如上图所示，其具体实现见代码： 123456789101112131415161718192021222324252627282930313233//基础成员template&lt;typename T,typename Alloc=alloc,size_t BuffSize=0&gt;class deque&#123;public: typedef _deque_iterator&lt;T,T&amp;,T*,BuffSize&gt; iterator;protected: typedef pointer* map_pointer; iterator start; //头部迭代器 iterator finish; //尾部迭代器 map_pointer map; //map size_type map_size; //节点数量public: //头部迭代器 iterator begin() &#123;return start;&#125; //尾部迭代器 iterator end() &#123;return finish;&#125; //首元素 reference front() &#123;return *start;&#125; //尾元素 reference back() &#123; iterator tmp=finish; --tmp; return *tmp; &#125; //略过其它常用接口&#125; 注意deque迭代器取值操作符返回*cur，start迭代器的cur总是指向首元素，finish迭代器的cur指向最后一个元素的下一位，因此需要前移。 1234567891011121314151617181920212223242526272829303132333435363738394041//构造函数deque(int n,const value_type&amp; value):start(),finish(),map(0),map_size(0)&#123; fill_initialize(n,value);&#125;template&lt;typename T,typename Alloc,size_t BuffSize&gt;void fill_initialize(size_type n,const value_type&amp; value)&#123; create_map_and_nodes(n); map_pointer cur; for(cur=start.node;cur&lt;finish.node;++cur) uninitialized_fill(*cur,*cur+buffer_size(),value); //尾部片段可能还有空闲，因此单独初始化 uninitialized_fill(finish.first,finish.cur,value);&#125;template&lt;typename T,typename Alloc,size_t BuffSize&gt;void create_map_and_nodes(size_type num_element)&#123; //计算初始需要分配的节点数，如果刚好占满n个片段，则额外加一 size_type num_nodes=num_element/buffer_size()+1; //初始节点数，最少为8。首尾各增加一个以供备用 map_size=max(8,num_nodes+2); //为map分配内存保存节点 map=map_allocator::allocate(map_size); //使初始占用的空间尽量居中，便于首尾插入 map_pointer nstart=map+(map_size-num_nodes)/2; map_pointer nfinish=nstart+num_nodes-1; map_pointer cur; //为片段分配空间 for(cur=nstart;cur&lt;=nfinish;++cur) *cur=allocate_node(); start.set_node(nstart); finish.set_node(nfinish); start.cur=start.first; finish.cur=finish.first+num_element%buffer_size();&#125; 再来看看deque在内部如何处理元素插入，以push_back为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void push_back(const value_type&amp; t)&#123; //如果尾片段空余空间大于1，则直接赋值 if(finish.cur != finish.last -1) &#123; construct(finish.cur,t); ++finish.cur; &#125; //否则新分配一个片段 else push_back_aux(t);&#125;void push_back_aux(const value_type&amp; t)&#123; value_type t_copy=t; //判断是否需要重新分配map reserve_map_at_back(); //为下一个节点分配一个片段 *(finish.node+1)=alocate_node(); //现在finish所指的片段已满 construct(finish.cur,t_copy); //尾迭代器指向下一个片段 finish.set_node(finish.node+1); finish.cur=finish.first;&#125;//判断尾部是否需要重新分配void reserve_map_at_back(size_type node_to_add=1)&#123; //尾部备用空间不足 if(node_to_add&gt;map_size-(finish.node-map)-1) //false尾部分配 reallocate_map(node_to_add,false);&#125;//头部操作类似，略过void reallocate_map(size_type node_to_add,bool add_at_front)&#123; size_type old_num_nodes=finish.node-start.node+1; size_type new_num_nodes=old_num_nodes+node_to_add; map_pointer new_nstart; //对应于一端插入，另一端删除时的极端情况，此时map中只有后半段的节点被利用，不需要重新申请更大的map if(map_size&gt;2*new_num_nodes) &#123; //重新安排头部节点到中间 new_nstart=map+(map_size-new_num_nodes)/2+(add_at_front?node_to_add:0); if(new_nstart&lt;start.node) //先序复制防止左边被覆盖 copy(start.node,finish.node+1,new_nstart); else //后序复制防止右边被覆盖 copy_backward(start.node,finish.node+1,new_nstart+old_num_nodes); &#125; //对应正常情况，map中空余节点不足 else &#123; size_type new_map_size=map_size+max(map_size,node_to_add)+2; //申请更大的map map_pointer new_map=map_allocator::allocate(new_map_size); //开始节点居中 new_nstart=new_map+(new_map_size-new_num_nodes)/2+(add_at_front?node_to_add:0); //复制原节点 copy(start.node,finish.node+1,new_start); //释放原map map_allocator::deallocate(map,map_size); map=new_map; map_size=new_map_size; &#125; start.set_node(new_nstart); finish.set_node(new_nstart+old_num_nodes+1);&#125; 接下来是删除操作，SGI的deque在片段中没有元素时会销毁片段以节省内存，具体实现如下，以pop_back为例： 12345678910111213141516171819202122232425void pop_back()&#123; //尾部片段有元素 if(finish.cur!=finish.first) &#123; //注意cur指向最后一个元素的下一位 --finish.cur; destroy(finish.cur); &#125; else //没有元素 pop_back_aux();&#125;void pop_back_aux()&#123; //销毁这个空片段 deallocate_node(finish.first); //跳转到上一个节点 finish.set_node(finish.node-1); finish.cur=finish.last-1; destroy(finish.cur);&#125;//pop_front类似，略过 接下来是clear方法，该方法清除deque所有元素并将deque初始化，SGI的deque在初始状态仍会保留一个片段，代码： 12345678910111213141516171819202122void clear()&#123; for(map_pointer node=start.node+1;node&lt;finish.node;++node) &#123; //析构元素 destroy(*node,*node+buffer_size()); //销毁片段 deallocate(*node,buffer_size()); &#125; //头尾不在同一个片段 if(start.node!=finish.node) &#123; destroy(start.cur,start.last); destroy(finish.first,finish.cur); //仅销毁尾部 deallocate(finish.first,buffer_size()); &#125; else //仅析构 destroy(start.cur,finish.cur); finish=start;&#125; 基本上常见的deque操作都与上面的实现类似，注意map的操作即可。 MS的deque实现MS与SGI的实现有较大区别，首先在deque内部成员上VS2013没有定义start和finish两个迭代器，而是定义了一个_Myoff记录头节点偏移量以及_Mysize记录元素数量： 12size_type _Myoff;size_type _Mysize; 在内部，deque利用_Myoff计算节点下标来访问节点： 12345size_type _Getblock(size_type off) const&#123; //_DEQUESIZE片段长度，_Mapsize代表map的大小 return ((off/_DEQUESIZE) &amp; (this-&gt;_Mapsize-1));&#125; 其次，MS的deque采用倍增的扩展策略，即每次重新分配map时大小变为原来的2倍(初始为8，不可自定义)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//VS2013void _Growmap(size_type _Count)&#123; typedef typename _Alpty::pointer _Blockptr; _Alpty _Almap(this-&gt;_Getal()); size_type _Newsize = 0 &lt; this-&gt;_Mapsize ? this-&gt;_Mapsize : 1; while (_Newsize - this-&gt;_Mapsize &lt; _Count || _Newsize &lt; _DEQUEMAPSIZ) &#123; //size加倍 _Newsize *= 2; &#125; //计算需要新增的节点数量 _Count = _Newsize - this-&gt;_Mapsize; //计算头节点偏移 size_type _Myboff = this-&gt;_Myoff / _DEQUESIZ; //申请新的map _Mapptr _Newmap = _Almap.allocate(this-&gt;_Mapsize + _Count); //新的头节点 _Mapptr _Myptr = _Newmap + _Myboff; //复制旧节点 _Myptr = _Uninitialized_copy(this-&gt;_Map + _Myboff,this-&gt;_Map + this-&gt;_Mapsize,_Myptr, _Almap); //如果新增节点数量大于头节点偏移 if (_Myboff &lt;= _Count) &#123; //复制旧map头节点之前未使用的节点到新map的尾部(意义不明，应该是为了减少初始化次数) _Myptr = _Uninitialized_copy(this-&gt;_Map,this-&gt;_Map + _Myboff,_Myptr, _Almap); //初始化剩余的尾部节点 _Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,_Almap); //初始化头部节点 _Uninitialized_default_fill_n(_Newmap, _Myboff, _Almap); &#125; else &#123; //复制旧map头部未使用的节点到新map尾部 _Uninitialized_copy(this-&gt;_Map,this-&gt;_Map + _Count,_Myptr, _Almap); //复制剩余的旧map头部到新map头部 _Myptr = _Uninitialized_copy(this-&gt;_Map + _Count, this-&gt;_Map + _Myboff,_Newmap, _Almap); //初始化新map头部未能复制到的节点 _Uninitialized_default_fill_n(_Myptr, _Count, _Almap); &#125; //析构旧map元素 _Destroy_range(this-&gt;_Map + _Myboff, this-&gt;_Map + this-&gt;_Mapsize, _Almap); //释放旧map空间 if (this-&gt;_Map != _Mapptr()) _Almap.deallocate(this-&gt;_Map,this-&gt;_Mapsize); this-&gt;_Map = _Newmap; // point at new this-&gt;_Mapsize += _Count;&#125; 相比起来MS的实现更加复杂化，结构层次也不明显，代码质量明显比SGI差很多。最后再吐槽一下MS神奇的变量命名方式以及各种奇葩#define。","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://intptrzero.github.io/tags/STL/"}]},{"title":"STL - 迭代器","slug":"STL-Iterator","date":"2019-06-08T16:06:27.000Z","updated":"2019-10-11T17:21:10.156Z","comments":true,"path":"2019/06/09/STL-Iterator/","link":"","permalink":"https://intptrzero.github.io/2019/06/09/STL-Iterator/","excerpt":"迭代器概念STL设计迭代器的初衷就是将容器细节与算法分离，转而用迭代器作为两者的桥梁。迭代器作为一种访问容器的结构，其本质上也是一种对指针的高级包装而已，因此对应于容器的结构特点，迭代器也分为单向迭代器(典型如单链表)、双向迭代器(如双链表)和随机访问迭代器(如vector等顺序存储容器)。","text":"迭代器概念STL设计迭代器的初衷就是将容器细节与算法分离，转而用迭代器作为两者的桥梁。迭代器作为一种访问容器的结构，其本质上也是一种对指针的高级包装而已，因此对应于容器的结构特点，迭代器也分为单向迭代器(典型如单链表)、双向迭代器(如双链表)和随机访问迭代器(如vector等顺序存储容器)。 迭代器的实现作为对容器元素指针的高级包装，迭代器不可避免的会暴露容器的实现细节，因此将迭代器完全脱离容器是不现实的，故STL容器都在内部实现了对应于特定容器的迭代器。为了说明迭代器的实现原理，下面以一个自定义的容器类MyList来进行演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef _MYLIST#define _MYLIST#include &lt;iostream&gt;template&lt;typename T&gt;struct MyListNode&#123; T _value; MyListNode&lt;T&gt;* _next; MyListNode():_value(0),_next(nullptr) &#123;&#125;&#125;;template&lt;typename NodeTy&gt;class MyListIter&#123;public: NodeTy* ptr; MyListIter( NodeTy* p = nullptr) :ptr(p)&#123;&#125; NodeTy&amp; operator*() const &#123; return *ptr; &#125; NodeTy* operator-&gt;() const &#123; return ptr; &#125; MyListIter&amp; operator++() &#123; ptr = ptr-&gt;_next; return *this; &#125; MyListIter operator++(int) &#123; MyListIter tmp = (*this); ++(*this); return tmp; &#125; bool operator==(const MyListIter&amp; i) const &#123; return ptr == i.ptr; &#125; bool operator!=(const MyListIter&amp; i) const &#123; return ptr != i.ptr; &#125;&#125;;template&lt;typename T&gt;class MyList&#123;private: MyListNode&lt;T&gt;* _head;public: void insert_front(T v) &#123; MyListNode&lt;T&gt;* tmp = new MyListNode&lt;T&gt;; tmp-&gt;_value = v; tmp-&gt;_next = _head-&gt;_next; _head-&gt;_next=tmp; &#125; void display(std::ostream&amp; os = std::cout) const &#123; MyListNode&lt;T&gt;* tmp = _head-&gt;_next; while (tmp) &#123; os &lt;&lt; tmp-&gt;_value&lt;&lt;\" \"; tmp = tmp-&gt;_next; &#125; &#125; MyList() &#123; _head = new MyListNode&lt;T&gt;; &#125; MyListIter&lt;MyListNode&lt;T&gt;&gt; begin() const &#123; return MyListIter&lt;MyListNode&lt;T&gt;&gt;(_head-&gt;_next); &#125; MyListIter&lt;MyListNode&lt;T&gt;&gt; end() const &#123; return MyListIter&lt;MyListNode&lt;T&gt;&gt;(nullptr); &#125;&#125;;#endif main: 12345678910111213141516171819202122232425262728#include \"mylist.h\"template&lt;typename IterTy,typename Ty&gt;IterTy find(IterTy begin,IterTy end, Ty value);int main()&#123; MyList&lt;int&gt; mylist; for (int i = 0; i &lt; 5;i++) mylist.insert_front(i); mylist.display(); auto ibegin=mylist.begin(); auto iend = mylist.end(); auto result = find(ibegin, iend, 2); std::cout &lt;&lt; result.ptr-&gt;_value;&#125;template&lt;typename IterTy, typename Ty&gt;IterTy find(IterTy begin, IterTy end, Ty value)&#123; while (begin != end) &#123; if (begin-&gt;_value == value) break; begin++; &#125; return begin;&#125; 通过上面的简单链表迭代器，我们成功实现了独立于容器的泛型算法find。上述的迭代器仅仅是个雏形，如果一个算法需要一个迭代器类型变量而返回一个迭代器指向的元素类型，在仅使用一个模板参数的情况下，上述迭代器根本不可能做到。例如： 123456789101112131415//两个参数可行template&lt;typename IterTy,typename NodeTy&gt;NodeTy somefunc(IterTy iter,NodeTy el)&#123; NodeTy tmp; ... return tmp;&#125;//一个参数无法完成template&lt;typename IterTy&gt;? somefunc(IterTy iter)&#123; ? tmp;&#125; 实际上以上问题在allocator中已经出现过，STL在allocator中的解决方法是rebind，简单来说就是将可能会用到的类型定义为内嵌类型： 1234567891011121314template&lt;typename NodeTy&gt;class MyListIter&#123;public: typedef NodeTy value_type; //...&#125;template&lt;typename IterTy&gt;typename IterTy::value_type somefunc(IterTy iter)&#123; //现在仅需要一个模板参数 typename IterTy::value_type tmp；&#125; 然而以上技巧仅适用于迭代器类，对于无法定义内嵌类型的原生指针无能为力。泛型算法不应该仅考虑到迭代器，原生指针的行为理应与迭代器类似。 Traits编程技巧Traits直译为“特性，特征”，即人为的赋予对象某些修饰，在需要的时候提取出来。显而易见，traits技术也只能用于类，仍然对原生指针束手无策。为了解决此问题，我们需要对原生指针进行一次包装，而包装方法就是使用模板偏特化： 123456789101112template&lt;typename IterTy&gt;struct iter_traits&#123; typedef typename IterTy::value_type value_type;&#125;//指针偏特化模板template&lt;typename Ty&gt;struct iter_traits&lt;Ty*&gt;&#123; typedef Ty value_type;&#125; 现在无论是原生指针还是迭代器都可以使用iter_traits::value_type获取指向的元素类型。根据编程经验，STL规定迭代器至少定义5种基本特性：value_type、difference_type、pointer、reference和iterator_category value_type:即迭代器指向的元素类型 difference_type:迭代器之间的距离 pointer:指向元素的指针 reference:元素的引用 category:迭代器类型 前面提到迭代器对应于特定容器分为单向迭代器、双向迭代器和随机访问迭代器，功能上还可分为输入迭代器和输出迭代器。很显然不同迭代器可定义的操作和效率是不同的，因此区分迭代器类型有利于提升性能。以advance()函数为例，该函数将一个给定的迭代器移动给定的距离： 123456789101112131415161718192021222324252627282930//单向迭代器template&lt;typename ForwardIter,typename Distance&gt;void advance_fiter(ForwardIter&amp; i,Distance n)&#123; while(n--) i++;&#125;//双向迭代器template&lt;typename BidIter,typename Distance&gt;void advance_biter(BidIter&amp; i,Distance n)&#123; if(n&gt;0) &#123; while(n--) i++; &#125; else &#123; while(n++) i--; &#125;&#125;//随机访问迭代器template&lt;typename RndIter,typename Distance&gt;void advance_rnditer(RndIter&amp; i,Distance n)&#123; i += n;&#125; 为了区分迭代器类型而设计三个函数显然不明智，然而上述函数都是两个模板参数的模板函数，无法重载，因此需要引入另一个不同的参数达成重载条件，STL的做法是引入一个迭代器类型参数： 123456789101112131415161718192021struct input_iterator_tag&#123;&#125;;struct output_iterator_tag&#123;&#125;;struct forward_iterator_tag:public input_iterator_tag&#123;&#125;;struct bidirectional_iterator_tag:public forward_iterator_tag&#123;&#125;;struct random_access_iterator_tag:public bidirectional)iterator_tag&#123;&#125;;//内部实现template&lt;typename InputIter,typename Distance&gt;void _advance(InputIter&amp; i,Distance n,input_iterator_tag)&#123; //...&#125;//...//外部接口template&lt;typename Iterator,Distance n&gt;void advance(Iterator&amp; i,Distance n)&#123; _advance(i,n,iterator_traits&lt;Iterator&gt;::iterator_category());&#125; 如上，通过定义几个用于标识迭代器类型的空类并作为参数启用函数重载，并在外部调用时使用traits技术获取迭代器类型，完成了不同迭代器的函数实现。并且STL迭代器类型是继承关系，利用模板协变，适用于低级迭代器的函数也可用于高级迭代器。","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://intptrzero.github.io/tags/STL/"}]},{"title":"STL - 内存分配器","slug":"STL-Allocator","date":"2019-06-01T12:37:17.000Z","updated":"2019-10-07T08:12:33.628Z","comments":true,"path":"2019/06/01/STL-Allocator/","link":"","permalink":"https://intptrzero.github.io/2019/06/01/STL-Allocator/","excerpt":"标准内存分配器定义STL容器时有一个可选参数allocator，缺省情况下使用STL自带的默认allocator类进行内存分配。allocator类在VS2013下由头文件xmemory0定义，间接由memory头文件引用。类声明节选如下：","text":"标准内存分配器定义STL容器时有一个可选参数allocator，缺省情况下使用STL自带的默认allocator类进行内存分配。allocator类在VS2013下由头文件xmemory0定义，间接由memory头文件引用。类声明节选如下： 12345678910111213141516171819202122232425262728293031323334353637383940//基类template&lt;typename _Ty&gt;struct _Allocator_base&#123; typedef _Ty value_type;&#125;//allocator类template&lt;typename _Ty&gt;class allocator:public _Allocator_base&lt;_Ty&gt;&#123;public: //STL标准需要的类型定义 typedef allocator&lt;_Ty&gt; other; typedef _Allocator_base&lt;_Ty&gt; _Mybase; typedef typename _Mybase::value_type value_type; typedef value_type *pointer; typedef const value_type *const_pointer; typedef void *void_pointer; typedef const void *const_void_pointer; typedef value_type&amp; reference; typedef const value_type&amp; const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type; //三个空构造函数 allocator() &#123;&#125; allocator(const allocator&lt;_Ty&gt;&amp;) &#123;&#125; template&lt;typename _Other&gt; allocator(const allocator&lt;_Other&gt;&amp;) &#123;&#125; //rebind template&lt;typename _Other&gt; struct rebind &#123; typedef allocator&lt;_Other&gt; other; &#125; //其它成员函数&#125; 其中略难理解的是rebind结构，rebind只有一个other成员用来代表allocator&lt;_Other&gt;，这一步貌似有点多余，何不在需要的时候直接声明一个allocator&lt;_Other&gt;类型的分配器呢。STL的allocator是为容器服务的，要弄清楚设计者的目的，需要联系容器的实现。作为普通容器如vector和array等，它们的元素是直接存储的，而list等容器有一个中间存储结构node，且node与元素类型是有关的。在分配内存时需要为节点类型node&lt;T&gt;和元素类型T传入对应的allocator，而声明list时只传入了元素类型T，因此需要某种方法根据allocator&lt;T&gt;得到allocator&lt;node&lt;T&gt;&gt;，这时rebind的作用就体现出来了。附VS2013的部分list实现代码： 123456789101112131415161718192021template&lt;class _Ty,class _Alloc0&gt; struct _List_base_types &#123; typedef _Alloc0 _Alloc; typedef _List_base_types&lt;_Ty, _Alloc&gt; _Myt; typedef _Wrap_alloc&lt;_Alloc&gt; _Alty0; //向底层元素的rebind typedef typename _Alty0::template rebind&lt;_Ty&gt;::other _Alty; typedef typename _Get_voidptr&lt;_Alty, typename _Alty::pointer&gt;::type _Voidptr; typedef _List_node&lt;typename _Alty::value_type, _Voidptr&gt; _Node; //向节点类型的rebind typedef typename _Alty::template rebind&lt;_Node&gt;::other _Alnod_type; typedef typename _Alnod_type::pointer _Nodeptr; typedef _Nodeptr&amp; _Nodepref; &#125;; rebind算是一种比较巧妙的方法，在元素与中间结构之间创建某种联系，从而达到只需要一个模板参数即可创建多级内存分配器的目的。 STL标准要求的其它函数接口实现如下： 12345678910111213141516171819202122232425262728293031323334353637void deallocate(pointer _Ptr, size_type) &#123; // deallocate object at _Ptr, ignore size ::operator delete(_Ptr); &#125;pointer allocate(size_type _Count) &#123; // allocate array of _Count elements return (_Allocate(_Count, (pointer)0)); &#125;pointer allocate(size_type _Count, const void *) &#123; // allocate array of _Count elements, ignore hint return (allocate(_Count)); &#125;void construct(_Ty *_Ptr) &#123; // default construct object at _Ptr ::new ((void *)_Ptr) _Ty(); &#125;void construct(_Ty *_Ptr, const _Ty&amp; _Val) &#123; // construct object at _Ptr with value _Val ::new ((void *)_Ptr) _Ty(_Val); &#125;template&lt;class _Objty, class... _Types&gt; void construct(_Objty *_Ptr, _Types&amp;&amp;... _Args) &#123; // construct _Objty(_Types...) at _Ptr ::new ((void *)_Ptr) _Objty(_STD forward&lt;_Types&gt;(_Args)...); &#125;template&lt;class _Uty&gt; void destroy(_Uty *_Ptr) &#123; // destroy object at _Ptr _Ptr-&gt;~_Uty(); &#125; 与SGI的二级分配器实现相比更简单，直接调用全局的operator new和delete，没有额外的内存优化。","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://intptrzero.github.io/tags/STL/"}]},{"title":"CLR - 委托与事件","slug":"CLR-Delegate","date":"2019-05-22T06:23:23.000Z","updated":"2019-11-22T08:52:48.369Z","comments":true,"path":"2019/05/22/CLR-Delegate/","link":"","permalink":"https://intptrzero.github.io/2019/05/22/CLR-Delegate/","excerpt":"委托委托实际上可以看作对C++函数指针的高级封装，只不过委托提供了编译时的类型安全。CLR的委托本质上是一个类，对委托的声明会被编译器翻译为一个继承自MulticastDelegate的派生类，代码如下:","text":"委托委托实际上可以看作对C++函数指针的高级封装，只不过委托提供了编译时的类型安全。CLR的委托本质上是一个类，对委托的声明会被编译器翻译为一个继承自MulticastDelegate的派生类，代码如下: 1delegate void MyCallback(Int32 v); 编译器实际上为上述语句生成如下代码： 1234567class MyCallback:System.MulticastDelegate&#123; public MyCallback(Object obj, IntPtr method); public virtual void Invoke(Int32 v); public virtual IAsyncResult BeginInvoke(Int32 v, AsyncCallback callback, Object obj); public virtual void EndInvoke(IAsyncResult result);&#125; MulticastDelegate类有三个重要的字段： _target：对象实例。回调静态方法时为null _methodPtr：方法指针 _invocationList：委托链，单播委托为null 例子： 12345678910111213class A&#123; public void Show(Int32 v) &#123; Console.WriteLine(v.ToString); &#125;&#125;A a=new A;MyCallback mcb=new MyCallback(a.Show);mcb(3);//输出:3 在上述代码中_target=a，_methodPtr指向Show方法。代码中mcb(3)语句实际上是个语法糖，编译器在底层将它翻译为mcb.Invoke(3)，Invoke方法使用_target与_methodPtr共同确定要调用的方法。 委托链由基类MulticastDelegate的名称很容易看出支持多个委托回调。多播委托与单播委托略有区别，由于需要保存多个回调，_target和_methodPtr显然是不够用的，因此需要使用_invocationList字段。_invocationList实际上是一个委托对象集合，每次使用Delegate.Combine方法添加委托时，方法检查被合并的委托是否为null，如果为null，则直接返回原委托，否则将构建一个新的委托对象。多播委托与单播委托使用方法一样，调用Invoke方法时，依次对每一个委托数组元素调用Invoke，因此如果委托具有返回值，将只返回最后一个执行的回调函数的返回值。Invoke方法的实现大致如下： 123456789101112public void Invoke(Int32 v)&#123; Delegate[] delegateArray = _invocationList as Delagate[] if(delegateArray != null) &#123; //多播委托依次调用每一个回调方法 foreach(MyCallback del in delgateArray) del.Invoke(v); &#125; else //单播委托直接调用回调方法&#125; 除了可以添加委托，还可以使用Delegate.Remove方法删除委托，方法查找源委托链中与目标委托签名一致的委托对象，并删除第一个匹配项。如果删除后委托链为空，则返回null。 异步委托为了便于执行耗时较长的回调，委托类提供了BeginInvoke()方法用于异步执行，其底层实现是将回调交给线程池处理。BeginInvoke接受两个额外的参数：在异步委托完成时执行的AsyncCallback类型的回调和一个用于标识的Object参数，其返回值是一个IAsyncResult类型 1234567891011interface IAsyncResult&#123; //BeginInvoke的object参数将传递给该属性 public object AsyncState&#123;get&#125;; //内核对象，异步完成时会收到信号 public WaitHandle AsyncWaitHandle&#123;get&#125;; //是否是同步完成的 public bool CompletedSynchronously &#123; get; &#125; //是否已执行完毕 public bool IsCompleted &#123; get; &#125;&#125; BeginInvoke必须用配对的EndInvoke结束异步操作，并返回异步操作的返回值。 1234567891011121314151617181920212223242526class Program&#123; static Func&lt;int,int&gt; MyAsyncWork = DoWork; static AsyncCallback MyAsyncCallback = AfterWork; static void Main() &#123; IAsyncResult ar = MyAsyncWork.BeginInvoke(100,MyAsyncCallback,\"任意自定义数据\"); //主线程结束后将看不到执行结果 Console.Read(); &#125; static int DoWork(int n) &#123; Thread.Sleep(1000); return n; &#125; static void AfterWork(IAsyncResult ar) &#123; Console.WriteLine(\"异步执行完毕\"); Console.WriteLine(\"结果是：\" + MyAsyncWork.EndInvoke(ar)); &#125;&#125;//AsyncCallback的内部定义//delegate void AsyncCallback(IAsyncResult); 事件事件实际上也是基于委托的。定义事件的一般步骤如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//定义事件参数public class MailEventArgs: EventArgs&#123; private string mFrom; private string mTo; private string mContent; public string From&#123;get&#123;return mFrom;&#125;&#125; public string To&#123;get&#123;return mTo;&#125;&#125; public string Content&#123;get&#123;return mContent;&#125;&#125;; public MailEventArgs(string from,string to,string content) &#123; mFrom=from; mTo=to; mContent=content; &#125;&#125;//定义事件public class MailBox&#123; public event EventHandler&lt;MailEventArgs&gt; MailEvent; protected virtual void OnNewMail(Object sender,MailEventArgs e) &#123; EventHandler&lt;MailEventArgs&gt; temp=Volatile.Read(ref MailEvent); if(temp!=null) temp(sender,e); &#125; public void NewMail(string from,string to,string content) &#123; MailEventArgs e=new MailEventArgs(from,to,content); OnNewMail(this,e); &#125;&#125;//注册事件处理函数static void Main()&#123; MailBox mb=new MailBox(); mb.MailEvent+=MyMailEvent_Handler; mb.NewMail(\"C#\",\"You\",\"HelloWorld\");&#125;static void MyMailEvent_Handler(Object sender,MailEventArgs e)&#123; Console.WriteLine(\"收到新消息\"); Console.WriteLine(\"From \"+e.From+\" To \"+e.To+NewLine+e.Content);&#125;/*对于下面这一事件定义public event EventHandler&lt;MailEventArgs&gt; MailEvent;编译器实际上产生以下代码private EventHandler&lt;MailEventArgs&gt; MailEvent;public void add_MailEvent(EventHandler&lt;MailEventArgs&gt; value)&#123; //注册事件回调时内部调用该方法&#125;public void remove_MailEvent(EventHandler&lt;MailEventArgs&gt; value)&#123; //移除事件回调时内部调用该方法&#125;*/ 内存优化的自定义事件不管是否订阅了事件，每个事件声明都会至少占用4个字节的内存，对于定义了大量事件的类–比如Windows控件，造成的内存浪费将非常可观。为了节省内存空间，CLR提供了EventHandlerList类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//C#private EventHandlerList Events=new EventHandlerList();//key可以是任意对象，只需要每种事件不同即可public event EventHandler Click&#123; add &#123; Events.AddHandler(key1,value); &#125; remove &#123; Events.RemoveHandler(key1,value); &#125;&#125;public event EventHandler KeyDown&#123; add &#123; Events.AddHandler(key2,value); &#125; remove &#123; Events.RemoveHandler(key2,value); &#125;&#125;protected virtual void OnClick(Object sender,EventArgs e)&#123; EventHandler temp=(EventHandler)Events[key]; temp(sender,e);&#125;//VB.NET更加简化的Custom关键字Private Events As New EventHandlerListPublic Custom Event Click As EventHandler AddHandler(ByVal value As EventHandler) Events.AddHandler(key1, value) End AddHandler RemoveHandler(ByVal value As EventHandler) Events.RemoveHandler(key1, value) End RemoveHandler RaiseEvent(ByVal sender As Object, ByVal e As EventArgs) CType(Events(key1), EventHandler).Invoke(sender, e) End RaiseEventEnd EventPublic Custom Event KeyDown As EventHandler AddHandler(ByVal value As EventHandler) Events.AddHandler(key2, value) End AddHandler RemoveHandler(ByVal value As EventHandler) Events.RemoveHandler(key2, value) End RemoveHandler RaiseEvent(ByVal sender As Object, ByVal e As EventArgs) CType(Events(key2), EventHandler).Invoke(sender, e) End RaiseEventEnd Event EventHandlerList类底层实现基于字典或者哈希表，因此当事件项数量过多时可能会有查找性能问题。","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"}]},{"title":"类与多态 - 继承","slug":"Class-Func","date":"2019-05-18T14:45:44.000Z","updated":"2019-11-17T09:30:56.359Z","comments":true,"path":"2019/05/18/Class-Func/","link":"","permalink":"https://intptrzero.github.io/2019/05/18/Class-Func/","excerpt":"类继承C++支持三种不同的继承方式：private、protected和public，继承方式只影响派生类外部对基类成员的访问权限，而不影响派生类在内部对基类成员的访问权限。私有继承意味着所有基类成员将被继承为派生类的私有成员；保护继承意味着基类所有public成员被继承为protected，其它成员不受影响；公有继承则保持基类成员的原有访问控制不变。例子：","text":"类继承C++支持三种不同的继承方式：private、protected和public，继承方式只影响派生类外部对基类成员的访问权限，而不影响派生类在内部对基类成员的访问权限。私有继承意味着所有基类成员将被继承为派生类的私有成员；保护继承意味着基类所有public成员被继承为protected，其它成员不受影响；公有继承则保持基类成员的原有访问控制不变。例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Base&#123;private: int _ID;protected: char* _Name;public: void show()&#123;cout&lt;&lt;_ID&lt;&lt;\": \"&lt;&lt;_Name;&#125;&#125;//私有继承class Child1: private Base&#123;private: //内部访问权限不受影响，可访问基类protected和public成员 void test() &#123; name=\"\"; //protected Base::name show(); //public Base::show() &#125;&#125;//保护继承同上class Child2: protected Base&#123;private: void test() &#123; name=\"\"; show(); &#125; &#125;class Child3: public Base&#123;private: void test() &#123; name=\"\"; show(); &#125; &#125;//Child1已将基类成员继承为private，CChild1显然不可访问class CChild1: public Child1&#123;private: void test() &#123; name=\"\"; //不可访问:private Child1::name show(); //不可访问:private Child1::show() &#125;&#125;//Child2是保护继承，基类非private成员均被继承为protected，CChild2显然可以访问class CChild2: public Child2&#123;private: void test() &#123; name=\"\"; //OK:protected Child2::name show(); //OK:protected Child2::show() &#125;&#125;Child1 c1;Child2 c2;c1.show(); //不可访问c2.show(); //不可访问 C++中的方法重写解释方法重写前需要弄明白函数重载与方法重写的概念。函数重载发生在同一类作用域，而方法重写发生在类继承中，即使子类用不同的参数列表重写父类方法，他也不是重载，而是重写，例如： 123456789101112131415class Base&#123;public: void show()&#123;cout&lt;&lt;\"base\";&#125;&#125;class Child: public Base&#123;public: void show(int i)&#123;cout&lt;&lt;\"child\";&#125;&#125;Child c;c.show(); //Errorc.show(0); //OK 发生重写时，函数的父类版本将被子类隐藏。 派生类重写基类虚方法时，要求子类保持方法签名一致，否则将变成上面的普通方法重写，子类将隐藏父类虚方法。例如： 12345678910111213141516171819202122232425class Base&#123;public: virtual void show() &#123;cout&lt;&lt;\"base\";&#125;&#125;//签名不一致，隐藏父类show()方法class Child: public Base&#123;public: void show(int i) &#123;cout&lt;&lt;\"child\";&#125;&#125;//重写并重载class Child1: public Base&#123;public: void show(int i) &#123;cout&lt;&lt;\"child1\";&#125; void show() &#123;cout&lt;&lt;\"child1 virtual\";&#125;&#125;Child c;c.show(); //Error.Child1 c1;c1.show(); //OK.调用Child1::show()c1.show(0); //OK.调用Child1::show(int) .NET中的函数重写当子类保持函数签名一致时，对于普通方法重写，需要显式指定new(Shadows)关键字；对于虚方法，需要显式指定override关键字 123456789101112131415161718192021222324252627282930313233343536class BaseCls&#123; public virtual void show() &#123; Console.WriteLine(\"Base\"); &#125;&#125;//虚方法重写(省略override则默认为new)class ChildCls:BaseCls&#123; public override void show() &#123; Console.WriteLine(\"Child\"); &#125;&#125;//普通重写(new可省略)class BadChildCls:BaseCls&#123; public new void show() &#123; Console.WriteLine(\"BadChild\"); &#125;&#125;BaseCls a,b;a=new ChildCls();b=new BadChildCls();a.show();b.show();/*输出：ChildBase*/ 当子类方法与父类函数签名不一致时，.NET将其视为重写+重载，而不是像C++一样简单的隐藏父类方法 12345678910111213141516171819202122232425262728293031//VB.NETClass BaseCls Public Overridable Sub Show() Console.WriteLine(\"base\") End SubEnd ClassClass Child:Inherits BaseCls Public Overloads Sub Show(Byval i as Int32) Console.WriteLine(\"child\") End SubEnd ClassDim c as New Childc.Show(0) //OKc.Show() //OK//C#class BaseCls&#123; public virtual void Show() &#123;Console.WriteLine(\"base\");&#125;&#125;class Child: BaseCls&#123; public void Show(int i) &#123;Console.WriteLine(\"child\");&#125;&#125;Child c = new Child();c.Show(); //OKc.Show(0); //OK 上述代码实际上可以拆分为： 1234567891011Class Child:Inherits BaseCls //方法重写 Public Overrides Sub Show() MyBase.Show() End Sub //函数重载 Public Overloads Sub Show(Byval i as Int32) Console.WriteLine(\"child\") End SubEnd Class 不过两者略有区别，通过查看生成的IL代码，第一种写法中Child只有Show(Int32)方法，对Show()的调用直接编译为MyBase.Show()，但使用反射仍然可以获取Child.Show()方法。","categories":[{"name":"类","slug":"类","permalink":"https://intptrzero.github.io/categories/类/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://intptrzero.github.io/tags/OOP/"}]},{"title":"CLR - 内存管理与垃圾回收","slug":"CLR-GC","date":"2019-05-12T08:12:58.000Z","updated":"2019-09-17T04:54:04.465Z","comments":true,"path":"2019/05/12/CLR-GC/","link":"","permalink":"https://intptrzero.github.io/2019/05/12/CLR-GC/","excerpt":"CLR内存分配无论是C#、VB.NET或是Java，这些所谓的高级编程语言实际上都致力于解决C++中常见的内存泄露问题，方法很简单 – 那就是剥夺程序员对于物理内存空间的直接控制权，重新虚拟一层“可控”的内存空间，并由框架(.NET的CLR以及Java的JVM)自行处理内存问题。这样虽然牺牲了一点点性能以及少许灵活性，但大大提高了安全性，更不用说框架封装所带来的便利。","text":"CLR内存分配无论是C#、VB.NET或是Java，这些所谓的高级编程语言实际上都致力于解决C++中常见的内存泄露问题，方法很简单 – 那就是剥夺程序员对于物理内存空间的直接控制权，重新虚拟一层“可控”的内存空间，并由框架(.NET的CLR以及Java的JVM)自行处理内存问题。这样虽然牺牲了一点点性能以及少许灵活性，但大大提高了安全性，更不用说框架封装所带来的便利。 类似于C++，CLR中动态分配的内存存在于一个叫做“托管堆”的地方。程序集初始化时，CLR在物理内存中划出一块作为进程的托管堆，托管堆类似于数据结构中的栈，它维护一个指针，指向下一块可被分配的内存。当使用new操作符声明新对象时，CLR首先计算对象的字节大小，然后再加上一个对象类型指针和一个同步块索引，然后检查托管堆是否拥有足够的可用空间，如果空间足够，则托管堆内部指针向后移动相应距离。 CLR垃圾回收托管堆内存不足以分配新对象时(或主动调用GC)，CLR便会发起垃圾回收。垃圾回收有许多不同的实现方法，例如COM中采用的引用计数，但引用计数无法处理循环引用的问题，即对象AB互相引用，则引用计数永远不可能为0，从而引发内存泄漏。.NET和Java都采用引用跟踪算法，即将对象变量看作“根”。在垃圾回收时CLR挂起整个线程以防止垃圾回收过程中的状态变化，CLR先将托管堆中所有对象标记为垃圾(将同步索引的某一位置为0)，然后以变量为根，向下搜索变量引用的对象和对象的成员所引用的对象，如果变量非NULL，则引用的对象被标记为非垃圾，如果对象已被标记为非垃圾，cLR跳过检查该对象的成员字段，防止循环引用造成的死循环。标记完成后，CLR将所有非垃圾对象整合到一段连续的内存空间并移动内部指针，这样可以解决传统C++中的内存碎片化问题。但整合内存意味着对象的地址发生变化，因此垃圾清理后必须恢复变量指向的对象的地址。 GC的性能优化如果每次都检查并移动托管堆中的所有对象，那么会造成比较大的性能开销，因此.NET和Java都采用了基于“代”的回收机制。“分代”的原理很简单，如果某对象经过一次垃圾回收后仍存活，则代数提高一代，而垃圾回收时优先回收第0代，理由是活的越久的对象越有可能继续存活，因此优先回收第0代有更大可能回收更多的空间。CLR将托管堆对象分为0、1、2三代，CLR对三块内存空间采取了动态负载的方案。垃圾回收时，如果第0代大部分对象都是垃圾，此时垃圾回收的代价很小(仅需要复制少量内存块以及修改少许指针)，CLR会相对分配较少的空间给第0代；反之，CLR分配较大的内存空间，以减少垃圾回收的次数。此策略也适用于1、2代。 大对象CLR将对象分为大对象和小对象，大对象是大小超过85000字节左右的对象，大对象与小对象并不在同一内存空间分配，且初始即为第2代，因为在内存中移动大对象的代价过高。 Finalize与Dispose当程序集调用非托管的本机资源对象(如File或Mutex)时，CLR只能回收托管内存，造成本机内存的泄露。因此CLR为封装的本机资源对象设计了Finalize方法，拥有该方法的对象在GC执行之后才会被CLR调用该方法，如果方法内有访问对象字段的代码，则此对象的内存并不能立即被回收，这导致对象活得更久，增加了内存消耗。Finalize被设计为只能由CLR调用，托管内存由CLR负责清理，因此Finalize负责清理非托管资源，例如文件句柄。然而Finalize只有当对象被标记为垃圾且在GC执行后才可能被调用，并且调用时间无法确定，因此有必要设计另一种由开发者精确控制的清理机制，对此CLR设计了IDisposeable接口，接口暴露Dispose方法，实现接口的对象可以由开发者主动调用Dispose方法立即执行非托管资源的清理。实现如下： 12345678910111213141516171819202122232425public class DisposablClass : IDisposable&#123; //标记是否已回收 bool disposed; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); //移除Finalize调用 &#125; ~DisposableClass() &#123; Dispose(false); &#125; private void Dispose(bool disposing) &#123; if(disposed) return; //防止多次执行 if(disposing) &#123; //TODO:释放本对象的托管资源 &#125; //TODO:释放非托管资源 disposed = true; &#125;&#125; 内部的Dispose(bool)参数用来标识被Dispose还是Finalize调用，如果是Dispose，则需要自己清理托管资源，同时移除GC对本对象的Finalize调用。如果是Finalize，则托管资源已由GC处理，只需要清理非托管资源。调用非托管资源的对象类设计原则：如果类实现了Finalize，则也应实现可控的Dispose方法，并在方法中移除GC对Finalize的调用；反之，实现了Dispose方法也应实现Finalize，以防止开发者忘记调用Dispose。","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"},{"name":"GC","slug":"GC","permalink":"https://intptrzero.github.io/tags/GC/"}]},{"title":"Leetcode - 字符串转换","slug":"Leetcode-stredis","date":"2019-04-12T04:40:11.000Z","updated":"2019-09-07T05:30:42.471Z","comments":true,"path":"2019/04/12/Leetcode-stredis/","link":"","permalink":"https://intptrzero.github.io/2019/04/12/Leetcode-stredis/","excerpt":"问题给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。","text":"问题给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。 思路对于类似第一时间想不出解法的问题，首先考虑动态规划。设dp[i][j]代表从长度i的字符串转换为长度j的字符串需要的最少操作数，若word1[i-1]==word2[j-1]，则显然最后一个字符无需任何操作，因此dp[i][j]=dp[i-1][j-1]。若word1[i-1]!=word2[j-1]，则最后一位字符需要一次操作，插入操作对应dp[i][j-1]，删除操作对应dp[i-1][j]，替换操作对应dp[i-1][j-1]，此时的状态方程为dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1。 代码(C++)12345678910111213141516int m=word1.length();int n=word2.length();int dp[m+1][n+1];for(int i=0;i&lt;=m;i++) //显然需要i次删除操作 dp[i][0]=i;for(int j=0;j&lt;=n;j++) //显然需要j次插入操作 dp[0][j]=j; for(int i=0;i&lt;m;i++) //长度比次序大一 for(int j=0;j&lt;n;j++) &#123; if(word1[i]==word2[j]) dp[i+1][j+1]=dp[i][j] //字符0对应长度1，类推 else dp[i+1][j+1]=min(min(dp[i+1][j],dp[i][j+1]),dp[i][j])+1; &#125;return dp[m][n];","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"}]},{"title":"Leetcode - 次方取模","slug":"Leetcode-superpow","date":"2019-04-08T03:30:04.000Z","updated":"2019-09-06T11:17:12.737Z","comments":true,"path":"2019/04/08/Leetcode-superpow/","link":"","permalink":"https://intptrzero.github.io/2019/04/08/Leetcode-superpow/","excerpt":"问题计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。","text":"问题计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 思路直接求a^b然后取模肯定不现实，但可以根据取模公式(a^b)%c=((a%c)^b)%c和(a*b)%c=(a%c*b%c)%c拆分计算，同时利用a^(km+n)=(a^m)^k*a^n公式对b进行逐位求次方。 代码(C++)123456789int n=b.size();int temp=1;int base=a%c;for(int i=n-1;i&gt;=0;i--)&#123; temp=pow(temp,10)%c; temp=(temp*(pow(base,b[i])%c))%c;&#125;return temp; 优化：pow函数返回值为double，且数据过大时溢出。根据快速幂算法可以进一步拆分。 快速幂12345678910111213141516171819202122232425int qpowmod(int x,int n,int vmod)&#123; int temp=1; int base=x%vmod; while(n) &#123; if(n&amp;1) temp=(temp*base)%vmod; base=(base*base)%vmod; n&gt;&gt;1; &#125; return temp;&#125;int main()&#123; int temp=1; int base=a%c; for(int i=0;i&lt;b.size();i++) //高位在前 &#123; temp=qpowmod(temp,10,c); temp=(temp*qpowmod(base,b[i],c))%c; &#125; return temp;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 重复元素III","slug":"Leetcode-KRangeT","date":"2019-04-06T13:03:30.000Z","updated":"2019-09-17T04:58:59.486Z","comments":true,"path":"2019/04/06/Leetcode-KRangeT/","link":"","permalink":"https://intptrzero.github.io/2019/04/06/Leetcode-KRangeT/","excerpt":"问题给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。","text":"问题给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。 思路 双指针：略过。 Set：维护一个大小为k的set，由于set自动排序的特性，可以找出不小于nums[i]-t的值，然后判断该值是否同时不大于nums[i]+t。 哈希+桶:将nums元素分散到大小为t+1的桶中，然后以桶id作为键，nums[i]作为值存入hash表，只需要查找nums[i]所在的桶和相邻的两个桶即可。 代码(C++)Set123456789101112if(k&lt;1 || nums.size()&lt;2 || t&lt;0) return false;set&lt;int&gt; s;for(int i=0;i&lt;nums.size();i++)&#123; auto ps=s.lower_bound(nums[i]-t); //不小于nums[i]-t if(ps!=s.end() &amp;&amp; abs((*ps)-nums[i])&lt;=t) //不大于nums[i]+t return true; s.insert(nums[i]); if(s.size()&gt;k) s.erase(nums[i-k]);&#125;return false; 哈希+桶12345678910111213141516171819202122232425int getid(int n,int s) //计算桶id，除法保证同一桶元素相差[0~s-1]&#123; return n&lt;0?(n+1)/s-1:n/s; //eg:[-s+1,-1]/s=0，如果不特殊处理则与[0,s-1]桶id混淆&#125;if(k&lt;1 || nums.size()&lt;2 || t&lt;0) return false;unordered_map&lt;int,int&gt; m;int sb=t+1; //桶大小，0~tint id;int n;for(int i=0;i&lt;nums.size();i++)&#123; n=nums[i]; id=getid(n,sb); if(m.count(id)) //同一桶必然满足条件 return true; if(m.count(id-1) &amp;&amp; n-m[id-1]&lt;=t) //左 return true; if(m.count(id+1) &amp;&amp; m[id+1]-n&lt;=t) //右 return true; m[id]=n; if(m.size()&gt;k) m.erase(m.find(getid(nums[i-k],sb)));&#125;return false;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 重复元素II","slug":"Leetcode-krepeat","date":"2019-04-04T02:09:48.000Z","updated":"2019-09-04T13:02:19.238Z","comments":true,"path":"2019/04/04/Leetcode-krepeat/","link":"","permalink":"https://intptrzero.github.io/2019/04/04/Leetcode-krepeat/","excerpt":"问题给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。","text":"问题给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。 思路 双指针：时间复杂度O(kn)，k很大时退化为O(n^2)。 哈希表：时间复杂度O(n)。 代码(C++)双指针12345678if(nums.size()&lt;2) return false;for(auto p1=nums.cbegin();p1&lt;nums.end();p1++) for(auto p2=p1+1;p2&lt;=p1+k &amp;&amp; p2&lt;nums.end();p2++) &#123; if(*p2==*p1) return true; &#125;return false; Map1234567891011if(nums.size()&lt;2) return false;unordered_map&lt;int,int&gt; m;for(int i=0;i&lt;nums.size();i++)&#123; if(m.find(nums[i])!=m.end()) return true m[nums[i]]=i; if(m.size()&gt;k) m.erase(nums[i-k]);&#125;return false; Set1234567891011if(nums.size()&lt;2) return false;unordered_set&lt;int&gt; s;for(int i=0;i&lt;nums.size();i++)&#123; if(s.find(nums[i])!=s.end()) return true s.insert(nums[i]); if(s.size()&gt;k) s.erase(nums[i-k]);&#125;return false;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 数组等和分割","slug":"Leetcode-CanSum","date":"2019-04-02T03:33:19.000Z","updated":"2019-09-04T00:52:05.296Z","comments":true,"path":"2019/04/02/Leetcode-CanSum/","link":"","permalink":"https://intptrzero.github.io/2019/04/02/Leetcode-CanSum/","excerpt":"问题给定一个只包含正整数的非空数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。","text":"问题给定一个只包含正整数的非空数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。 思路 动态规划：数组等和分割，可以拆分成能否从数组中找出和为一半的元素，显然该问题与背包问题极其相似。设dp[i][j]为是否能从数组 0 ~ i 号元素中选出和为j。分析不难发现当前数字可以选中或不选，若选中，则结果取决于dp[i-1][j-nums[i]]，若不选，则取决于dp[i-1][j]。得出状态方程dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i]] 深度优先：每个元素要么选中要么丢弃，展开得到一个二叉树，父节点取决于两个叶子节点的结果。 代码(C++)DP1234567891011121314151617181920212223242526int sum=0;const int N=nums.size();for(int i=0;i&lt;N;i++) sum+=nums[i];if(sum &amp; 1) return false;const int S=sum/2;bool dp[N][S+1];//初始化for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=S;j++) dp[i][j]=false;//第一个数(0 ~ 0)for(int j=0;j&lt;=S;j++) dp[0][j]=(j==nums[0]) ? true:false;for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=S;j++) &#123; if(j&lt;nums[i] dp[i][j]=dp[i-1][j]; //数字超过总和，只能舍弃 else dp[i][j]=dp[i-1][j-nums[i]] || dp[i-1][j]; &#125;return dp[N-1][S]; 优化：稍作分析可以看出dp[i][j]只取决于dp[i-1][j]和dp[i-1][j-nums[i]]，两者相差一行，后一步dp可以直接覆盖前一步，将二维数组压缩到一维，空间复杂度降为O(S)。进一步分析可以得知，对于本题不要求给出所有可行方案的前提下，如果在前面的规划过程中得到了dp[S]为true的结果，可以直接返回。 优化DP12345678910111213141516171819202122int sum=0;const int N=nums.size();for(int i=0;i&lt;N;i++) sum+=nums[i];if(sum &amp; 1) return false;const int S=sum/2;bool dp[S+1];//第一个元数(0 ~ 0)for(int j=0;j&lt;=S;j++) dp[j]=(j==nums[0]) ? true:false;//第一个元素等于S，满足等和分割，直接返回if(dp[s]) return true;for(int i=0;i&lt;N;i++) for(int j=S;j&gt;=nums[i];j--) //优先规划和为S的情况。j&lt;nums[i]时dp值等于前一步，直接跳过 &#123; dp[j]=dp[j-nums[i]] || d[j]; if(j==S &amp;&amp; dp[j]) return true; //已有可行方案，直接返回 &#125;return dp[S]; DFS1234567891011121314151617181920bool dfs(int i,int sum)&#123; if(sum==0) return true; if(i&lt;0 || sum&lt;0) //边界条件 return false; return dfs(i-1,sum) || dfs(i-1,sum-nums[i]); //左右分支&#125;int main()&#123; int sum=0; const int N=nums.size(); for(int i=0;i&lt;N;i++) sum+=nums[i]; if(sum &amp; 1) return false; const int S=sum/2; return dfs(N-1,S);&#125; 优化：如果用两个变量分别记录已选和丢弃元素的和，则可以实现左右剪枝。 优化DFS - 剪枝123456789101112131415161718192021222324bool dfs(int i,int sumL,int sumR) //左分支选中，右分支丢弃&#123; if(sumL&gt;S || sumR&gt;S || i&lt;0) //丢弃或已选元素之和超过目标，直接剪枝 return false; if(sumL==S || sumR==S) return true; return dfs(i-1,sumL+nums[i],sumR) || dfs(i-1,sumL,sumR+nums[i]);&#125;int S;int main()&#123; int sum=0; const int N=nums.size(); for(int i=0;i&lt;N;i++) sum+=nums[i]; if(sum &amp; 1) return false; S=sum/2; sort(nums.begin(),nums.end()); //预排序 if(nums.back()&gt;S) //最大元素超过目标值 return false; return dfs(N-1,0,0);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"},{"name":"DFS","slug":"DFS","permalink":"https://intptrzero.github.io/tags/DFS/"}]},{"title":"动态规划 - 背包问题","slug":"DP-zoPack","date":"2019-03-14T10:52:53.000Z","updated":"2019-09-01T15:50:35.100Z","comments":true,"path":"2019/03/14/DP-zoPack/","link":"","permalink":"https://intptrzero.github.io/2019/03/14/DP-zoPack/","excerpt":"问题有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。","text":"问题有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。 分析类似问题如果用暴力求解时间复杂度将不可接受。分析问题发现，对于选定的物品，其状态只有两种 – 拿走或放弃，这是一个很明显的动态规划问题。设dp[i][j]为剩余可选物品数量 i 和剩余空间 j 时的物品价值，则很显然有状态方程：dp[i][j] = max[dp[i - 1][j], dp[i - 1][j - w[i-1]]+v[i-1]]. 前者对应放弃物品，因此背包剩余容量不变。后者对应拿走物品，背包容量减少，总价值加上选中物品价值。 代码C++123456789101112131415161718192021222324252627282930313233int dp[S+1][P+1];int pick[S]; //保存选中物品//初始化for(int i=0;i&lt;S;i++) pick[i]=0;for (int i = 0; i &lt;= S; i++) dp[i][0] = 0;for (int i = 0; i &lt;= P; i++) dp[0][i] = 0;//DPfor (int i = 1; i &lt;= S; i++) for (int j = 1; j &lt;= P; j++) &#123; if (j &lt; w[i - 1]) //背包空间不足 &#123; dp[i][j] = dp[i - 1][j]; continue; &#125; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]); &#125;//反向查找选中物品int j = P;for (int i = S; i &gt;0; i--)&#123; if (dp[i][j] &gt; dp[i - 1][j]) &#123; pick[i - 1] = 1; j -= w[i - 1]; if (j&lt;=0) break; &#125;&#125; 难点：从剩余物品中取时容易理解成贪心算法，每一步DP实际上是从第一个物品选到当前物品","categories":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"}]},{"title":"Leetcode - 两数之和","slug":"Leetcode-twoSum","date":"2019-02-28T11:11:38.000Z","updated":"2019-09-01T13:39:56.116Z","comments":true,"path":"2019/02/28/Leetcode-twoSum/","link":"","permalink":"https://intptrzero.github.io/2019/02/28/Leetcode-twoSum/","excerpt":"问题给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。","text":"问题给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 思路 先将两数相加，再提取各位数字组成新链表。 优点：代码简单 缺点：无法用于大数计算 边遍历边相加，同时构建链表节点。需要考虑进位问题。 代码C++1234567891011121314151617181920212223242526272829303132bool flag = false;ListNode* L3 = L2;ListNode* cur=nullptr;unsigned short val = 0;while (L2 || L1)&#123; if (L2) &#123; cur = L2; //保存当前位置 val = cur-&gt;val + flag; L2 = L2-&gt;next; &#125; else &#123; cur-&gt;next = L1; //L2比L1短，直接链接到L1 cur = L1; val = flag; &#125; if (L1) &#123; val += L1-&gt;val; L1 = L1-&gt;next; &#125; cur-&gt;val = val % 10; (val &gt; 9) ? flag = 1 : flag = 0;&#125;if (L1 == 0 &amp;&amp; L2 == 0 &amp;&amp; flag == 1) cur-&gt;next = new ListNode(1);return L3; CSharp123456789101112131415161718192021222324252627282930int flag = 0;int val = 0;ListNode L3=L2;ListNode cur=new ListNode(0);while( L2!=null|| L1!=null)&#123; if(L2!=null) &#123; cur = L2; val = cur.val+flag; L2 = L2.next; &#125; else &#123; cur.next = L1; cur = L1; val = flag; &#125; if(L1!=null) &#123; val += L1.val; L1 = L1.next; &#125; cur.val = val % 10; flag = val &gt; 9 ? 1 : 0;&#125;if (L1 == null &amp;&amp; L2 == null &amp;&amp; flag == 1) cur.next = new ListNode(1);return L3; 考查点：单链表、大数计算","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"C++泛型基础 - 模板","slug":"C-Template","date":"2018-12-28T02:40:23.000Z","updated":"2019-10-12T10:46:04.077Z","comments":true,"path":"2018/12/28/C-Template/","link":"","permalink":"https://intptrzero.github.io/2018/12/28/C-Template/","excerpt":"函数模板隐式实例化与显式实例化常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2);","text":"函数模板隐式实例化与显式实例化常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2); 模板实际上并不是一个可以直接调用的函数，只有首次使用函数时，编译器才根据参数类型生成一个对应版本的函数实例，然后调用该函数，这个过程称为隐式实例化。C++ 11新增显式实例化: 1template int add(int, int); 该语句提示编译器强制生成一个int版本的模板函数实例，而不管接下来有没有用到该版本的函数。显式实例化可以用于模板函数的声明与定义分离，例如在头文件中声明函数模板，在源文件中定义函数体。 123456789101112131415161718192021222324//头文件 声明template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2);//源文件 定义template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2)&#123; arg1=arg1^arg2; arg2=arg1^arg2; arg1=arg1^arg2;&#125;//不包含此显式实例化将产生link_errortemplate void myswap(int,int);//main.cpp#include \"myswap.h\"int main()&#123; int a,b; a=1,b=2; myswap(a,b) return 0;&#125; 在模板实现文件中显式具体化后强制生成了对应函数实例，main中调用myswap函数时，编译器虽然无法访问函数定义生成main自己的函数实例，但在链接阶段找到了myswap.obj中签名相符的函数实例，因此链接通过。显式实例化避免了重复实例化，缺点是必须在模板实现文件中实例化所有需要的版本，适用于重载需求较少的模板。 显式实例化与具体化模板只能解决“普遍情况”下的问题，对于特殊参数类型，通用模板就无法工作。为了解决类似的“具体”问题，需要为对应的参数类型实现“具体化”的模板定义： 1234template&lt;&gt; char* add(char* pc1, char* pc2)&#123; //...&#125; 显而易见，具体化的模板优先级高于普通模板。如果在同一编译单元同时存在签名相同的显式实例化与具体化，且显式实例化在具体化之前，则会引发重复定义错误，原因是编译器先显式实例化生成了函数实例，但接下来的语句出现了优先级更高的具体化模板，编译器尝试以具体化模板生成函数实例，但已存在相同签名的函数实例，因此引发重复定义错误。反之编译器先以具体化模板为原型生成函数实例，则会跳过优先级较低的显式实例化，编译通过。 12345678910111213141516//通用模板template&lt;typename T&gt;T add(T arg1, T arg2);//a.显式实例化template int add(int, int);//b.相同签名的具体化模板template&lt;&gt; int add(int, int);//交换ab的次序则编译通过int main()&#123; int a=1,b=2; add(a,b); //使用该签名的函数引发重复定义&#125;//模板定义/*......... 模板调用优先级如果同时存在参数类型匹配的非模板函数、普通模板、具体化模板，则非模板 &gt;具体化模板 &gt;通用模板，其中具体化模板参数越具体，其优先级越高。调用时也可以强制使用模板函数，此时只考虑模板的优先级。 1234567int main()&#123; int a=1,b=2; add(a,b); //优先调用非模板add(int,int) add&lt;&gt;(a,b); //强制使用模板，类型自动推断 add&lt;int&gt;(a,b); //使用模板，显式指定模板参数类型为int&#125; 类模板偏特化类模板与函数模板使用方法类似，不过类模板多一个偏特化(或者叫部分具体化)语法： 12345678910111213//通用模板template&lt;typename T&gt;class MyClass&#123; //...&#125;//偏特化模板，特化为指针template&lt;typename T&gt;class MyClass&lt;T*&gt;&#123; //...&#125; 偏特化可以看作是对模板的进一步具体，介于完全具体与完全泛化之间。函数模板没有偏特化语法，因为可以用函数模板重载来实现一样的效果： 123456789101112131415161718template&lt;typename T&gt;void MyFunc(T);//非法使用显式模板参数template&lt;typename T&gt;void MyFunc&lt;T*&gt;(T*);//OK，这是另一种具体化语法，可省略&lt;char*&gt;template&lt;&gt;void MyFunc&lt;char*&gt;(char*);//OK，构成模板重载template&lt;typename T&gt;void MyFunc(T*);//不推荐。编译器将它看作显式实例化，忽略&lt;typename T&gt;以及函数定义。template&lt;typename T&gt;void MyFunc(char*); 以上代码测试结果均来自VS2013，具体情形以编译器实现为准","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"泛型","slug":"泛型","permalink":"https://intptrzero.github.io/tags/泛型/"}]}]}