{"meta":{"title":"IntPtr.Zero","subtitle":"IntPtr.Zero的博客","description":"Code and Learn","author":"IntPtr.Zero","url":"https://intptrzero.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-08-31T14:10:44.186Z","updated":"2019-08-31T14:10:44.186Z","comments":true,"path":"404.html","permalink":"https://intptrzero.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，你访问的页面不存在 前方可能正在施工，你可以在下面报告错误"},{"title":"关于","date":"2019-08-31T14:11:00.661Z","updated":"2019-08-31T14:11:00.661Z","comments":true,"path":"about/index.html","permalink":"https://intptrzero.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 兴趣广泛，专注Windows平台，主要使用C++/.NET，喜欢研究底层。破解爱好者 关于博客本站使用 Hexo 主题 Material X感谢 Github 提供的空间支持以及 Gitalk 评论插件Gitalk表情食用方法：查看Gitalk支持的emoji列表，在评论框输入对应代码即可◕‿-欢迎交流、分享与评论"},{"title":"文章分类","date":"2019-08-31T14:11:14.554Z","updated":"2019-08-31T14:11:14.554Z","comments":true,"path":"categories/index.html","permalink":"https://intptrzero.github.io/categories/index.html","excerpt":"","text":""},{"title":"推荐链接","date":"2019-09-02T03:48:58.510Z","updated":"2019-09-02T03:48:58.510Z","comments":true,"path":"links/index.html","permalink":"https://intptrzero.github.io/links/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-08-31T14:12:04.165Z","updated":"2019-08-31T14:12:04.165Z","comments":true,"path":"tags/index.html","permalink":"https://intptrzero.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode - 字符串转换","slug":"Leetcode-stredis","date":"2019-04-12T04:40:11.000Z","updated":"2019-09-07T05:30:42.471Z","comments":true,"path":"2019/04/12/Leetcode-stredis/","link":"","permalink":"https://intptrzero.github.io/2019/04/12/Leetcode-stredis/","excerpt":"问题给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。","text":"问题给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。 思路对于类似第一时间想不出解法的问题，首先考虑动态规划。设dp[i][j]代表从长度i的字符串转换为长度j的字符串需要的最少操作数，若word1[i-1]==word2[j-1]，则显然最后一个字符无需任何操作，因此dp[i][j]=dp[i-1][j-1]。若word1[i-1]!=word2[j-1]，则最后一位字符需要一次操作，插入操作对应dp[i][j-1]，删除操作对应dp[i-1][j]，替换操作对应dp[i-1][j-1]，此时的状态方程为dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1。 代码(C++)12345678910111213141516int m=word1.length();int n=word2.length();int dp[m+1][n+1];for(int i=0;i&lt;=m;i++) //显然需要i次删除操作 dp[i][0]=i;for(int j=0;j&lt;=n;j++) //显然需要j次插入操作 dp[0][j]=j; for(int i=0;i&lt;m;i++) //长度比次序大一 for(int j=0;j&lt;n;j++) &#123; if(word1[i]==word2[j]) dp[i+1][j+1]=dp[i][j] //字符0对应长度1，类推 else dp[i+1][j+1]=min(min(dp[i+1][j],dp[i][j+1]),dp[i][j])+1; &#125;return dp[m][n];","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"}]},{"title":"Leetcode - 次方取模","slug":"Leetcode-superpow","date":"2019-04-08T03:30:04.000Z","updated":"2019-09-06T11:17:12.737Z","comments":true,"path":"2019/04/08/Leetcode-superpow/","link":"","permalink":"https://intptrzero.github.io/2019/04/08/Leetcode-superpow/","excerpt":"问题计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。","text":"问题计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 思路直接求a^b然后取模肯定不现实，但可以根据取模公式(a^b)%c=((a%c)^b)%c和(a*b)%c=(a%c*b%c)%c拆分计算，同时利用a^(km+n)=(a^m)^k*a^n公式对b进行逐位求次方。 代码(C++)123456789int n=b.size();int temp=1;int base=a%c;for(int i=n-1;i&gt;=0;i--)&#123; temp=pow(temp,10)%c; temp=(temp*(pow(base,b[i])%c))%c;&#125;return temp; 优化：pow函数返回值为double，且数据过大时溢出。根据快速幂算法可以进一步拆分。 快速幂12345678910111213141516171819202122232425int qpowmod(int x,int n,int vmod)&#123; int temp=1; int base=x%vmod; while(n) &#123; if(n&amp;1) temp=(temp*base)%vmod; base=(base*base)%vmod; n&gt;&gt;1; &#125; return temp;&#125;int main()&#123; int temp=1; int base=a%c; for(int i=0;i&lt;b.size();i++) //高位在前 &#123; temp=qpowmod(temp,10,c); temp=(temp*qpowmod(base,b[i],c))%c; &#125; return temp;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 重复元素III","slug":"Leetcode-KRangeT","date":"2019-04-06T13:03:30.000Z","updated":"2019-09-04T14:14:58.285Z","comments":true,"path":"2019/04/06/Leetcode-KRangeT/","link":"","permalink":"https://intptrzero.github.io/2019/04/06/Leetcode-KRangeT/","excerpt":"题目给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。","text":"题目给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。 思路 双指针：略过。 Set：维护一个大小为k的set，由于set自动排序的特性，可以找出不小于nums[i]-t的值，然后判断该值是否同时不大于nums[i]+t。 哈希+桶:将nums元素分散到大小为t+1的桶中，然后以桶id作为键，nums[i]作为值存入hash表，只需要查找nums[i]所在的桶和相邻的两个桶即可。 代码(C++)Set123456789101112if(k&lt;1 || nums.size()&lt;2 || t&lt;0) return false;set&lt;int&gt; s;for(int i=0;i&lt;nums.size();i++)&#123; auto ps=s.lower_bound(nums[i]-t); //不小于nums[i]-t if(ps!=s.end() &amp;&amp; abs((*ps)-nums[i])&lt;=t) //不大于nums[i]+t return true; s.insert(nums[i]); if(s.size()&gt;k) s.erase(nums[i-k]);&#125;return false; 哈希+桶12345678910111213141516171819202122232425int getid(int n,int s) //计算桶id，除法保证同一桶元素相差[0~s-1]&#123; return n&lt;0?(n+1)/s-1:n/s; //eg:[-s+1,-1]/s=0，如果不特殊处理则与[0,s-1]桶id混淆&#125;if(k&lt;1 || nums.size()&lt;2 || t&lt;0) return false;unordered_map&lt;int,int&gt; m;int sb=t+1; //桶大小，0~tint id;int n;for(int i=0;i&lt;nums.size();i++)&#123; n=nums[i]; id=getid(n,sb); if(m.count(id)) //同一桶必然满足条件 return true; if(m.count(id-1) &amp;&amp; n-m[id-1]&lt;=t) //左 return true; if(m.count(id+1) &amp;&amp; m[id+1]-n&lt;=t) //右 return true; m[id]=n; if(m.size()&gt;k) m.erase(m.find(getid(nums[i-k],sb)));&#125;return false;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 重复元素II","slug":"Leetcode-krepeat","date":"2019-04-04T02:09:48.000Z","updated":"2019-09-04T13:02:19.238Z","comments":true,"path":"2019/04/04/Leetcode-krepeat/","link":"","permalink":"https://intptrzero.github.io/2019/04/04/Leetcode-krepeat/","excerpt":"问题给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。","text":"问题给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。 思路 双指针：时间复杂度O(kn)，k很大时退化为O(n^2)。 哈希表：时间复杂度O(n)。 代码(C++)双指针12345678if(nums.size()&lt;2) return false;for(auto p1=nums.cbegin();p1&lt;nums.end();p1++) for(auto p2=p1+1;p2&lt;=p1+k &amp;&amp; p2&lt;nums.end();p2++) &#123; if(*p2==*p1) return true; &#125;return false; Map1234567891011if(nums.size()&lt;2) return false;unordered_map&lt;int,int&gt; m;for(int i=0;i&lt;nums.size();i++)&#123; if(m.find(nums[i])!=m.end()) return true m[nums[i]]=i; if(m.size()&gt;k) m.erase(nums[i-k]);&#125;return false; Set1234567891011if(nums.size()&lt;2) return false;unordered_set&lt;int&gt; s;for(int i=0;i&lt;nums.size();i++)&#123; if(s.find(nums[i])!=s.end()) return true s.insert(nums[i]); if(s.size()&gt;k) s.erase(nums[i-k]);&#125;return false;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 数组等和分割","slug":"Leetcode-CanSum","date":"2019-04-02T03:33:19.000Z","updated":"2019-09-04T00:52:05.296Z","comments":true,"path":"2019/04/02/Leetcode-CanSum/","link":"","permalink":"https://intptrzero.github.io/2019/04/02/Leetcode-CanSum/","excerpt":"问题给定一个只包含正整数的非空数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。","text":"问题给定一个只包含正整数的非空数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。 思路 动态规划：数组等和分割，可以拆分成能否从数组中找出和为一半的元素，显然该问题与背包问题极其相似。设dp[i][j]为是否能从数组 0 ~ i 号元素中选出和为j。分析不难发现当前数字可以选中或不选，若选中，则结果取决于dp[i-1][j-nums[i]]，若不选，则取决于dp[i-1][j]。得出状态方程dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i]] 深度优先：每个元素要么选中要么丢弃，展开得到一个二叉树，父节点取决于两个叶子节点的结果。 代码(C++)DP1234567891011121314151617181920212223242526int sum=0;const int N=nums.size();for(int i=0;i&lt;N;i++) sum+=nums[i];if(sum &amp; 1) return false;const int S=sum/2;bool dp[N][S+1];//初始化for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=S;j++) dp[i][j]=false;//第一个数(0 ~ 0)for(int j=0;j&lt;=S;j++) dp[0][j]=(j==nums[0]) ? true:false;for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=S;j++) &#123; if(j&lt;nums[i] dp[i][j]=dp[i-1][j]; //数字超过总和，只能舍弃 else dp[i][j]=dp[i-1][j-nums[i]] || dp[i-1][j]; &#125;return dp[N-1][S]; 优化：稍作分析可以看出dp[i][j]只取决于dp[i-1][j]和dp[i-1][j-nums[i]]，两者相差一行，后一步dp可以直接覆盖前一步，将二维数组压缩到一维，空间复杂度降为O(S)。进一步分析可以得知，对于本题不要求给出所有可行方案的前提下，如果在前面的规划过程中得到了dp[S]为true的结果，可以直接返回。 优化DP12345678910111213141516171819202122int sum=0;const int N=nums.size();for(int i=0;i&lt;N;i++) sum+=nums[i];if(sum &amp; 1) return false;const int S=sum/2;bool dp[S+1];//第一个元数(0 ~ 0)for(int j=0;j&lt;=S;j++) dp[j]=(j==nums[0]) ? true:false;//第一个元素等于S，满足等和分割，直接返回if(dp[s]) return true;for(int i=0;i&lt;N;i++) for(int j=S;j&gt;=nums[i];j--) //优先规划和为S的情况。j&lt;nums[i]时dp值等于前一步，直接跳过 &#123; dp[j]=dp[j-nums[i]] || d[j]; if(j==S &amp;&amp; dp[j]) return true; //已有可行方案，直接返回 &#125;return dp[S]; DFS1234567891011121314151617181920bool dfs(int i,int sum)&#123; if(sum==0) return true; if(i&lt;0 || sum&lt;0) //边界条件 return false; return dfs(i-1,sum) || dfs(i-1,sum-nums[i]); //左右分支&#125;int main()&#123; int sum=0; const int N=nums.size(); for(int i=0;i&lt;N;i++) sum+=nums[i]; if(sum &amp; 1) return false; const int S=sum/2; return dfs(N-1,S);&#125; 优化：如果用两个变量分别记录已选和丢弃元素的和，则可以实现左右剪枝。 优化DFS - 剪枝123456789101112131415161718192021222324bool dfs(int i,int sumL,int sumR) //左分支选中，右分支丢弃&#123; if(sumL&gt;S || sumR&gt;S || i&lt;0) //丢弃或已选元素之和超过目标，直接剪枝 return false; if(sumL==S || sumR==S) return true; return dfs(i-1,sumL+nums[i],sumR) || dfs(i-1,sumL,sumR+nums[i]);&#125;int S;int main()&#123; int sum=0; const int N=nums.size(); for(int i=0;i&lt;N;i++) sum+=nums[i]; if(sum &amp; 1) return false; S=sum/2; sort(nums.begin(),nums.end()); //预排序 if(nums.back()&gt;S) //最大元素超过目标值 return false; return dfs(N-1,0,0);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"},{"name":"DFS","slug":"DFS","permalink":"https://intptrzero.github.io/tags/DFS/"}]},{"title":"动态规划 - 背包问题","slug":"DP-zoPack","date":"2019-03-14T10:52:53.000Z","updated":"2019-09-01T15:50:35.100Z","comments":true,"path":"2019/03/14/DP-zoPack/","link":"","permalink":"https://intptrzero.github.io/2019/03/14/DP-zoPack/","excerpt":"问题有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。","text":"问题有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。 分析类似问题如果用暴力求解时间复杂度将不可接受。分析问题发现，对于选定的物品，其状态只有两种 – 拿走或放弃，这是一个很明显的动态规划问题。设dp[i][j]为剩余可选物品数量 i 和剩余空间 j 时的物品价值，则很显然有状态方程：dp[i][j] = max[dp[i - 1][j], dp[i - 1][j - w[i-1]]+v[i-1]]. 前者对应放弃物品，因此背包剩余容量不变。后者对应拿走物品，背包容量减少，总价值加上选中物品价值。 代码C++123456789101112131415161718192021222324252627282930313233int dp[S+1][P+1];int pick[S]; //保存选中物品//初始化for(int i=0;i&lt;S;i++) pick[i]=0;for (int i = 0; i &lt;= S; i++) dp[i][0] = 0;for (int i = 0; i &lt;= P; i++) dp[0][i] = 0;//DPfor (int i = 1; i &lt;= S; i++) for (int j = 1; j &lt;= P; j++) &#123; if (j &lt; w[i - 1]) //背包空间不足 &#123; dp[i][j] = dp[i - 1][j]; continue; &#125; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]); &#125;//反向查找选中物品int j = P;for (int i = S; i &gt;0; i--)&#123; if (dp[i][j] &gt; dp[i - 1][j]) &#123; pick[i - 1] = 1; j -= w[i - 1]; if (j&lt;=0) break; &#125;&#125; 难点：从剩余物品中取时容易理解成贪心算法，每一步DP实际上是从第一个物品选到当前物品","categories":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"}]},{"title":"Leetcode - 两数之和","slug":"Leetcode-twoSum","date":"2019-02-28T11:11:38.000Z","updated":"2019-09-01T13:39:56.116Z","comments":true,"path":"2019/02/28/Leetcode-twoSum/","link":"","permalink":"https://intptrzero.github.io/2019/02/28/Leetcode-twoSum/","excerpt":"问题给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。","text":"问题给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 思路 先将两数相加，再提取各位数字组成新链表。 优点：代码简单 缺点：无法用于大数计算 边遍历边相加，同时构建链表节点。需要考虑进位问题。 代码C++1234567891011121314151617181920212223242526272829303132bool flag = false;ListNode* L3 = L2;ListNode* cur=nullptr;unsigned short val = 0;while (L2 || L1)&#123; if (L2) &#123; cur = L2; //保存当前位置 val = cur-&gt;val + flag; L2 = L2-&gt;next; &#125; else &#123; cur-&gt;next = L1; //L2比L1短，直接链接到L1 cur = L1; val = flag; &#125; if (L1) &#123; val += L1-&gt;val; L1 = L1-&gt;next; &#125; cur-&gt;val = val % 10; (val &gt; 9) ? flag = 1 : flag = 0;&#125;if (L1 == 0 &amp;&amp; L2 == 0 &amp;&amp; flag == 1) cur-&gt;next = new ListNode(1);return L3; CSharp123456789101112131415161718192021222324252627282930int flag = 0;int val = 0;ListNode L3=L2;ListNode cur=new ListNode(0);while( L2!=null|| L1!=null)&#123; if(L2!=null) &#123; cur = L2; val = cur.val+flag; L2 = L2.next; &#125; else &#123; cur.next = L1; cur = L1; val = flag; &#125; if(L1!=null) &#123; val += L1.val; L1 = L1.next; &#125; cur.val = val % 10; flag = val &gt; 9 ? 1 : 0;&#125;if (L1 == null &amp;&amp; L2 == null &amp;&amp; flag == 1) cur.next = new ListNode(1);return L3; 考查点：单链表、大数计算","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"C++模板与泛型 - 函数模板","slug":"C-FunTemplate","date":"2018-12-28T02:40:23.000Z","updated":"2019-09-01T13:44:13.543Z","comments":true,"path":"2018/12/28/C-FunTemplate/","link":"","permalink":"https://intptrzero.github.io/2018/12/28/C-FunTemplate/","excerpt":"隐式实例化与显式实例化函数模板解决的是不同参数类型的函数重载问题，常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2);","text":"隐式实例化与显式实例化函数模板解决的是不同参数类型的函数重载问题，常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2); 模板实际上并不是一个可以直接调用的函数，只有首次使用函数时，编译器才根据参数类型自动生成一个对应版本的函数定义，然后调用该函数，这个过程称为隐式实例化。C++ 11新增显式实例化: 1template int add(int, int); 该语句提示编译器强制生成一个int版本的模板函数实例，而不管接下来有没有用到该版本。显式实例化可以用于模板函数的声明与定义分离，例如在头文件中声明一个函数模板，则必须同时包含其定义，否则将会产生链接错误。 123456789101112131415161718192021222324252627282930//myswap.h 声明template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2);//1.不包含定义产生link_error/*&#123; arg1=arg1^arg2; arg2=arg1^arg2; arg1=arg1^arg2;&#125;*///myswap.cpp 定义template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2)&#123; arg1=arg1^arg2; arg2=arg1^arg2; arg1=arg1^arg2;&#125;//2.不包含显式实例化产生link_error/*template void myswap(int,int);*///main.cpp#include \"myswap.h\"int main()&#123; int a,b; a=1,b=2; myswap(a,b) return 0;&#125; 对于情形1，编译阶段找不到模板定义，无法生成对应的函数实例。如果在头文件包含函数定义，每个使用了myswap函数的源文件都会在自己的编译单元生成函数实例，导致执行文件变大。对于情形2，在模板实现文件中仅包含定义，由于main无法访问myswap.cpp，同样产生link_error，一种解决方法是在main中包含myswap.cpp文件，这种方法有违C++的编程规范，同样无法避免重复生成函数实例的问题。在模板实现文件中显式具体化后强制生成了对应函数实例，main中调用myswap函数时，编译器无法访问函数定义生成main自己的函数实例，但在链接阶段找到了myswap.obj中签名相符的函数实例，因此链接通过。显式实例化避免了重复实例化，缺点是必须在模板实现文件中实例化所有需要的版本，适用于重载需求较少的模板。 显式实例化与具体化模板只能解决“普遍情况”下的重载问题，对于特殊参数类型，例如实现指针的加法(虽然没有意义)，通用模板就无法工作，因为指针没有重载加法操作符。为了解决类似的“具体”问题，需要为对应的参数类型实现“具体化”的模板定义： 1234template&lt;&gt; int* add(int* pint1, int* pint2)&#123; return (int*)((int)pint1 + (int)pint2);&#125; 显而易见，具体化的模板优先级高于普通模板。如果在同一编译单元同时存在签名相同的显式实例化与具体化，且显式实例化在具体化之前，则会引发重复定义错误，原因是编译器显式实例化生成了函数实例，但接下来的语句出现了优先级更高的具体化模板，编译器尝试以具体化模板生成函数实例，但已存在相同签名的函数实例，因此引发错误。反之编译器先以具体化模板为原型生成函数实例，则会跳过优先级较低的显式实例化，编译通过。 12345678910111213141516//通用模板template&lt;typename T&gt;T add(T arg1, T arg2);//a.显式实例化template int add(int, int);//b.相同签名的具体化模板template&lt;&gt; int add(int, int);//交换ab的次序则编译通过int main()&#123; int a=1,b=2; add(a,b); //使用该签名的函数引发重复定义&#125;//模板定义/*......... 函数调用优先级如果同时存在相同签名的非模板函数、普通模板、具体化模板，则非模板 &gt;具体化模板 &gt;普通模板。调用时也可以指定使用模板函数，此时只考虑模板的优先级。 12345int main()&#123; int a=1,b=2; add&lt;int&gt;(a,b); //强制使用模板。省略int将自动推断&#125; 以上代码测试结果来自VS2013","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"泛型","slug":"泛型","permalink":"https://intptrzero.github.io/tags/泛型/"}]}]}