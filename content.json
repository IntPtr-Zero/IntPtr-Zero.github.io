{"meta":{"title":"IntPtr.Zero","subtitle":"IntPtr.Zero的博客","description":"Code and Learn","author":"IntPtr.Zero","url":"https://intptrzero.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-08-31T14:10:44.186Z","updated":"2019-08-31T14:10:44.186Z","comments":true,"path":"404.html","permalink":"https://intptrzero.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，你访问的页面不存在 前方可能正在施工，你可以在下面报告错误"},{"title":"关于","date":"2019-08-31T14:11:00.661Z","updated":"2019-08-31T14:11:00.661Z","comments":true,"path":"about/index.html","permalink":"https://intptrzero.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 兴趣广泛，专注Windows平台，主要使用C++/.NET，喜欢研究底层。破解爱好者 关于博客本站使用 Hexo 主题 Material X感谢 Github 提供的空间支持以及 Gitalk 评论插件Gitalk表情食用方法：查看Gitalk支持的emoji列表，在评论框输入对应代码即可◕‿-欢迎交流、分享与评论"},{"title":"文章分类","date":"2019-08-31T14:11:14.554Z","updated":"2019-08-31T14:11:14.554Z","comments":true,"path":"categories/index.html","permalink":"https://intptrzero.github.io/categories/index.html","excerpt":"","text":""},{"title":"推荐链接","date":"2019-09-02T03:48:58.510Z","updated":"2019-09-02T03:48:58.510Z","comments":true,"path":"links/index.html","permalink":"https://intptrzero.github.io/links/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-08-31T14:12:04.165Z","updated":"2019-08-31T14:12:04.165Z","comments":true,"path":"tags/index.html","permalink":"https://intptrzero.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"STL - Deque","slug":"STL-Deque","date":"2019-07-02T17:26:51.000Z","updated":"2019-10-16T22:26:31.254Z","comments":true,"path":"2019/07/03/STL-Deque/","link":"","permalink":"https://intptrzero.github.io/2019/07/03/STL-Deque/","excerpt":"双端队列简介顾名思义，deque支持在头尾进行插入删除操作。类似于vector和array，deque也是顺序存储结构，没有了解过deque的人在主观上可能会以为deque与vector底层结构类似，实际上为了支持头部插入与删除操作，deque采用分段连续存储的数据结构，因此实现上比vector复杂得多。因为采用分段设计，deque的迭代器效率比vector低。为了管理片段，STL的deque在内部定义了一个_Map成员，_Map底层实际是一个T**，也可以将_Map看作一个数组，每一个数组元素指向内存中的一段连续的元素存储空间","text":"双端队列简介顾名思义，deque支持在头尾进行插入删除操作。类似于vector和array，deque也是顺序存储结构，没有了解过deque的人在主观上可能会以为deque与vector底层结构类似，实际上为了支持头部插入与删除操作，deque采用分段连续存储的数据结构，因此实现上比vector复杂得多。因为采用分段设计，deque的迭代器效率比vector低。为了管理片段，STL的deque在内部定义了一个_Map成员，_Map底层实际是一个T**，也可以将_Map看作一个数组，每一个数组元素指向内存中的一段连续的元素存储空间 123456789//VS2013 deque节选template&lt;class _Ty&gt; struct _Deque_simple_types : public _Simple_types&lt;_Ty&gt; &#123; // wraps types needed by iterators typedef _Ty **_Mapptr; &#125;;_Mapptr _Map; 双端队列的迭代器deque分类上属于顺序存储容器，因此迭代器理所应当提供随机访问迭代器的所有功能。但在内部deque是分段的，因此迭代器需要知道片段的大小以及片段的地址，以在到达片段边缘时跳转到另一个片段。SGI的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859template&lt;typename T,typename Ref,typename Ptr,size_t BufSize&gt;struct _deque_iterator&#123; //省略traits定义 typedef T** map_pointer; typedef _deque_iterator self; //每一个片段的元素容量，如果不指定，默认为512/sizeof(T) static size_t buffer_size()&#123;&#125;; T* cur; //指向片段的当前可插入位置 T* first; //指向片段的头部 T* last; //指向片段的超尾 map_pointer node; //节点 //设置节点 set_node(map_pointer new_node) &#123; node=new_node; first=*new_node; last=first+difference_type(buffer_size()); &#125; //迭代器之间的减法 difference_type operator-(self&amp; x) const &#123; return difference_type(buffer_size())*(node-x.node-1)+(cur-first)+(x.last-x.cur); &#125; self&amp; operator++() &#123; ++cur; if(cur==last) //到达当前片段超尾 &#123; set_node(node+1); //跳转到下一片段 cur=first; //指向头部 &#125; return *this; &#125; //自减操作类似，略过 self&amp; operator+=(difference_type n) &#123; difference_type offset=n+cur-first; //判断是否在同一片段内偏移 if(offset&gt;=0 &amp;&amp; offset&lt;difference_type(buffer_size())) cur+=n; else &#123; difference_type node_offset=offset&gt;0 ? offset/difference(buffer_size()):-difference_type((-offset-1)/buffer_size())-1; set_node(node+node_offset); cur=first+offset-node_offset*difference_type(buffer_size()); &#125; return *this; &#125; //省略其它操作&#125; 双端队列的结构SGI的deque结构如上图所示，其具体实现见代码： 123456789101112131415161718192021222324252627282930313233//基础成员template&lt;typename T,typename Alloc=alloc,size_t BuffSize=0&gt;class deque&#123;public: typedef _deque_iterator&lt;T,T&amp;,T*,BuffSize&gt; iterator;protected: typedef pointer* map_pointer; iterator start; //头部迭代器 iterator finish; //尾部迭代器 map_pointer map; //map size_type map_size; //节点数量public: //头部迭代器 iterator begin() &#123;return start;&#125; //尾部迭代器 iterator end() &#123;return finish;&#125; //首元素 reference front() &#123;return *start;&#125; //尾元素 reference back() &#123; iterator tmp=finish; --tmp; return *tmp; &#125; //略过其它常用接口&#125; 注意deque迭代器取值操作符返回*cur，start迭代器的cur总是指向首元素，finish迭代器的cur指向最后一个元素的下一位，因此需要前移。 1234567891011121314151617181920212223242526272829303132333435363738394041//构造函数deque(int n,const value_type&amp; value):start(),finish(),map(0),map_size(0)&#123; fill_initialize(n,value);&#125;template&lt;typename T,typename Alloc,size_t BuffSize&gt;void fill_initialize(size_type n,const value_type&amp; value)&#123; create_map_and_nodes(n); map_pointer cur; for(cur=start.node;cur&lt;finish.node;++cur) uninitialized_fill(*cur,*cur+buffer_size(),value); //尾部片段可能还有空闲，因此单独初始化 uninitialized_fill(finish.first,finish.cur,value);&#125;template&lt;typename T,typename Alloc,size_t BuffSize&gt;void create_map_and_nodes(size_type num_element)&#123; //计算初始需要分配的节点数，如果刚好占满n个片段，则额外加一 size_type num_nodes=num_element/buffer_size()+1; //初始节点数，最少为8。首尾各增加一个以供备用 map_size=max(8,num_nodes+2); //为map分配内存保存节点 map=map_allocator::allocate(map_size); //使初始占用的空间尽量居中，便于首尾插入 map_pointer nstart=map+(map_size-num_nodes)/2; map_pointer nfinish=nstart+num_nodes-1; map_pointer cur; //为片段分配空间 for(cur=nstart;cur&lt;=nfinish;++cur) *cur=allocate_node(); start.set_node(nstart); finish.set_node(nfinish); start.cur=start.first; finish.cur=finish.first+num_element%buffer_size();&#125; 再来看看deque在内部如何处理元素插入，以push_back为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void push_back(const value_type&amp; t)&#123; //如果尾片段空余空间大于1，则直接赋值 if(finish.cur != finish.last -1) &#123; construct(finish.cur,t); ++finish.cur; &#125; //否则新分配一个片段 else push_back_aux(t);&#125;void push_back_aux(const value_type&amp; t)&#123; value_type t_copy=t; //判断是否需要重新分配map reserve_map_at_back(); //为下一个节点分配一个片段 *(finish.node+1)=alocate_node(); //现在finish所指的片段已满 construct(finish.cur,t_copy); //尾迭代器指向下一个片段 finish.set_node(finish.node+1); finish.cur=finish.first;&#125;//判断尾部是否需要重新分配void reserve_map_at_back(size_type node_to_add=1)&#123; //尾部备用空间不足 if(node_to_add&gt;map_size-(finish.node-map)-1) //false尾部分配 reallocate_map(node_to_add,false);&#125;//头部操作类似，略过void reallocate_map(size_type node_to_add,bool add_at_front)&#123; size_type old_num_nodes=finish.node-start.node+1; size_type new_num_nodes=old_num_nodes+node_to_add; map_pointer new_nstart; //对应于一端插入，另一端删除时的极端情况，此时map中只有后半段的节点被利用，不需要重新申请更大的map if(map_size&gt;2*new_num_nodes) &#123; //重新安排头部节点到中间 new_nstart=map+(map_size-new_num_nodes)/2+(add_at_front?node_to_add:0); if(new_nstart&lt;start.node) //先序复制防止左边被覆盖 copy(start.node,finish.node+1,new_nstart); else //后序复制防止右边被覆盖 copy_backward(start.node,finish.node+1,new_nstart+old_num_nodes); &#125; //对应正常情况，map中空余节点不足 else &#123; size_type new_map_size=map_size+max(map_size,node_to_add)+2; //申请更大的map map_pointer new_map=map_allocator::allocate(new_map_size); //开始节点居中 new_nstart=new_map+(new_map_size-new_num_nodes)/2+(add_at_front?node_to_add:0); //复制原节点 copy(start.node,finish.node+1,new_start); //释放原map map_allocator::deallocate(map,map_size); map=new_map; map_size=new_map_size; &#125; start.set_node(new_nstart); finish.set_node(new_nstart+old_num_nodes+1);&#125; 接下来是删除操作，SGI的deque在片段中没有元素时会销毁片段以节省内存，具体实现如下，以pop_back为例： 12345678910111213141516171819202122232425void pop_back()&#123; //尾部片段有元素 if(finish.cur!=finish.first) &#123; //注意cur指向最后一个元素的下一位 --finish.cur; destroy(finish.cur); &#125; else //没有元素 pop_back_aux();&#125;void pop_back_aux()&#123; //销毁这个空片段 deallocate_node(finish.first); //跳转到上一个节点 finish.set_node(finish.node-1); finish.cur=finish.last-1; destroy(finish.cur);&#125;//pop_front类似，略过 接下来是clear方法，该方法清除deque所有元素并将deque初始化，SGI的deque在初始状态仍会保留一个片段，代码： 12345678910111213141516171819202122void clear()&#123; for(map_pointer node=start.node+1;node&lt;finish.node;++node) &#123; //析构元素 destroy(*node,*node+buffer_size()); //销毁片段 deallocate(*node,buffer_size()); &#125; //头尾不在同一个片段 if(start.node!=finish.node) &#123; destroy(start.cur,start.last); destroy(finish.first,finish.cur); //仅销毁尾部 deallocate(finish.first,buffer_size()); &#125; else //仅析构 destroy(start.cur,finish.cur); finish=start;&#125; 基本上常见的deque操作都与上面的实现类似，注意map的操作即可。 MS的deque实现MS与SGI的实现有较大区别，首先在deque内部成员上VS2013没有定义start和finish两个迭代器，而是定义了一个_Myoff记录头节点偏移量以及_Mysize记录元素数量： 12size_type _Myoff;size_type _Mysize; 在内部，deque利用_Myoff计算节点下标来访问节点： 12345size_type _Getblock(size_type off) const&#123; //_DEQUESIZE片段长度，_Mapsize代表map的大小 return ((off/_DEQUESIZE) &amp; (this-&gt;_Mapsize-1));&#125; 其次，MS的deque采用倍增的扩展策略，即每次重新分配map时大小变为原来的2倍(初始为8，不可自定义)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//VS2013void _Growmap(size_type _Count)&#123; typedef typename _Alpty::pointer _Blockptr; _Alpty _Almap(this-&gt;_Getal()); size_type _Newsize = 0 &lt; this-&gt;_Mapsize ? this-&gt;_Mapsize : 1; while (_Newsize - this-&gt;_Mapsize &lt; _Count || _Newsize &lt; _DEQUEMAPSIZ) &#123; //size加倍 _Newsize *= 2; &#125; //计算需要新增的节点数量 _Count = _Newsize - this-&gt;_Mapsize; //计算头节点偏移 size_type _Myboff = this-&gt;_Myoff / _DEQUESIZ; //申请新的map _Mapptr _Newmap = _Almap.allocate(this-&gt;_Mapsize + _Count); //新的头节点 _Mapptr _Myptr = _Newmap + _Myboff; //复制旧节点 _Myptr = _Uninitialized_copy(this-&gt;_Map + _Myboff,this-&gt;_Map + this-&gt;_Mapsize,_Myptr, _Almap); //如果新增节点数量大于头节点偏移 if (_Myboff &lt;= _Count) &#123; //复制旧map头节点之前未使用的节点到新map的尾部(意义不明，应该是为了减少初始化次数) _Myptr = _Uninitialized_copy(this-&gt;_Map,this-&gt;_Map + _Myboff,_Myptr, _Almap); //初始化剩余的尾部节点 _Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,_Almap); //初始化头部节点 _Uninitialized_default_fill_n(_Newmap, _Myboff, _Almap); &#125; else &#123; //复制旧map头部未使用的节点到新map尾部 _Uninitialized_copy(this-&gt;_Map,this-&gt;_Map + _Count,_Myptr, _Almap); //复制剩余的旧map头部到新map头部 _Myptr = _Uninitialized_copy(this-&gt;_Map + _Count, this-&gt;_Map + _Myboff,_Newmap, _Almap); //初始化新map头部未能复制到的节点 _Uninitialized_default_fill_n(_Myptr, _Count, _Almap); &#125; //析构旧map元素 _Destroy_range(this-&gt;_Map + _Myboff, this-&gt;_Map + this-&gt;_Mapsize, _Almap); //释放旧map空间 if (this-&gt;_Map != _Mapptr()) _Almap.deallocate(this-&gt;_Map,this-&gt;_Mapsize); this-&gt;_Map = _Newmap; // point at new this-&gt;_Mapsize += _Count;&#125; 相比起来MS的实现更加复杂化，结构层次也不明显，代码质量明显比SGI差很多。最后再吐槽一下MS神奇的变量命名方式以及各种奇葩#define。","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://intptrzero.github.io/tags/STL/"}]},{"title":"STL - 迭代器","slug":"STL-Iterator","date":"2019-06-08T16:06:27.000Z","updated":"2019-10-11T17:21:10.156Z","comments":true,"path":"2019/06/09/STL-Iterator/","link":"","permalink":"https://intptrzero.github.io/2019/06/09/STL-Iterator/","excerpt":"迭代器概念STL设计迭代器的初衷就是将容器细节与算法分离，转而用迭代器作为两者的桥梁。迭代器作为一种访问容器的结构，其本质上也是一种对指针的高级包装而已，因此对应于容器的结构特点，迭代器也分为单向迭代器(典型如单链表)、双向迭代器(如双链表)和随机访问迭代器(如vector等顺序存储容器)。","text":"迭代器概念STL设计迭代器的初衷就是将容器细节与算法分离，转而用迭代器作为两者的桥梁。迭代器作为一种访问容器的结构，其本质上也是一种对指针的高级包装而已，因此对应于容器的结构特点，迭代器也分为单向迭代器(典型如单链表)、双向迭代器(如双链表)和随机访问迭代器(如vector等顺序存储容器)。 迭代器的实现作为对容器元素指针的高级包装，迭代器不可避免的会暴露容器的实现细节，因此将迭代器完全脱离容器是不现实的，故STL容器都在内部实现了对应于特定容器的迭代器。为了说明迭代器的实现原理，下面以一个自定义的容器类MyList来进行演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef _MYLIST#define _MYLIST#include &lt;iostream&gt;template&lt;typename T&gt;struct MyListNode&#123; T _value; MyListNode&lt;T&gt;* _next; MyListNode():_value(0),_next(nullptr) &#123;&#125;&#125;;template&lt;typename NodeTy&gt;class MyListIter&#123;public: NodeTy* ptr; MyListIter( NodeTy* p = nullptr) :ptr(p)&#123;&#125; NodeTy&amp; operator*() const &#123; return *ptr; &#125; NodeTy* operator-&gt;() const &#123; return ptr; &#125; MyListIter&amp; operator++() &#123; ptr = ptr-&gt;_next; return *this; &#125; MyListIter operator++(int) &#123; MyListIter tmp = (*this); ++(*this); return tmp; &#125; bool operator==(const MyListIter&amp; i) const &#123; return ptr == i.ptr; &#125; bool operator!=(const MyListIter&amp; i) const &#123; return ptr != i.ptr; &#125;&#125;;template&lt;typename T&gt;class MyList&#123;private: MyListNode&lt;T&gt;* _head;public: void insert_front(T v) &#123; MyListNode&lt;T&gt;* tmp = new MyListNode&lt;T&gt;; tmp-&gt;_value = v; tmp-&gt;_next = _head-&gt;_next; _head-&gt;_next=tmp; &#125; void display(std::ostream&amp; os = std::cout) const &#123; MyListNode&lt;T&gt;* tmp = _head-&gt;_next; while (tmp) &#123; os &lt;&lt; tmp-&gt;_value&lt;&lt;\" \"; tmp = tmp-&gt;_next; &#125; &#125; MyList() &#123; _head = new MyListNode&lt;T&gt;; &#125; MyListIter&lt;MyListNode&lt;T&gt;&gt; begin() const &#123; return MyListIter&lt;MyListNode&lt;T&gt;&gt;(_head-&gt;_next); &#125; MyListIter&lt;MyListNode&lt;T&gt;&gt; end() const &#123; return MyListIter&lt;MyListNode&lt;T&gt;&gt;(nullptr); &#125;&#125;;#endif main: 12345678910111213141516171819202122232425262728#include \"mylist.h\"template&lt;typename IterTy,typename Ty&gt;IterTy find(IterTy begin,IterTy end, Ty value);int main()&#123; MyList&lt;int&gt; mylist; for (int i = 0; i &lt; 5;i++) mylist.insert_front(i); mylist.display(); auto ibegin=mylist.begin(); auto iend = mylist.end(); auto result = find(ibegin, iend, 2); std::cout &lt;&lt; result.ptr-&gt;_value;&#125;template&lt;typename IterTy, typename Ty&gt;IterTy find(IterTy begin, IterTy end, Ty value)&#123; while (begin != end) &#123; if (begin-&gt;_value == value) break; begin++; &#125; return begin;&#125; 通过上面的简单链表迭代器，我们成功实现了独立于容器的泛型算法find。上述的迭代器仅仅是个雏形，如果一个算法需要一个迭代器类型变量而返回一个迭代器指向的元素类型，在仅使用一个模板参数的情况下，上述迭代器根本不可能做到。例如： 123456789101112131415//两个参数可行template&lt;typename IterTy,typename NodeTy&gt;NodeTy somefunc(IterTy iter,NodeTy el)&#123; NodeTy tmp; ... return tmp;&#125;//一个参数无法完成template&lt;typename IterTy&gt;? somefunc(IterTy iter)&#123; ? tmp;&#125; 实际上以上问题在allocator中已经出现过，STL在allocator中的解决方法是rebind，简单来说就是将可能会用到的类型定义为内嵌类型： 1234567891011121314template&lt;typename NodeTy&gt;class MyListIter&#123;public: typedef NodeTy value_type; //...&#125;template&lt;typename IterTy&gt;typename IterTy::value_type somefunc(IterTy iter)&#123; //现在仅需要一个模板参数 typename IterTy::value_type tmp；&#125; 然而以上技巧仅适用于迭代器类，对于无法定义内嵌类型的原生指针无能为力。泛型算法不应该仅考虑到迭代器，原生指针的行为理应与迭代器类似。 Traits编程技巧Traits直译为“特性，特征”，即人为的赋予对象某些修饰，在需要的时候提取出来。显而易见，traits技术也只能用于类，仍然对原生指针束手无策。为了解决此问题，我们需要对原生指针进行一次包装，而包装方法就是使用模板偏特化： 123456789101112template&lt;typename IterTy&gt;struct iter_traits&#123; typedef typename IterTy::value_type value_type;&#125;//指针偏特化模板template&lt;typename Ty&gt;struct iter_traits&lt;Ty*&gt;&#123; typedef Ty value_type;&#125; 现在无论是原生指针还是迭代器都可以使用iter_traits::value_type获取指向的元素类型。根据编程经验，STL规定迭代器至少定义5种基本特性：value_type、difference_type、pointer、reference和iterator_category value_type:即迭代器指向的元素类型 difference_type:迭代器之间的距离 pointer:指向元素的指针 reference:元素的引用 category:迭代器类型 前面提到迭代器对应于特定容器分为单向迭代器、双向迭代器和随机访问迭代器，功能上还可分为输入迭代器和输出迭代器。很显然不同迭代器可定义的操作和效率是不同的，因此区分迭代器类型有利于提升性能。以advance()函数为例，该函数将一个给定的迭代器移动给定的距离： 123456789101112131415161718192021222324252627282930//单向迭代器template&lt;typename ForwardIter,typename Distance&gt;void advance_fiter(ForwardIter&amp; i,Distance n)&#123; while(n--) i++;&#125;//双向迭代器template&lt;typename BidIter,typename Distance&gt;void advance_biter(BidIter&amp; i,Distance n)&#123; if(n&gt;0) &#123; while(n--) i++; &#125; else &#123; while(n++) i--; &#125;&#125;//随机访问迭代器template&lt;typename RndIter,typename Distance&gt;void advance_rnditer(RndIter&amp; i,Distance n)&#123; i += n;&#125; 为了区分迭代器类型而设计三个函数显然不明智，然而上述函数都是两个模板参数的模板函数，无法重载，因此需要引入另一个不同的参数达成重载条件，STL的做法是引入一个迭代器类型参数： 123456789101112131415161718192021struct input_iterator_tag&#123;&#125;;struct output_iterator_tag&#123;&#125;;struct forward_iterator_tag:public input_iterator_tag&#123;&#125;;struct bidirectional_iterator_tag:public forward_iterator_tag&#123;&#125;;struct random_access_iterator_tag:public bidirectional)iterator_tag&#123;&#125;;//内部实现template&lt;typename InputIter,typename Distance&gt;void _advance(InputIter&amp; i,Distance n,input_iterator_tag)&#123; //...&#125;//...//外部接口template&lt;typename Iterator,Distance n&gt;void advance(Iterator&amp; i,Distance n)&#123; _advance(i,n,iterator_traits&lt;Iterator&gt;::iterator_category());&#125; 如上，通过定义几个用于标识迭代器类型的空类并作为参数启用函数重载，并在外部调用时使用traits技术获取迭代器类型，完成了不同迭代器的函数实现。并且STL迭代器类型是继承关系，利用模板协变，适用于低级迭代器的函数也可用于高级迭代器。","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://intptrzero.github.io/tags/STL/"}]},{"title":"STL - 内存分配器","slug":"STL-Allocator","date":"2019-06-01T12:37:17.000Z","updated":"2019-10-07T08:12:33.628Z","comments":true,"path":"2019/06/01/STL-Allocator/","link":"","permalink":"https://intptrzero.github.io/2019/06/01/STL-Allocator/","excerpt":"标准内存分配器定义STL容器时有一个可选参数allocator，缺省情况下使用STL自带的默认allocator类进行内存分配。allocator类在VS2013下由头文件xmemory0定义，间接由memory头文件引用。类声明节选如下：","text":"标准内存分配器定义STL容器时有一个可选参数allocator，缺省情况下使用STL自带的默认allocator类进行内存分配。allocator类在VS2013下由头文件xmemory0定义，间接由memory头文件引用。类声明节选如下： 12345678910111213141516171819202122232425262728293031323334353637383940//基类template&lt;typename _Ty&gt;struct _Allocator_base&#123; typedef _Ty value_type;&#125;//allocator类template&lt;typename _Ty&gt;class allocator:public _Allocator_base&lt;_Ty&gt;&#123;public: //STL标准需要的类型定义 typedef allocator&lt;_Ty&gt; other; typedef _Allocator_base&lt;_Ty&gt; _Mybase; typedef typename _Mybase::value_type value_type; typedef value_type *pointer; typedef const value_type *const_pointer; typedef void *void_pointer; typedef const void *const_void_pointer; typedef value_type&amp; reference; typedef const value_type&amp; const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type; //三个空构造函数 allocator() &#123;&#125; allocator(const allocator&lt;_Ty&gt;&amp;) &#123;&#125; template&lt;typename _Other&gt; allocator(const allocator&lt;_Other&gt;&amp;) &#123;&#125; //rebind template&lt;typename _Other&gt; struct rebind &#123; typedef allocator&lt;_Other&gt; other; &#125; //其它成员函数&#125; 其中略难理解的是rebind结构，rebind只有一个other成员用来代表allocator&lt;_Other&gt;，这一步貌似有点多余，何不在需要的时候直接声明一个allocator&lt;_Other&gt;类型的分配器呢。STL的allocator是为容器服务的，要弄清楚设计者的目的，需要联系容器的实现。作为普通容器如vector和array等，它们的元素是直接存储的，而list等容器有一个中间存储结构node，且node与元素类型是有关的。在分配内存时需要为节点类型node&lt;T&gt;和元素类型T传入对应的allocator，而声明list时只传入了元素类型T，因此需要某种方法根据allocator&lt;T&gt;得到allocator&lt;node&lt;T&gt;&gt;，这时rebind的作用就体现出来了。附VS2013的部分list实现代码： 123456789101112131415161718192021template&lt;class _Ty,class _Alloc0&gt; struct _List_base_types &#123; typedef _Alloc0 _Alloc; typedef _List_base_types&lt;_Ty, _Alloc&gt; _Myt; typedef _Wrap_alloc&lt;_Alloc&gt; _Alty0; //向底层元素的rebind typedef typename _Alty0::template rebind&lt;_Ty&gt;::other _Alty; typedef typename _Get_voidptr&lt;_Alty, typename _Alty::pointer&gt;::type _Voidptr; typedef _List_node&lt;typename _Alty::value_type, _Voidptr&gt; _Node; //向节点类型的rebind typedef typename _Alty::template rebind&lt;_Node&gt;::other _Alnod_type; typedef typename _Alnod_type::pointer _Nodeptr; typedef _Nodeptr&amp; _Nodepref; &#125;; rebind算是一种比较巧妙的方法，在元素与中间结构之间创建某种联系，从而达到只需要一个模板参数即可创建多级内存分配器的目的。 STL标准要求的其它函数接口实现如下： 12345678910111213141516171819202122232425262728293031323334353637void deallocate(pointer _Ptr, size_type) &#123; // deallocate object at _Ptr, ignore size ::operator delete(_Ptr); &#125;pointer allocate(size_type _Count) &#123; // allocate array of _Count elements return (_Allocate(_Count, (pointer)0)); &#125;pointer allocate(size_type _Count, const void *) &#123; // allocate array of _Count elements, ignore hint return (allocate(_Count)); &#125;void construct(_Ty *_Ptr) &#123; // default construct object at _Ptr ::new ((void *)_Ptr) _Ty(); &#125;void construct(_Ty *_Ptr, const _Ty&amp; _Val) &#123; // construct object at _Ptr with value _Val ::new ((void *)_Ptr) _Ty(_Val); &#125;template&lt;class _Objty, class... _Types&gt; void construct(_Objty *_Ptr, _Types&amp;&amp;... _Args) &#123; // construct _Objty(_Types...) at _Ptr ::new ((void *)_Ptr) _Objty(_STD forward&lt;_Types&gt;(_Args)...); &#125;template&lt;class _Uty&gt; void destroy(_Uty *_Ptr) &#123; // destroy object at _Ptr _Ptr-&gt;~_Uty(); &#125; 与SGI的二级分配器实现相比更简单，直接调用全局的operator new和delete，没有额外的内存优化。","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://intptrzero.github.io/tags/STL/"}]},{"title":".NET - 委托","slug":"CLR-Delegate","date":"2019-05-22T06:23:23.000Z","updated":"2019-09-30T12:01:44.615Z","comments":true,"path":"2019/05/22/CLR-Delegate/","link":"","permalink":"https://intptrzero.github.io/2019/05/22/CLR-Delegate/","excerpt":"委托与函数指针在C++中经常需要以变量形式传递函数，函数在底层实际上就是一个地址，调用时跳转到相应的地址执行代码，函数指针类型可以非常方便的用来传递函数地址，但C++中的函数指针仅仅是一个指针类型变量，无法提供参数和返回值等详细信息，因此函数指针不是类型安全的。CLR在此基础上更进一步，将函数指针抽象化为委托，增强了类型安全。","text":"委托与函数指针在C++中经常需要以变量形式传递函数，函数在底层实际上就是一个地址，调用时跳转到相应的地址执行代码，函数指针类型可以非常方便的用来传递函数地址，但C++中的函数指针仅仅是一个指针类型变量，无法提供参数和返回值等详细信息，因此函数指针不是类型安全的。CLR在此基础上更进一步，将函数指针抽象化为委托，增强了类型安全。 委托的底层原理先来看看委托的声明语句： 1delegate void MyCallback(Int32 v); 编译器实际上为上述语句生成如下代码： 1234567class MyCallback:System.MulticastDelegate&#123; public MyCallback(Object obj, IntPtr method); public virtual void Invoke(Int32 v); public virtual IAsyncResult BeginInvoke(Int32 v, AsyncCallback callback, Object obj); public virtual void EndInvoke(IAsyncResult result);&#125; 显而易见，CLR将C++的函数指针包装成了一个类，自定义的委托类全部派生于CLR内置的MulticastDelegate类。MulticastDelegate类有三个重要的字段： _target：对象实例 _methodPtr：方法指针 _invocationList：委托链，单播委托为null 例子： 12345678910111213class A&#123; public void Show(Int32 v) &#123; Console.WriteLine(v.ToString); &#125;&#125;A a=new A;MyCallback mcb=new MyCallback(a.Show);mcb(3);//输出:3 在上述代码中_target=a，_methodPtr指向Show方法。代码中mcb(3)语句实际上是个语法糖，编译器在底层将它翻译为mcb.Invoke(3)，Invoke方法实际上也是使用_target与_methodPtr确定要调用的方法。 委托链由基类MulticastDelegate的名称很容易看出支持多个委托调用。多个委托与单个委托略有区别，由于需要保存多个回调，_target和_methodPtr显然是不够用的，因此需要使用_invocationList字段。_invocationList实际上是一个委托对象数组，每次使用Delegate.Combine方法添加委托时，委托对象被添加到数组中。多播委托与单播委托使用方法一样，调用Invoke方法时，依次对每一个委托数组元素调用Invoke，因此如果委托具有返回值，将只返回最后一个回调函数的返回值。Invoke方法的实现大致如下： 1234567891011public void Invoke(Int32 v)&#123; Delegate[] delegateArray = _invocationList as Delagate[] if(delegateArray != null) &#123; foreach(MyCallback del in delgateArray) del.Invoke(v); &#125; else //根据_target调用_methodPtr指向的方法&#125; 除了可以添加委托，还可以使用Delegate.Remove方法删除委托，方法查找源委托链中与目标委托签名一致的委托对象，并删除第一个匹配项。如果删除后委托链为空，则返回null。如果删除后委托链只有一个元素，则返回该委托元素，源委托变为单播委托，委托链为null。","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"}]},{"title":"类与多态 - 继承","slug":"Class-Func","date":"2019-05-18T14:45:44.000Z","updated":"2019-11-10T06:49:35.196Z","comments":true,"path":"2019/05/18/Class-Func/","link":"","permalink":"https://intptrzero.github.io/2019/05/18/Class-Func/","excerpt":"类继承C++支持三种不同的继承方式：private、protected和public，继承方式只影响派生类外部对基类成员的访问权限，而不影响派生类在内部对基类成员的访问权限。私有继承意味着所有基类成员将被继承为派生类的私有成员；保护继承意味着基类所有public成员被继承为protected，其它成员不受影响；公有继承则保持基类成员的原有访问控制不变。例子：","text":"类继承C++支持三种不同的继承方式：private、protected和public，继承方式只影响派生类外部对基类成员的访问权限，而不影响派生类在内部对基类成员的访问权限。私有继承意味着所有基类成员将被继承为派生类的私有成员；保护继承意味着基类所有public成员被继承为protected，其它成员不受影响；公有继承则保持基类成员的原有访问控制不变。例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Base&#123;private: int _ID;protected: char* _Name;public: void show()&#123;cout&lt;&lt;_ID&lt;&lt;\": \"&lt;&lt;_Name;&#125;&#125;//私有继承class Child1: private Base&#123;private: //内部访问权限不受影响，可访问基类protected和public成员 void test() &#123; name=\"\"; //protected Base::name show(); //public Base::show() &#125;&#125;//保护继承同上class Child2: protected Base&#123;private: void test() &#123; name=\"\"; show(); &#125; &#125;class Child3: public Base&#123;private: void test() &#123; name=\"\"; show(); &#125; &#125;//Child1已将基类成员继承为private，CChild1显然不可访问class CChild1: public Child1&#123;private: void test() &#123; name=\"\"; //不可访问:private Child1::name show(); //不可访问:private Child1::show() &#125;&#125;//Child2是保护继承，基类非private成员均被继承为protected，CChild2显然可以访问class CChild2: public Child2&#123;private: void test() &#123; name=\"\"; //OK:protected Child2::name show(); //OK:protected Child2::show() &#125;&#125;Child1 c1;Child2 c2;c1.show(); //不可访问c2.show(); //不可访问 方法重写解释方法重写前需要弄明白函数重载与方法重写的概念。函数重载发生在同一类作用域，而方法重写发生在类继承中，即使子类用不同的参数列表重写父类方法，他也不是重载，而是重写，例如： 123456789101112131415class Base&#123;public: void show()&#123;cout&lt;&lt;\"base\";&#125;&#125;class Child: public Base&#123;public: void show(int i)&#123;cout&lt;&lt;\"child\";&#125;&#125;Child c;c.show(); //Errorc.show(0); //OK 这种情况下属于重写，子类只可调用带参数版本，原版本将被子类隐藏。 派生类重写基类方法分为两种情况：虚方法和非虚方法，重写虚方法要求子类与父类保持方法签名一致，否则将变成普通方法重写，且子类隐藏父类虚方法。例如： 1234567891011121314151617181920212223class Base&#123;public: virtual void show() &#123;cout&lt;&lt;\"base\";&#125;&#125;class Child: public Base&#123;public: void show(int i) &#123;cout&lt;&lt;\"child\";&#125;&#125;class Child1: public Base&#123;public: void show(int i) &#123;cout&lt;&lt;\"child1\";&#125; void show() &#123;cout&lt;&lt;\"child1 virtual\";&#125;&#125;Child c;c.show(); //Error.子类重写虚方法未保持函数签名一致,退化为普通方法重写，将隐藏基类同名方法。Child1 c1;c1.show(); //OK.重写虚方法c1.show(0); //OK.构成重载 在.NET中，MS对C++原有的继承关系做了进一步包装。首先取消了多重继承和非公有继承；其次将抽象类细化为抽象基类和接口；最后对方法重写规则做了一些额外的限制。例如对于普通方法重写，编译器要求显式指定new(Shadows)关键字；对于虚方法重写，要求显式指定override(s)关键字，否则一律视为普通方法重写。 123456789101112131415161718192021222324252627282930313233343536class BaseCls&#123; public virtual void show() &#123; Console.WriteLine(\"Base\"); &#125;&#125;//虚方法重写class ChildCls:BaseCls&#123; public override void show() &#123; Console.WriteLine(\"Child\"); &#125;&#125;//普通重写(new可省略)class BadChildCls:BaseCls&#123; public new void show() &#123; Console.WriteLine(\"BadChild\"); &#125;&#125;BaseCls a,b;a=new ChildCls();b=new BadChildCls();a.show();b.show();/*输出：ChildBase*/ BadChildCls使用new重写，因此虚函数表不会记录BadChildCls的show()方法。 VB.NET语法糖相比于C#，VB.NET增加了一个额外的关键字Overloads用于显式重载函数，它也可以简化虚方法重写与重载： 123456789101112131415Class Base Public Overridable Sub Show() Console.WriteLine(\"base\") End SubEnd ClassClass Child:Inherits Base Public Overloads Sub Show(Byval i as Int32) Console.WriteLine(\"child\") End SubEnd ClassDim c as New Childc.Show(0) //OKc.Show() //OK 上述代码实际上可以拆分为： 1234567891011Class Child:Inherits Base //虚方法重写 Public Overrides Sub Show() MyBase.Show() End Sub //函数重载 Public Overloads Sub Show(Byval i as Int32) Console.WriteLine(\"child\") End SubEnd Class 不过两者略有区别，通过查看IL代码，第一种写法中Child只有Show(Int32)方法，对Show()的调用直接编译为MyBase.Show()，可见.NET的编译器足够智能。","categories":[{"name":"类","slug":"类","permalink":"https://intptrzero.github.io/categories/类/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://intptrzero.github.io/tags/OOP/"}]},{"title":"CLR - 内存管理与垃圾回收","slug":"CLR-GC","date":"2019-05-12T08:12:58.000Z","updated":"2019-09-17T04:54:04.465Z","comments":true,"path":"2019/05/12/CLR-GC/","link":"","permalink":"https://intptrzero.github.io/2019/05/12/CLR-GC/","excerpt":"CLR内存分配无论是C#、VB.NET或是Java，这些所谓的高级编程语言实际上都致力于解决C++中常见的内存泄露问题，方法很简单 – 那就是剥夺程序员对于物理内存空间的直接控制权，重新虚拟一层“可控”的内存空间，并由框架(.NET的CLR以及Java的JVM)自行处理内存问题。这样虽然牺牲了一点点性能以及少许灵活性，但大大提高了安全性，更不用说框架封装所带来的便利。","text":"CLR内存分配无论是C#、VB.NET或是Java，这些所谓的高级编程语言实际上都致力于解决C++中常见的内存泄露问题，方法很简单 – 那就是剥夺程序员对于物理内存空间的直接控制权，重新虚拟一层“可控”的内存空间，并由框架(.NET的CLR以及Java的JVM)自行处理内存问题。这样虽然牺牲了一点点性能以及少许灵活性，但大大提高了安全性，更不用说框架封装所带来的便利。 类似于C++，CLR中动态分配的内存存在于一个叫做“托管堆”的地方。程序集初始化时，CLR在物理内存中划出一块作为进程的托管堆，托管堆类似于数据结构中的栈，它维护一个指针，指向下一块可被分配的内存。当使用new操作符声明新对象时，CLR首先计算对象的字节大小，然后再加上一个对象类型指针和一个同步块索引，然后检查托管堆是否拥有足够的可用空间，如果空间足够，则托管堆内部指针向后移动相应距离。 CLR垃圾回收托管堆内存不足以分配新对象时(或主动调用GC)，CLR便会发起垃圾回收。垃圾回收有许多不同的实现方法，例如COM中采用的引用计数，但引用计数无法处理循环引用的问题，即对象AB互相引用，则引用计数永远不可能为0，从而引发内存泄漏。.NET和Java都采用引用跟踪算法，即将对象变量看作“根”。在垃圾回收时CLR挂起整个线程以防止垃圾回收过程中的状态变化，CLR先将托管堆中所有对象标记为垃圾(将同步索引的某一位置为0)，然后以变量为根，向下搜索变量引用的对象和对象的成员所引用的对象，如果变量非NULL，则引用的对象被标记为非垃圾，如果对象已被标记为非垃圾，cLR跳过检查该对象的成员字段，防止循环引用造成的死循环。标记完成后，CLR将所有非垃圾对象整合到一段连续的内存空间并移动内部指针，这样可以解决传统C++中的内存碎片化问题。但整合内存意味着对象的地址发生变化，因此垃圾清理后必须恢复变量指向的对象的地址。 GC的性能优化如果每次都检查并移动托管堆中的所有对象，那么会造成比较大的性能开销，因此.NET和Java都采用了基于“代”的回收机制。“分代”的原理很简单，如果某对象经过一次垃圾回收后仍存活，则代数提高一代，而垃圾回收时优先回收第0代，理由是活的越久的对象越有可能继续存活，因此优先回收第0代有更大可能回收更多的空间。CLR将托管堆对象分为0、1、2三代，CLR对三块内存空间采取了动态负载的方案。垃圾回收时，如果第0代大部分对象都是垃圾，此时垃圾回收的代价很小(仅需要复制少量内存块以及修改少许指针)，CLR会相对分配较少的空间给第0代；反之，CLR分配较大的内存空间，以减少垃圾回收的次数。此策略也适用于1、2代。 大对象CLR将对象分为大对象和小对象，大对象是大小超过85000字节左右的对象，大对象与小对象并不在同一内存空间分配，且初始即为第2代，因为在内存中移动大对象的代价过高。 Finalize与Dispose当程序集调用非托管的本机资源对象(如File或Mutex)时，CLR只能回收托管内存，造成本机内存的泄露。因此CLR为封装的本机资源对象设计了Finalize方法，拥有该方法的对象在GC执行之后才会被CLR调用该方法，如果方法内有访问对象字段的代码，则此对象的内存并不能立即被回收，这导致对象活得更久，增加了内存消耗。Finalize被设计为只能由CLR调用，托管内存由CLR负责清理，因此Finalize负责清理非托管资源，例如文件句柄。然而Finalize只有当对象被标记为垃圾且在GC执行后才可能被调用，并且调用时间无法确定，因此有必要设计另一种由开发者精确控制的清理机制，对此CLR设计了IDisposeable接口，接口暴露Dispose方法，实现接口的对象可以由开发者主动调用Dispose方法立即执行非托管资源的清理。实现如下： 12345678910111213141516171819202122232425public class DisposablClass : IDisposable&#123; //标记是否已回收 bool disposed; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); //移除Finalize调用 &#125; ~DisposableClass() &#123; Dispose(false); &#125; private void Dispose(bool disposing) &#123; if(disposed) return; //防止多次执行 if(disposing) &#123; //TODO:释放本对象的托管资源 &#125; //TODO:释放非托管资源 disposed = true; &#125;&#125; 内部的Dispose(bool)参数用来标识被Dispose还是Finalize调用，如果是Dispose，则需要自己清理托管资源，同时移除GC对本对象的Finalize调用。如果是Finalize，则托管资源已由GC处理，只需要清理非托管资源。调用非托管资源的对象类设计原则：如果类实现了Finalize，则也应实现可控的Dispose方法，并在方法中移除GC对Finalize的调用；反之，实现了Dispose方法也应实现Finalize，以防止开发者忘记调用Dispose。","categories":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/categories/NET/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://intptrzero.github.io/tags/NET/"},{"name":"GC","slug":"GC","permalink":"https://intptrzero.github.io/tags/GC/"}]},{"title":"Leetcode - 字符串转换","slug":"Leetcode-stredis","date":"2019-04-12T04:40:11.000Z","updated":"2019-09-07T05:30:42.471Z","comments":true,"path":"2019/04/12/Leetcode-stredis/","link":"","permalink":"https://intptrzero.github.io/2019/04/12/Leetcode-stredis/","excerpt":"问题给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。","text":"问题给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。 思路对于类似第一时间想不出解法的问题，首先考虑动态规划。设dp[i][j]代表从长度i的字符串转换为长度j的字符串需要的最少操作数，若word1[i-1]==word2[j-1]，则显然最后一个字符无需任何操作，因此dp[i][j]=dp[i-1][j-1]。若word1[i-1]!=word2[j-1]，则最后一位字符需要一次操作，插入操作对应dp[i][j-1]，删除操作对应dp[i-1][j]，替换操作对应dp[i-1][j-1]，此时的状态方程为dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1。 代码(C++)12345678910111213141516int m=word1.length();int n=word2.length();int dp[m+1][n+1];for(int i=0;i&lt;=m;i++) //显然需要i次删除操作 dp[i][0]=i;for(int j=0;j&lt;=n;j++) //显然需要j次插入操作 dp[0][j]=j; for(int i=0;i&lt;m;i++) //长度比次序大一 for(int j=0;j&lt;n;j++) &#123; if(word1[i]==word2[j]) dp[i+1][j+1]=dp[i][j] //字符0对应长度1，类推 else dp[i+1][j+1]=min(min(dp[i+1][j],dp[i][j+1]),dp[i][j])+1; &#125;return dp[m][n];","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"}]},{"title":"Leetcode - 次方取模","slug":"Leetcode-superpow","date":"2019-04-08T03:30:04.000Z","updated":"2019-09-06T11:17:12.737Z","comments":true,"path":"2019/04/08/Leetcode-superpow/","link":"","permalink":"https://intptrzero.github.io/2019/04/08/Leetcode-superpow/","excerpt":"问题计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。","text":"问题计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 思路直接求a^b然后取模肯定不现实，但可以根据取模公式(a^b)%c=((a%c)^b)%c和(a*b)%c=(a%c*b%c)%c拆分计算，同时利用a^(km+n)=(a^m)^k*a^n公式对b进行逐位求次方。 代码(C++)123456789int n=b.size();int temp=1;int base=a%c;for(int i=n-1;i&gt;=0;i--)&#123; temp=pow(temp,10)%c; temp=(temp*(pow(base,b[i])%c))%c;&#125;return temp; 优化：pow函数返回值为double，且数据过大时溢出。根据快速幂算法可以进一步拆分。 快速幂12345678910111213141516171819202122232425int qpowmod(int x,int n,int vmod)&#123; int temp=1; int base=x%vmod; while(n) &#123; if(n&amp;1) temp=(temp*base)%vmod; base=(base*base)%vmod; n&gt;&gt;1; &#125; return temp;&#125;int main()&#123; int temp=1; int base=a%c; for(int i=0;i&lt;b.size();i++) //高位在前 &#123; temp=qpowmod(temp,10,c); temp=(temp*qpowmod(base,b[i],c))%c; &#125; return temp;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 重复元素III","slug":"Leetcode-KRangeT","date":"2019-04-06T13:03:30.000Z","updated":"2019-09-17T04:58:59.486Z","comments":true,"path":"2019/04/06/Leetcode-KRangeT/","link":"","permalink":"https://intptrzero.github.io/2019/04/06/Leetcode-KRangeT/","excerpt":"问题给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。","text":"问题给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。 思路 双指针：略过。 Set：维护一个大小为k的set，由于set自动排序的特性，可以找出不小于nums[i]-t的值，然后判断该值是否同时不大于nums[i]+t。 哈希+桶:将nums元素分散到大小为t+1的桶中，然后以桶id作为键，nums[i]作为值存入hash表，只需要查找nums[i]所在的桶和相邻的两个桶即可。 代码(C++)Set123456789101112if(k&lt;1 || nums.size()&lt;2 || t&lt;0) return false;set&lt;int&gt; s;for(int i=0;i&lt;nums.size();i++)&#123; auto ps=s.lower_bound(nums[i]-t); //不小于nums[i]-t if(ps!=s.end() &amp;&amp; abs((*ps)-nums[i])&lt;=t) //不大于nums[i]+t return true; s.insert(nums[i]); if(s.size()&gt;k) s.erase(nums[i-k]);&#125;return false; 哈希+桶12345678910111213141516171819202122232425int getid(int n,int s) //计算桶id，除法保证同一桶元素相差[0~s-1]&#123; return n&lt;0?(n+1)/s-1:n/s; //eg:[-s+1,-1]/s=0，如果不特殊处理则与[0,s-1]桶id混淆&#125;if(k&lt;1 || nums.size()&lt;2 || t&lt;0) return false;unordered_map&lt;int,int&gt; m;int sb=t+1; //桶大小，0~tint id;int n;for(int i=0;i&lt;nums.size();i++)&#123; n=nums[i]; id=getid(n,sb); if(m.count(id)) //同一桶必然满足条件 return true; if(m.count(id-1) &amp;&amp; n-m[id-1]&lt;=t) //左 return true; if(m.count(id+1) &amp;&amp; m[id+1]-n&lt;=t) //右 return true; m[id]=n; if(m.size()&gt;k) m.erase(m.find(getid(nums[i-k],sb)));&#125;return false;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 重复元素II","slug":"Leetcode-krepeat","date":"2019-04-04T02:09:48.000Z","updated":"2019-09-04T13:02:19.238Z","comments":true,"path":"2019/04/04/Leetcode-krepeat/","link":"","permalink":"https://intptrzero.github.io/2019/04/04/Leetcode-krepeat/","excerpt":"问题给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。","text":"问题给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。 思路 双指针：时间复杂度O(kn)，k很大时退化为O(n^2)。 哈希表：时间复杂度O(n)。 代码(C++)双指针12345678if(nums.size()&lt;2) return false;for(auto p1=nums.cbegin();p1&lt;nums.end();p1++) for(auto p2=p1+1;p2&lt;=p1+k &amp;&amp; p2&lt;nums.end();p2++) &#123; if(*p2==*p1) return true; &#125;return false; Map1234567891011if(nums.size()&lt;2) return false;unordered_map&lt;int,int&gt; m;for(int i=0;i&lt;nums.size();i++)&#123; if(m.find(nums[i])!=m.end()) return true m[nums[i]]=i; if(m.size()&gt;k) m.erase(nums[i-k]);&#125;return false; Set1234567891011if(nums.size()&lt;2) return false;unordered_set&lt;int&gt; s;for(int i=0;i&lt;nums.size();i++)&#123; if(s.find(nums[i])!=s.end()) return true s.insert(nums[i]); if(s.size()&gt;k) s.erase(nums[i-k]);&#125;return false;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"Leetcode - 数组等和分割","slug":"Leetcode-CanSum","date":"2019-04-02T03:33:19.000Z","updated":"2019-09-04T00:52:05.296Z","comments":true,"path":"2019/04/02/Leetcode-CanSum/","link":"","permalink":"https://intptrzero.github.io/2019/04/02/Leetcode-CanSum/","excerpt":"问题给定一个只包含正整数的非空数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。","text":"问题给定一个只包含正整数的非空数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。 思路 动态规划：数组等和分割，可以拆分成能否从数组中找出和为一半的元素，显然该问题与背包问题极其相似。设dp[i][j]为是否能从数组 0 ~ i 号元素中选出和为j。分析不难发现当前数字可以选中或不选，若选中，则结果取决于dp[i-1][j-nums[i]]，若不选，则取决于dp[i-1][j]。得出状态方程dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i]] 深度优先：每个元素要么选中要么丢弃，展开得到一个二叉树，父节点取决于两个叶子节点的结果。 代码(C++)DP1234567891011121314151617181920212223242526int sum=0;const int N=nums.size();for(int i=0;i&lt;N;i++) sum+=nums[i];if(sum &amp; 1) return false;const int S=sum/2;bool dp[N][S+1];//初始化for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=S;j++) dp[i][j]=false;//第一个数(0 ~ 0)for(int j=0;j&lt;=S;j++) dp[0][j]=(j==nums[0]) ? true:false;for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=S;j++) &#123; if(j&lt;nums[i] dp[i][j]=dp[i-1][j]; //数字超过总和，只能舍弃 else dp[i][j]=dp[i-1][j-nums[i]] || dp[i-1][j]; &#125;return dp[N-1][S]; 优化：稍作分析可以看出dp[i][j]只取决于dp[i-1][j]和dp[i-1][j-nums[i]]，两者相差一行，后一步dp可以直接覆盖前一步，将二维数组压缩到一维，空间复杂度降为O(S)。进一步分析可以得知，对于本题不要求给出所有可行方案的前提下，如果在前面的规划过程中得到了dp[S]为true的结果，可以直接返回。 优化DP12345678910111213141516171819202122int sum=0;const int N=nums.size();for(int i=0;i&lt;N;i++) sum+=nums[i];if(sum &amp; 1) return false;const int S=sum/2;bool dp[S+1];//第一个元数(0 ~ 0)for(int j=0;j&lt;=S;j++) dp[j]=(j==nums[0]) ? true:false;//第一个元素等于S，满足等和分割，直接返回if(dp[s]) return true;for(int i=0;i&lt;N;i++) for(int j=S;j&gt;=nums[i];j--) //优先规划和为S的情况。j&lt;nums[i]时dp值等于前一步，直接跳过 &#123; dp[j]=dp[j-nums[i]] || d[j]; if(j==S &amp;&amp; dp[j]) return true; //已有可行方案，直接返回 &#125;return dp[S]; DFS1234567891011121314151617181920bool dfs(int i,int sum)&#123; if(sum==0) return true; if(i&lt;0 || sum&lt;0) //边界条件 return false; return dfs(i-1,sum) || dfs(i-1,sum-nums[i]); //左右分支&#125;int main()&#123; int sum=0; const int N=nums.size(); for(int i=0;i&lt;N;i++) sum+=nums[i]; if(sum &amp; 1) return false; const int S=sum/2; return dfs(N-1,S);&#125; 优化：如果用两个变量分别记录已选和丢弃元素的和，则可以实现左右剪枝。 优化DFS - 剪枝123456789101112131415161718192021222324bool dfs(int i,int sumL,int sumR) //左分支选中，右分支丢弃&#123; if(sumL&gt;S || sumR&gt;S || i&lt;0) //丢弃或已选元素之和超过目标，直接剪枝 return false; if(sumL==S || sumR==S) return true; return dfs(i-1,sumL+nums[i],sumR) || dfs(i-1,sumL,sumR+nums[i]);&#125;int S;int main()&#123; int sum=0; const int N=nums.size(); for(int i=0;i&lt;N;i++) sum+=nums[i]; if(sum &amp; 1) return false; S=sum/2; sort(nums.begin(),nums.end()); //预排序 if(nums.back()&gt;S) //最大元素超过目标值 return false; return dfs(N-1,0,0);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"},{"name":"DFS","slug":"DFS","permalink":"https://intptrzero.github.io/tags/DFS/"}]},{"title":"动态规划 - 背包问题","slug":"DP-zoPack","date":"2019-03-14T10:52:53.000Z","updated":"2019-09-01T15:50:35.100Z","comments":true,"path":"2019/03/14/DP-zoPack/","link":"","permalink":"https://intptrzero.github.io/2019/03/14/DP-zoPack/","excerpt":"问题有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。","text":"问题有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。 分析类似问题如果用暴力求解时间复杂度将不可接受。分析问题发现，对于选定的物品，其状态只有两种 – 拿走或放弃，这是一个很明显的动态规划问题。设dp[i][j]为剩余可选物品数量 i 和剩余空间 j 时的物品价值，则很显然有状态方程：dp[i][j] = max[dp[i - 1][j], dp[i - 1][j - w[i-1]]+v[i-1]]. 前者对应放弃物品，因此背包剩余容量不变。后者对应拿走物品，背包容量减少，总价值加上选中物品价值。 代码C++123456789101112131415161718192021222324252627282930313233int dp[S+1][P+1];int pick[S]; //保存选中物品//初始化for(int i=0;i&lt;S;i++) pick[i]=0;for (int i = 0; i &lt;= S; i++) dp[i][0] = 0;for (int i = 0; i &lt;= P; i++) dp[0][i] = 0;//DPfor (int i = 1; i &lt;= S; i++) for (int j = 1; j &lt;= P; j++) &#123; if (j &lt; w[i - 1]) //背包空间不足 &#123; dp[i][j] = dp[i - 1][j]; continue; &#125; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]); &#125;//反向查找选中物品int j = P;for (int i = S; i &gt;0; i--)&#123; if (dp[i][j] &gt; dp[i - 1][j]) &#123; pick[i - 1] = 1; j -= w[i - 1]; if (j&lt;=0) break; &#125;&#125; 难点：从剩余物品中取时容易理解成贪心算法，每一步DP实际上是从第一个物品选到当前物品","categories":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://intptrzero.github.io/tags/动态规划/"}]},{"title":"Leetcode - 两数之和","slug":"Leetcode-twoSum","date":"2019-02-28T11:11:38.000Z","updated":"2019-09-01T13:39:56.116Z","comments":true,"path":"2019/02/28/Leetcode-twoSum/","link":"","permalink":"https://intptrzero.github.io/2019/02/28/Leetcode-twoSum/","excerpt":"问题给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。","text":"问题给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 思路 先将两数相加，再提取各位数字组成新链表。 优点：代码简单 缺点：无法用于大数计算 边遍历边相加，同时构建链表节点。需要考虑进位问题。 代码C++1234567891011121314151617181920212223242526272829303132bool flag = false;ListNode* L3 = L2;ListNode* cur=nullptr;unsigned short val = 0;while (L2 || L1)&#123; if (L2) &#123; cur = L2; //保存当前位置 val = cur-&gt;val + flag; L2 = L2-&gt;next; &#125; else &#123; cur-&gt;next = L1; //L2比L1短，直接链接到L1 cur = L1; val = flag; &#125; if (L1) &#123; val += L1-&gt;val; L1 = L1-&gt;next; &#125; cur-&gt;val = val % 10; (val &gt; 9) ? flag = 1 : flag = 0;&#125;if (L1 == 0 &amp;&amp; L2 == 0 &amp;&amp; flag == 1) cur-&gt;next = new ListNode(1);return L3; CSharp123456789101112131415161718192021222324252627282930int flag = 0;int val = 0;ListNode L3=L2;ListNode cur=new ListNode(0);while( L2!=null|| L1!=null)&#123; if(L2!=null) &#123; cur = L2; val = cur.val+flag; L2 = L2.next; &#125; else &#123; cur.next = L1; cur = L1; val = flag; &#125; if(L1!=null) &#123; val += L1.val; L1 = L1.next; &#125; cur.val = val % 10; flag = val &gt; 9 ? 1 : 0;&#125;if (L1 == null &amp;&amp; L2 == null &amp;&amp; flag == 1) cur.next = new ListNode(1);return L3; 考查点：单链表、大数计算","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://intptrzero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://intptrzero.github.io/tags/算法/"}]},{"title":"C++泛型基础 - 模板","slug":"C-Template","date":"2018-12-28T02:40:23.000Z","updated":"2019-10-12T10:46:04.077Z","comments":true,"path":"2018/12/28/C-Template/","link":"","permalink":"https://intptrzero.github.io/2018/12/28/C-Template/","excerpt":"函数模板隐式实例化与显式实例化常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2);","text":"函数模板隐式实例化与显式实例化常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2); 模板实际上并不是一个可以直接调用的函数，只有首次使用函数时，编译器才根据参数类型生成一个对应版本的函数实例，然后调用该函数，这个过程称为隐式实例化。C++ 11新增显式实例化: 1template int add(int, int); 该语句提示编译器强制生成一个int版本的模板函数实例，而不管接下来有没有用到该版本的函数。显式实例化可以用于模板函数的声明与定义分离，例如在头文件中声明函数模板，在源文件中定义函数体。 123456789101112131415161718192021222324//头文件 声明template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2);//源文件 定义template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2)&#123; arg1=arg1^arg2; arg2=arg1^arg2; arg1=arg1^arg2;&#125;//不包含此显式实例化将产生link_errortemplate void myswap(int,int);//main.cpp#include \"myswap.h\"int main()&#123; int a,b; a=1,b=2; myswap(a,b) return 0;&#125; 在模板实现文件中显式具体化后强制生成了对应函数实例，main中调用myswap函数时，编译器虽然无法访问函数定义生成main自己的函数实例，但在链接阶段找到了myswap.obj中签名相符的函数实例，因此链接通过。显式实例化避免了重复实例化，缺点是必须在模板实现文件中实例化所有需要的版本，适用于重载需求较少的模板。 显式实例化与具体化模板只能解决“普遍情况”下的问题，对于特殊参数类型，通用模板就无法工作。为了解决类似的“具体”问题，需要为对应的参数类型实现“具体化”的模板定义： 1234template&lt;&gt; char* add(char* pc1, char* pc2)&#123; //...&#125; 显而易见，具体化的模板优先级高于普通模板。如果在同一编译单元同时存在签名相同的显式实例化与具体化，且显式实例化在具体化之前，则会引发重复定义错误，原因是编译器先显式实例化生成了函数实例，但接下来的语句出现了优先级更高的具体化模板，编译器尝试以具体化模板生成函数实例，但已存在相同签名的函数实例，因此引发重复定义错误。反之编译器先以具体化模板为原型生成函数实例，则会跳过优先级较低的显式实例化，编译通过。 12345678910111213141516//通用模板template&lt;typename T&gt;T add(T arg1, T arg2);//a.显式实例化template int add(int, int);//b.相同签名的具体化模板template&lt;&gt; int add(int, int);//交换ab的次序则编译通过int main()&#123; int a=1,b=2; add(a,b); //使用该签名的函数引发重复定义&#125;//模板定义/*......... 模板调用优先级如果同时存在参数类型匹配的非模板函数、普通模板、具体化模板，则非模板 &gt;具体化模板 &gt;通用模板，其中具体化模板参数越具体，其优先级越高。调用时也可以强制使用模板函数，此时只考虑模板的优先级。 1234567int main()&#123; int a=1,b=2; add(a,b); //优先调用非模板add(int,int) add&lt;&gt;(a,b); //强制使用模板，类型自动推断 add&lt;int&gt;(a,b); //使用模板，显式指定模板参数类型为int&#125; 类模板偏特化类模板与函数模板使用方法类似，不过类模板多一个偏特化(或者叫部分具体化)语法： 12345678910111213//通用模板template&lt;typename T&gt;class MyClass&#123; //...&#125;//偏特化模板，特化为指针template&lt;typename T&gt;class MyClass&lt;T*&gt;&#123; //...&#125; 偏特化可以看作是对模板的进一步具体，介于完全具体与完全泛化之间。函数模板没有偏特化语法，因为可以用函数模板重载来实现一样的效果： 123456789101112131415161718template&lt;typename T&gt;void MyFunc(T);//非法使用显式模板参数template&lt;typename T&gt;void MyFunc&lt;T*&gt;(T*);//OK，这是另一种具体化语法，可省略&lt;char*&gt;template&lt;&gt;void MyFunc&lt;char*&gt;(char*);//OK，构成模板重载template&lt;typename T&gt;void MyFunc(T*);//不推荐。编译器将它看作显式实例化，忽略&lt;typename T&gt;以及函数定义。template&lt;typename T&gt;void MyFunc(char*); 以上代码测试结果均来自VS2013，具体情形以编译器实现为准","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"泛型","slug":"泛型","permalink":"https://intptrzero.github.io/tags/泛型/"}]}]}