{"meta":{"title":"IntPtr.Zero","subtitle":"IntPtr.Zero的博客","description":"Code and Learn","author":"IntPtr.Zero","url":"https://intptrzero.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-08-26T01:26:14.220Z","updated":"2019-08-26T01:26:14.220Z","comments":true,"path":"404.html","permalink":"https://intptrzero.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-08-31T07:04:40.996Z","updated":"2019-08-31T07:04:40.996Z","comments":true,"path":"about/index.html","permalink":"https://intptrzero.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 兴趣广泛，专注Windows平台，主要使用C++/.NET，喜欢研究底层。破解爱好者 关于博客本站使用 Hexo 主题 Material X感谢 Github 提供的空间支持以及 Gitalk 评论插件Gitalk表情食用方法：查看Gitalk支持的emoji列表，在评论框输入对应代码即可◕‿-欢迎交流、分享与评论"},{"title":"文章分类","date":"2019-08-28T03:53:58.310Z","updated":"2019-08-28T03:53:58.310Z","comments":true,"path":"categories/index.html","permalink":"https://intptrzero.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-08-30T14:15:02.549Z","updated":"2019-08-30T14:15:02.549Z","comments":true,"path":"tags/index.html","permalink":"https://intptrzero.github.io/tags/index.html","excerpt":"","text":""},{"title":"推荐博文","date":"2019-08-31T06:34:55.830Z","updated":"2019-08-31T06:34:55.830Z","comments":true,"path":"links/index.html","permalink":"https://intptrzero.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"C++模板与泛型 - 函数模板","slug":"C-FunTemplate","date":"2018-12-28T02:40:23.000Z","updated":"2019-08-31T03:09:48.697Z","comments":true,"path":"2018/12/28/C-FunTemplate/","link":"","permalink":"https://intptrzero.github.io/2018/12/28/C-FunTemplate/","excerpt":"隐式实例化与显式实例化函数模板解决的是不同参数类型的函数重载问题，常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2);","text":"隐式实例化与显式实例化函数模板解决的是不同参数类型的函数重载问题，常规的模板函数声明如下: 12template &lt;typename T&gt;T add(T arg1, T arg2); 模板实际上并不是一个可以直接调用的函数，只有首次使用函数时，编译器才根据参数类型自动生成一个对应版本的函数定义，然后调用该函数，这个过程称为隐式实例化。C++ 11新增显式实例化: 1template int add(int, int); 该语句提示编译器强制生成一个int版本的模板函数实例，而不管接下来有没有用到该版本。显式实例化可以用于模板函数的声明与定义分离，例如在头文件中声明一个函数模板，则必须同时包含其定义，否则将会产生链接错误。 123456789101112131415161718192021222324252627282930//myswap.h 声明template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2);//1.不包含定义产生link_error/*&#123; arg1=arg1^arg2; arg2=arg1^arg2; arg1=arg1^arg2;&#125;*///myswap.cpp 定义template&lt;typename T&gt;void myswap(T &amp;arg1, T &amp;arg2)&#123; arg1=arg1^arg2; arg2=arg1^arg2; arg1=arg1^arg2;&#125;//2.不包含显式实例化产生link_error/*template void myswap(int,int);*///main.cpp#include \"myswap.h\"int main()&#123; int a,b; a=1,b=2; myswap(a,b) return 0;&#125; 对于情形1，编译阶段找不到模板定义，无法生成对应的函数实例。如果在头文件包含函数定义，每个使用了myswap函数的源文件都会在自己的编译单元生成函数实例，导致执行文件变大。对于情形2，在模板实现文件中仅包含定义，由于main无法访问myswap.cpp，同样产生link_error，一种解决方法是在main中包含myswap.cpp文件，这种方法有违C++的编程规范，同样无法避免重复生成函数实例的问题。在模板实现文件中显式具体化后强制生成了对应函数实例，main中调用myswap函数时，编译器无法访问函数定义生成main自己的函数实例，但在链接阶段找到了myswap.obj中签名相符的函数实例，因此链接通过。显式实例化避免了重复实例化，缺点是必须在模板实现文件中实例化所有需要的版本，适用于重载需求较少的模板。 显式实例化与具体化模板只能解决“普遍情况”下的重载问题，对于特殊参数类型，例如实现指针的加法(虽然没有意义)，通用模板就无法工作，因为指针没有重载加法操作符。为了解决类似的“具体”问题，需要为对应的参数类型实现“具体化”的模板定义： 1234template&lt;&gt; int* add(int* pint1, int* pint2)&#123; return (int*)((int)pint1 + (int)pint2);&#125; 显而易见，具体化的模板优先级高于普通模板。如果在同一编译单元同时存在签名相同的显式实例化与具体化，且显式实例化在具体化之前，则会引发重复定义错误，原因是编译器显式实例化生成了函数实例，但接下来的语句出现了优先级更高的具体化模板，编译器尝试以具体化模板生成函数实例，但已存在相同签名的函数实例，因此引发错误。反之编译器先以具体化模板为原型生成函数实例，则会跳过优先级较低的显式实例化，编译通过。 12345678910111213141516//通用模板template&lt;typename T&gt;T add(T arg1, T arg2);//a.显式实例化template int add(int, int);//b.相同签名的具体化模板template&lt;&gt; int add(int, int);//交换ab的次序则编译通过int main()&#123; int a=1,b=2; add(a,b); //使用该签名的函数引发重复定义&#125;//模板定义/*......... 函数调用优先级如果同时存在相同签名的非模板函数、普通模板、具体化模板，则非模板 &gt;具体化模板 &gt;普通模板。调用时也可以指定使用模板函数，此时只考虑模板的优先级。 12345int main()&#123; int a=1,b=2; add&lt;int&gt;(a,b); //省略int将自动推断&#125; 以上代码测试结果来自VS2013","categories":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://intptrzero.github.io/tags/C/"},{"name":"泛型","slug":"泛型","permalink":"https://intptrzero.github.io/tags/泛型/"}]}]}