<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL - Deque</title>
      <link href="/2019/07/03/STL-Deque/"/>
      <url>/2019/07/03/STL-Deque/</url>
      
        <content type="html"><![CDATA[<h3 id="双端队列简介"><a href="#双端队列简介" class="headerlink" title="双端队列简介"></a>双端队列简介</h3><p>顾名思义，deque支持在头尾进行插入删除操作。类似于vector和array，deque也是顺序存储结构，没有了解过deque的人在主观上可能会以为deque与vector底层结构类似，实际上为了支持头部插入与删除操作，deque采用<strong>分段连续存储</strong>的数据结构，因此实现上比vector复杂得多。因为采用分段设计，deque的迭代器效率比vector低。<br>为了管理片段，STL的deque在内部定义了一个_Map成员，_Map底层实际是一个T**，也可以将_Map看作一个数组，每一个数组元素指向内存中的一段连续的元素存储空间</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VS2013 deque节选</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Deque_simple_types</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span> _Simple_types&lt;_Ty&gt;</span><br><span class="line">&#123;<span class="comment">// wraps types needed by iterators</span></span><br><span class="line"><span class="keyword">typedef</span> _Ty **_Mapptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_Mapptr _Map;</span><br></pre></td></tr></table></figure><h3 id="双端队列的迭代器"><a href="#双端队列的迭代器" class="headerlink" title="双端队列的迭代器"></a>双端队列的迭代器</h3><p>deque分类上属于顺序存储容器，因此迭代器理所应当提供随机访问迭代器的所有功能。但在内部deque是分段的，因此迭代器需要知道片段的大小以及片段的地址，以在到达片段边缘时跳转到另一个片段。SGI的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr,<span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">deque_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//省略traits定义</span></span><br><span class="line"><span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"><span class="keyword">typedef</span> _deque_iterator self;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个片段的元素容量，如果不指定，默认为512/sizeof(T)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">T*  cur;<span class="comment">//指向片段的当前可插入位置</span></span><br><span class="line">T* first;<span class="comment">//指向片段的头部</span></span><br><span class="line">T* last;<span class="comment">//指向片段的超尾</span></span><br><span class="line">map_pointer node;<span class="comment">//节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点</span></span><br><span class="line">set_node(map_pointer new_node)</span><br><span class="line">&#123;</span><br><span class="line">node=new_node;</span><br><span class="line">first=*new_node;</span><br><span class="line">last=first+difference_type(buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器之间的减法</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(self&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> difference_type(buffer_size())*(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">++cur;</span><br><span class="line"><span class="keyword">if</span>(cur==last)<span class="comment">//到达当前片段超尾</span></span><br><span class="line">&#123;</span><br><span class="line">set_node(node+<span class="number">1</span>);<span class="comment">//跳转到下一片段</span></span><br><span class="line">cur=first;<span class="comment">//指向头部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自减操作类似，略过</span></span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)</span><br><span class="line">&#123;</span><br><span class="line">difference_type offset=n+cur-first;</span><br><span class="line"><span class="comment">//判断是否在同一片段内偏移</span></span><br><span class="line"><span class="keyword">if</span>(offset&gt;=<span class="number">0</span> &amp;&amp; offset&lt;difference_type(buffer_size()))</span><br><span class="line">cur+=n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">difference_type node_offset=offset&gt;<span class="number">0</span> ? offset/difference(buffer_size()):-difference_type((-offset<span class="number">-1</span>)/buffer_size())<span class="number">-1</span>;</span><br><span class="line">set_node(node+node_offset);</span><br><span class="line">cur=first+offset-node_offset*difference_type(buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其它操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双端队列的结构"><a href="#双端队列的结构" class="headerlink" title="双端队列的结构"></a>双端队列的结构</h3><p><img src="/images/assets/deque.jpg" alt="deque结构图"><br>SGI的deque结构如上图所示，其具体实现见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础成员</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=alloc,<span class="keyword">size_t</span> BuffSize=<span class="number">0</span>&gt;</span><br><span class="line">class <span class="built_in">deque</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> _deque_iterator&lt;T,T&amp;,T*,BuffSize&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line">iterator start;<span class="comment">//头部迭代器</span></span><br><span class="line">iterator finish;<span class="comment">//尾部迭代器</span></span><br><span class="line">map_pointer <span class="built_in">map</span>;<span class="comment">//map</span></span><br><span class="line">size_type map_size;<span class="comment">//节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//头部迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line"><span class="comment">//尾部迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首元素</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *start;&#125;</span><br><span class="line"><span class="comment">//尾元素</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iterator tmp=finish;</span><br><span class="line">--tmp;</span><br><span class="line"><span class="keyword">return</span> *tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//略过其它常用接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意deque迭代器取值操作符返回*cur，start迭代器的cur总是指向首元素，finish迭代器的cur指向最后一个元素的下一位，因此需要前移。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> value_type&amp; value):start(),finish(),<span class="built_in">map</span>(<span class="number">0</span>),map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc,<span class="keyword">size_t</span> BuffSize&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n,<span class="keyword">const</span> value_type&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">create_map_and_nodes(n);</span><br><span class="line">map_pointer cur;</span><br><span class="line"><span class="keyword">for</span>(cur=start.node;cur&lt;finish.node;++cur)</span><br><span class="line">uninitialized_fill(*cur,*cur+buffer_size(),value);</span><br><span class="line"><span class="comment">//尾部片段可能还有空闲，因此单独初始化</span></span><br><span class="line">uninitialized_fill(finish.first,finish.cur,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc,<span class="keyword">size_t</span> BuffSize&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_map_and_nodes</span><span class="params">(size_type num_element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//计算初始需要分配的节点数，如果刚好占满n个片段，则额外加一</span></span><br><span class="line">size_type num_nodes=num_element/buffer_size()+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//初始节点数，最少为8。首尾各增加一个以供备用</span></span><br><span class="line">map_size=max(<span class="number">8</span>,num_nodes+<span class="number">2</span>);</span><br><span class="line"><span class="comment">//为map分配内存保存节点</span></span><br><span class="line"><span class="built_in">map</span>=map_allocator::allocate(map_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使初始占用的空间尽量居中，便于首尾插入</span></span><br><span class="line">map_pointer nstart=<span class="built_in">map</span>+(map_size-num_nodes)/<span class="number">2</span>;</span><br><span class="line">map_pointer nfinish=nstart+num_nodes<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">map_pointer cur;</span><br><span class="line"><span class="comment">//为片段分配空间</span></span><br><span class="line"><span class="keyword">for</span>(cur=nstart;cur&lt;=nfinish;++cur)</span><br><span class="line">*cur=allocate_node();</span><br><span class="line"></span><br><span class="line">start.set_node(nstart);</span><br><span class="line">finish.set_node(nfinish);</span><br><span class="line">start.cur=start.first;</span><br><span class="line">finish.cur=finish.first+num_element%buffer_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看deque在内部如何处理元素插入，以push_back为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果尾片段空余空间大于1，则直接赋值</span></span><br><span class="line"><span class="keyword">if</span>(finish.cur != finish.last <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">construct(finish.cur,t);</span><br><span class="line">++finish.cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则新分配一个片段</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">push_back_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back_aux</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value_type t_copy=t;</span><br><span class="line"><span class="comment">//判断是否需要重新分配map</span></span><br><span class="line">reserve_map_at_back();</span><br><span class="line"><span class="comment">//为下一个节点分配一个片段</span></span><br><span class="line">*(finish.node+<span class="number">1</span>)=alocate_node();</span><br><span class="line"><span class="comment">//现在finish所指的片段已满</span></span><br><span class="line">construct(finish.cur,t_copy);</span><br><span class="line"><span class="comment">//尾迭代器指向下一个片段</span></span><br><span class="line">finish.set_node(finish.node+<span class="number">1</span>);</span><br><span class="line">finish.cur=finish.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断尾部是否需要重新分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span><span class="params">(size_type node_to_add=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//尾部备用空间不足</span></span><br><span class="line"><span class="keyword">if</span>(node_to_add&gt;map_size-(finish.node-<span class="built_in">map</span>)<span class="number">-1</span>)</span><br><span class="line"><span class="comment">//false尾部分配</span></span><br><span class="line">reallocate_map(node_to_add,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头部操作类似，略过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reallocate_map</span><span class="params">(size_type node_to_add,<span class="keyword">bool</span> add_at_front)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">size_type old_num_nodes=finish.node-start.node+<span class="number">1</span>;</span><br><span class="line">size_type new_num_nodes=old_num_nodes+node_to_add;</span><br><span class="line">map_pointer new_nstart;</span><br><span class="line"><span class="comment">//对应于一端插入，另一端删除时的极端情况，此时map中只有后半段的节点被利用，不需要重新申请更大的map</span></span><br><span class="line"><span class="keyword">if</span>(map_size&gt;<span class="number">2</span>*new_num_nodes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//重新安排头部节点到中间</span></span><br><span class="line">new_nstart=<span class="built_in">map</span>+(map_size-new_num_nodes)/<span class="number">2</span>+(add_at_front?node_to_add:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(new_nstart&lt;start.node)</span><br><span class="line"><span class="comment">//先序复制防止左边被覆盖</span></span><br><span class="line">copy(start.node,finish.node+<span class="number">1</span>,new_nstart);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//后序复制防止右边被覆盖</span></span><br><span class="line">copy_backward(start.node,finish.node+<span class="number">1</span>,new_nstart+old_num_nodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应正常情况，map中空余节点不足</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">size_type new_map_size=map_size+max(map_size,node_to_add)+<span class="number">2</span>;</span><br><span class="line"><span class="comment">//申请更大的map</span></span><br><span class="line">map_pointer new_map=map_allocator::allocate(new_map_size);</span><br><span class="line"><span class="comment">//开始节点居中</span></span><br><span class="line">new_nstart=new_map+(new_map_size-new_num_nodes)/<span class="number">2</span>+(add_at_front?node_to_add:<span class="number">0</span>);</span><br><span class="line"><span class="comment">//复制原节点</span></span><br><span class="line">copy(start.node,finish.node+<span class="number">1</span>,new_start);</span><br><span class="line"><span class="comment">//释放原map</span></span><br><span class="line">map_allocator::deallocate(<span class="built_in">map</span>,map_size);</span><br><span class="line"><span class="built_in">map</span>=new_map;</span><br><span class="line">map_size=new_map_size;</span><br><span class="line">&#125;</span><br><span class="line">start.set_node(new_nstart);</span><br><span class="line">finish.set_node(new_nstart+old_num_nodes+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是删除操作，SGI的deque在片段中没有元素时会销毁片段以节省内存，具体实现如下，以pop_back为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//尾部片段有元素</span></span><br><span class="line"><span class="keyword">if</span>(finish.cur!=finish.first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意cur指向最后一个元素的下一位</span></span><br><span class="line">--finish.cur;</span><br><span class="line">destroy(finish.cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//没有元素</span></span><br><span class="line">pop_back_aux();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back_aux</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//销毁这个空片段</span></span><br><span class="line">deallocate_node(finish.first);</span><br><span class="line"><span class="comment">//跳转到上一个节点</span></span><br><span class="line">finish.set_node(finish.node<span class="number">-1</span>);</span><br><span class="line">finish.cur=finish.last<span class="number">-1</span>;</span><br><span class="line">destroy(finish.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop_front类似，略过</span></span><br></pre></td></tr></table></figure><p>接下来是clear方法，该方法清除deque所有元素并将deque初始化，SGI的deque在初始状态仍会保留一个片段，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(map_pointer node=start.node+<span class="number">1</span>;node&lt;finish.node;++node)</span><br><span class="line">&#123;<span class="comment">//析构元素</span></span><br><span class="line">destroy(*node,*node+buffer_size());</span><br><span class="line"><span class="comment">//销毁片段</span></span><br><span class="line">deallocate(*node,buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头尾不在同一个片段</span></span><br><span class="line"><span class="keyword">if</span>(start.node!=finish.node)</span><br><span class="line">&#123;</span><br><span class="line">destroy(start.cur,start.last);</span><br><span class="line">destroy(finish.first,finish.cur);</span><br><span class="line"><span class="comment">//仅销毁尾部</span></span><br><span class="line">deallocate(finish.first,buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//仅析构</span></span><br><span class="line">destroy(start.cur,finish.cur);</span><br><span class="line">finish=start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上常见的deque操作都与上面的实现类似，注意map的操作即可。</p><h3 id="MS的deque实现"><a href="#MS的deque实现" class="headerlink" title="MS的deque实现"></a>MS的deque实现</h3><p>MS与SGI的实现有较大区别，首先在deque内部成员上VS2013没有定义start和finish两个迭代器，而是定义了一个_Myoff记录头节点偏移量以及_Mysize记录元素数量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type _Myoff;</span><br><span class="line">size_type _Mysize;</span><br></pre></td></tr></table></figure><p>在内部，deque利用_Myoff计算节点下标来访问节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_type _Getblock(size_type off) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//_DEQUESIZE片段长度，_Mapsize代表map的大小</span></span><br><span class="line"><span class="keyword">return</span> ((off/_DEQUESIZE) &amp; (<span class="keyword">this</span>-&gt;_Mapsize<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，MS的deque采用倍增的扩展策略，即每次重新分配map时大小变为原来的2倍(初始为8，不可自定义)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VS2013</span></span><br><span class="line"><span class="keyword">void</span> _Growmap(size_type _Count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alpty::pointer _Blockptr;</span><br><span class="line">_Alpty _Almap(<span class="keyword">this</span>-&gt;_Getal());</span><br><span class="line">size_type _Newsize = <span class="number">0</span> &lt; <span class="keyword">this</span>-&gt;_Mapsize ? <span class="keyword">this</span>-&gt;_Mapsize : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (_Newsize - <span class="keyword">this</span>-&gt;_Mapsize &lt; _Count || _Newsize &lt; _DEQUEMAPSIZ)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//size加倍</span></span><br><span class="line">_Newsize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算需要新增的节点数量</span></span><br><span class="line">_Count = _Newsize - <span class="keyword">this</span>-&gt;_Mapsize;</span><br><span class="line"><span class="comment">//计算头节点偏移</span></span><br><span class="line">size_type _Myboff = <span class="keyword">this</span>-&gt;_Myoff / _DEQUESIZ;</span><br><span class="line"><span class="comment">//申请新的map</span></span><br><span class="line">_Mapptr _Newmap = _Almap.allocate(<span class="keyword">this</span>-&gt;_Mapsize + _Count);</span><br><span class="line"><span class="comment">//新的头节点</span></span><br><span class="line">_Mapptr _Myptr = _Newmap + _Myboff;</span><br><span class="line"><span class="comment">//复制旧节点</span></span><br><span class="line">_Myptr = _Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map + _Myboff,<span class="keyword">this</span>-&gt;_Map + <span class="keyword">this</span>-&gt;_Mapsize,_Myptr, _Almap);</span><br><span class="line"><span class="comment">//如果新增节点数量大于头节点偏移</span></span><br><span class="line"><span class="keyword">if</span> (_Myboff &lt;= _Count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//复制旧map头节点之前未使用的节点到新map的尾部(意义不明，应该是为了减少初始化次数)</span></span><br><span class="line">_Myptr = _Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map,<span class="keyword">this</span>-&gt;_Map + _Myboff,_Myptr, _Almap);</span><br><span class="line"><span class="comment">//初始化剩余的尾部节点</span></span><br><span class="line">_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,_Almap);</span><br><span class="line"><span class="comment">//初始化头部节点</span></span><br><span class="line">_Uninitialized_default_fill_n(_Newmap, _Myboff, _Almap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//复制旧map头部未使用的节点到新map尾部</span></span><br><span class="line">_Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map,<span class="keyword">this</span>-&gt;_Map + _Count,_Myptr, _Almap);</span><br><span class="line"><span class="comment">//复制剩余的旧map头部到新map头部</span></span><br><span class="line">_Myptr = _Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map + _Count,</span><br><span class="line"><span class="keyword">this</span>-&gt;_Map + _Myboff,_Newmap, _Almap);</span><br><span class="line"><span class="comment">//初始化新map头部未能复制到的节点</span></span><br><span class="line">_Uninitialized_default_fill_n(_Myptr, _Count, _Almap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构旧map元素</span></span><br><span class="line">_Destroy_range(<span class="keyword">this</span>-&gt;_Map + _Myboff, <span class="keyword">this</span>-&gt;_Map + <span class="keyword">this</span>-&gt;_Mapsize, _Almap);</span><br><span class="line"><span class="comment">//释放旧map空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_Map != _Mapptr())</span><br><span class="line">_Almap.deallocate(<span class="keyword">this</span>-&gt;_Map,<span class="keyword">this</span>-&gt;_Mapsize);</span><br><span class="line"><span class="keyword">this</span>-&gt;_Map = _Newmap;<span class="comment">// point at new</span></span><br><span class="line"><span class="keyword">this</span>-&gt;_Mapsize += _Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比起来MS的实现更加复杂化，结构层次也不明显，代码质量明显比SGI差很多。最后再吐槽一下MS神奇的变量命名方式以及各种奇葩#define。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL - 迭代器</title>
      <link href="/2019/06/09/STL-Iterator/"/>
      <url>/2019/06/09/STL-Iterator/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器概念"><a href="#迭代器概念" class="headerlink" title="迭代器概念"></a>迭代器概念</h3><p>STL设计迭代器的初衷就是将容器细节与算法分离，转而用迭代器作为两者的桥梁。迭代器作为一种访问容器的结构，其本质上也是一种对指针的高级包装而已，因此对应于容器的结构特点，迭代器也分为单向迭代器(典型如单链表)、双向迭代器(如双链表)和随机访问迭代器(如vector等顺序存储容器)。</p><a id="more"></a><h3 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h3><p>作为对容器元素指针的高级包装，迭代器不可避免的会暴露容器的实现细节，因此将迭代器完全脱离容器是不现实的，故STL容器都在内部实现了对应于特定容器的迭代器。为了说明迭代器的实现原理，下面以一个自定义的容器类MyList来进行演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MYLIST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MYLIST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T _value;</span><br><span class="line">MyListNode&lt;T&gt;* _next;</span><br><span class="line"></span><br><span class="line">MyListNode():_value(<span class="number">0</span>),_next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListIter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NodeTy* ptr;</span><br><span class="line">MyListIter( NodeTy* p = <span class="literal">nullptr</span>) :ptr(p)&#123;&#125;</span><br><span class="line"></span><br><span class="line">NodeTy&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">NodeTy* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">MyListIter&amp; <span class="keyword">operator</span>++() &#123; ptr = ptr-&gt;_next; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">MyListIter <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; MyListIter tmp = (*<span class="keyword">this</span>); ++(*<span class="keyword">this</span>); <span class="keyword">return</span> tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyListIter&amp; i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr == i.ptr; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> MyListIter&amp; i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr != i.ptr; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MyListNode&lt;T&gt;* _head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_front</span><span class="params">(T v)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">MyListNode&lt;T&gt;* tmp = <span class="keyword">new</span> MyListNode&lt;T&gt;;</span><br><span class="line">tmp-&gt;_value = v;</span><br><span class="line">tmp-&gt;_next = _head-&gt;_next;</span><br><span class="line">_head-&gt;_next=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream&amp; os = <span class="built_in">std</span>::<span class="built_in">cout</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyListNode&lt;T&gt;* tmp = _head-&gt;_next;</span><br><span class="line"><span class="keyword">while</span> (tmp)</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; tmp-&gt;_value&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">tmp = tmp-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyList() </span><br><span class="line">&#123; </span><br><span class="line">_head = <span class="keyword">new</span> MyListNode&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyListIter&lt;MyListNode&lt;T&gt;&gt; begin() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MyListIter&lt;MyListNode&lt;T&gt;&gt;(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyListIter&lt;MyListNode&lt;T&gt;&gt; end() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MyListIter&lt;MyListNode&lt;T&gt;&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy,<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function">IterTy <span class="title">find</span><span class="params">(IterTy begin,IterTy end, Ty value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyList&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)</span><br><span class="line">mylist.insert_front(i);</span><br><span class="line">mylist.display();</span><br><span class="line"><span class="keyword">auto</span> ibegin=mylist.begin();</span><br><span class="line"><span class="keyword">auto</span> iend = mylist.end();</span><br><span class="line"><span class="keyword">auto</span> result = find(ibegin, iend, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result.ptr-&gt;_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy, <span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function">IterTy <span class="title">find</span><span class="params">(IterTy begin, IterTy end, Ty value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (begin != end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (begin-&gt;_value == value)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的简单链表迭代器，我们成功实现了独立于容器的泛型算法find。上述的迭代器仅仅是个雏形，如果一个算法需要一个迭代器类型变量而返回一个迭代器指向的元素类型，在仅使用一个模板参数的情况下，上述迭代器根本不可能做到。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个参数可行</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy,<span class="keyword">typename</span> NodeTy&gt;</span><br><span class="line"><span class="function">NodeTy <span class="title">somefunc</span><span class="params">(IterTy iter,NodeTy el)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NodeTy tmp;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个参数无法完成</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy&gt;</span><br><span class="line">? somefunc(IterTy iter)</span><br><span class="line">&#123;</span><br><span class="line">? tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上以上问题在allocator中已经出现过，STL在allocator中的解决方法是rebind，简单来说就是将可能会用到的类型定义为内嵌类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListIter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> NodeTy value_type;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy&gt;</span><br><span class="line"><span class="keyword">typename</span> IterTy::<span class="function">value_type <span class="title">somefunc</span><span class="params">(IterTy iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//现在仅需要一个模板参数</span></span><br><span class="line"><span class="keyword">typename</span> IterTy::value_type tmp；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而以上技巧仅适用于迭代器类，对于无法定义内嵌类型的原生指针无能为力。泛型算法不应该仅考虑到迭代器，原生指针的行为理应与迭代器类似。</p><h3 id="Traits编程技巧"><a href="#Traits编程技巧" class="headerlink" title="Traits编程技巧"></a>Traits编程技巧</h3><p>Traits直译为“特性，特征”，即人为的赋予对象某些修饰，在需要的时候提取出来。显而易见，traits技术也只能用于类，仍然对原生指针束手无策。为了解决此问题，我们需要对原生指针进行一次包装，而包装方法就是使用模板偏特化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iter_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> IterTy::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针偏特化模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iter_traits</span>&lt;Ty*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Ty value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在无论是原生指针还是迭代器都可以使用iter_traits<t>::value_type获取指向的元素类型。根据编程经验，STL规定迭代器至少定义5种基本特性：value_type、difference_type、pointer、reference和iterator_category</t></p><ol><li>value_type:即迭代器指向的元素类型</li><li>difference_type:迭代器之间的距离</li><li>pointer:指向元素的指针</li><li>reference:元素的引用</li><li>category:迭代器类型</li></ol><p>前面提到迭代器对应于特定容器分为单向迭代器、双向迭代器和随机访问迭代器，功能上还可分为输入迭代器和输出迭代器。很显然不同迭代器可定义的操作和效率是不同的，因此区分迭代器类型有利于提升性能。以advance()函数为例，该函数将一个给定的迭代器移动给定的距离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_fiter</span><span class="params">(ForwardIter&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BidIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_biter</span><span class="params">(BidIter&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(n++)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机访问迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RndIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_rnditer</span><span class="params">(RndIter&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了区分迭代器类型而设计三个函数显然不明智，然而上述函数都是两个模板参数的模板函数，无法重载，因此需要引入另一个不同的参数达成重载条件，STL的做法是引入一个迭代器类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span><span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span><span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span><span class="keyword">public</span> bidirectional)iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">void</span> _advance(InputIter&amp; i,Distance n,input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//外部接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,Distance n&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(Iterator&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_advance(i,n,iterator_traits&lt;Iterator&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过定义几个用于标识迭代器类型的空类并作为参数启用函数重载，并在外部调用时使用traits技术获取迭代器类型，完成了不同迭代器的函数实现。并且STL迭代器类型是继承关系，利用模板协变，适用于低级迭代器的函数也可用于高级迭代器。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL - 内存分配器</title>
      <link href="/2019/06/01/STL-Allocator/"/>
      <url>/2019/06/01/STL-Allocator/</url>
      
        <content type="html"><![CDATA[<h3 id="标准内存分配器"><a href="#标准内存分配器" class="headerlink" title="标准内存分配器"></a>标准内存分配器</h3><p>定义STL容器时有一个可选参数allocator，缺省情况下使用STL自带的默认allocator类进行内存分配。allocator类在VS2013下由头文件xmemory0定义，间接由memory头文件引用。类声明节选如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Allocator_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocator类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span>:</span><span class="keyword">public</span> _Allocator_base&lt;_Ty&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//STL标准需要的类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> allocator&lt;_Ty&gt; other;</span><br><span class="line"><span class="keyword">typedef</span> _Allocator_base&lt;_Ty&gt; _Mybase;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Mybase::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type *pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *void_pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">void</span> *const_void_pointer;</span><br><span class="line"><span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个空构造函数</span></span><br><span class="line">allocator() &#123;&#125;</span><br><span class="line">allocator(<span class="keyword">const</span> allocator&lt;_Ty&gt;&amp;) &#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Other&gt;</span><br><span class="line">allocator(<span class="keyword">const</span> allocator&lt;_Other&gt;&amp;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rebind</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Other&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> allocator&lt;_Other&gt; other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其它成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中略难理解的是rebind结构，rebind只有一个other成员用来代表allocator&lt;_Other&gt;，这一步貌似有点多余，何不在需要的时候直接声明一个allocator&lt;_Other&gt;类型的分配器呢。STL的allocator是为容器服务的，要弄清楚设计者的目的，需要联系容器的实现。作为普通容器如vector和array等，它们的元素是<strong>直接</strong>存储的，而list等容器有一个中间存储结构node，且node与元素类型是有关的。在分配内存时需要为节点类型node&lt;T&gt;和元素类型T传入对应的allocator，而声明list时只传入了元素类型T，因此需要某种方法根据allocator&lt;T&gt;得到allocator&lt;node&lt;T&gt;&gt;，这时rebind的作用就体现出来了。附VS2013的部分list实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,<span class="title">class</span> _<span class="title">Alloc0</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_base_types</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _Alloc0 _Alloc;</span><br><span class="line"><span class="keyword">typedef</span> _List_base_types&lt;_Ty, _Alloc&gt; _Myt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> _Wrap_alloc&lt;_Alloc&gt; _Alty0;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向底层元素的rebind</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alty0::<span class="keyword">template</span> rebind&lt;_Ty&gt;::other _Alty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Get_voidptr&lt;_Alty, <span class="keyword">typename</span> _Alty::pointer&gt;::type</span><br><span class="line">_Voidptr;</span><br><span class="line"><span class="keyword">typedef</span> _List_node&lt;<span class="keyword">typename</span> _Alty::value_type,</span><br><span class="line">_Voidptr&gt; _Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向节点类型的rebind</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alty::<span class="keyword">template</span> rebind&lt;_Node&gt;::other _Alnod_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alnod_type::pointer _Nodeptr;</span><br><span class="line"><span class="keyword">typedef</span> _Nodeptr&amp; _Nodepref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rebind算是一种比较巧妙的方法，在元素与中间结构之间创建某种联系，从而达到只需要一个模板参数即可创建多级内存分配器的目的。</p><p>STL标准要求的其它函数接口实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer _Ptr, size_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// deallocate object at _Ptr, ignore size</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_Ptr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _Count)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// allocate array of _Count elements</span></span><br><span class="line"><span class="keyword">return</span> (_Allocate(_Count, (pointer)<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _Count, <span class="keyword">const</span> <span class="keyword">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// allocate array of _Count elements, ignore hint</span></span><br><span class="line"><span class="keyword">return</span> (allocate(_Count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(_Ty *_Ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// default construct object at _Ptr</span></span><br><span class="line">::<span class="keyword">new</span> ((<span class="keyword">void</span> *)_Ptr) _Ty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(_Ty *_Ptr, <span class="keyword">const</span> _Ty&amp; _Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// construct object at _Ptr with value _Val</span></span><br><span class="line">::<span class="keyword">new</span> ((<span class="keyword">void</span> *)_Ptr) _Ty(_Val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Objty</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">construct</span>(_<span class="title">Objty</span> *_<span class="title">Ptr</span>, _<span class="title">Types</span>&amp;&amp;... _<span class="title">Args</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// construct _Objty(_Types...) at _Ptr</span></span><br><span class="line">::<span class="keyword">new</span> ((<span class="keyword">void</span> *)_Ptr) _Objty(_STD forward&lt;_Types&gt;(_Args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Uty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">destroy</span>(_<span class="title">Uty</span> *_<span class="title">Ptr</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// destroy object at _Ptr</span></span><br><span class="line">_Ptr-&gt;~_Uty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与SGI的二级分配器实现相比更简单，直接调用全局的operator new和delete，没有额外的内存优化。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET - 委托</title>
      <link href="/2019/05/22/CLR-Delegate/"/>
      <url>/2019/05/22/CLR-Delegate/</url>
      
        <content type="html"><![CDATA[<h3 id="委托与函数指针"><a href="#委托与函数指针" class="headerlink" title="委托与函数指针"></a>委托与函数指针</h3><p>在C++中经常需要以变量形式传递函数，函数在底层实际上就是一个地址，调用时跳转到相应的地址执行代码，函数指针类型可以非常方便的用来传递函数地址，但C++中的函数指针仅仅是一个指针类型变量，无法提供参数和返回值等详细信息，因此函数指针不是类型安全的。CLR在此基础上更进一步，将函数指针抽象化为委托，增强了类型安全。</p><a id="more"></a><h3 id="委托的底层原理"><a href="#委托的底层原理" class="headerlink" title="委托的底层原理"></a>委托的底层原理</h3><p>先来看看委托的声明语句：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyCallback</span>(<span class="params">Int32 v</span>)</span>;</span><br></pre></td></tr></table></figure><p>编译器实际上为上述语句生成如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyCallback:System.MulticastDelegate</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCallback</span>(<span class="params">Object obj, IntPtr method</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params">Int32 v</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IAsyncResult <span class="title">BeginInvoke</span>(<span class="params">Int32 v, AsyncCallback callback, Object obj</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndInvoke</span>(<span class="params">IAsyncResult result</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，CLR将C++的函数指针包装成了一个类，自定义的委托类全部派生于CLR内置的MulticastDelegate类。MulticastDelegate类有三个重要的字段：  </p><ol><li>_target：对象实例</li><li>_methodPtr：方法指针</li><li>_invocationList：委托链，单播委托为null</li></ol><p>例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params">Int32 v</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(v.ToString);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a=<span class="keyword">new</span> A;</span><br><span class="line">MyCallback mcb=<span class="keyword">new</span> MyCallback(a.Show);</span><br><span class="line">mcb(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:3</span></span><br></pre></td></tr></table></figure><p>在上述代码中_target=a，_methodPtr指向Show方法。代码中mcb(3)语句实际上是个语法糖，编译器在底层将它翻译为mcb.Invoke(3)，Invoke方法实际上也是使用_target与_methodPtr确定要调用的方法。</p><h3 id="委托链"><a href="#委托链" class="headerlink" title="委托链"></a>委托链</h3><p>由基类MulticastDelegate的名称很容易看出支持多个委托调用。多个委托与单个委托略有区别，由于需要保存多个回调，_target和_methodPtr显然是不够用的，因此需要使用_invocationList字段。_invocationList实际上是一个委托对象数组，每次使用Delegate.Combine方法添加委托时，委托对象被添加到数组中。多播委托与单播委托使用方法一样，调用Invoke方法时，依次对每一个委托数组元素调用Invoke，因此如果委托具有返回值，将只返回最后一个回调函数的返回值。Invoke方法的实现大致如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params">Int32 v</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Delegate[] delegateArray = _invocationList <span class="keyword">as</span> Delagate[]</span><br><span class="line"><span class="keyword">if</span>(delegateArray != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span>(MyCallback del <span class="keyword">in</span> delgateArray)</span><br><span class="line">del.Invoke(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//根据_target调用_methodPtr指向的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以添加委托，还可以使用Delegate.Remove方法删除委托，方法查找源委托链中与目标委托签名一致的委托对象，并删除第一个匹配项。如果删除后委托链为空，则返回null。如果删除后委托链只有一个元素，则返回该委托元素，源委托变为单播委托，委托链为null。</p>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与多态 - 继承</title>
      <link href="/2019/05/18/Class-Func/"/>
      <url>/2019/05/18/Class-Func/</url>
      
        <content type="html"><![CDATA[<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p>C++支持三种不同的继承方式：private、protected和public，继承方式只影响派生类外部对基类成员的访问权限，而不影响派生类在内部对基类成员的访问权限。私有继承意味着所有基类成员将被继承为派生类的私有成员；保护继承意味着基类所有public成员被继承为protected，其它成员不受影响；公有继承则保持基类成员的原有访问控制不变。例子：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _ID;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* _Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;_ID&lt;&lt;<span class="string">": "</span>&lt;&lt;_Name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//内部访问权限不受影响，可访问基类protected和public成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;<span class="comment">//protected Base::name</span></span><br><span class="line">show();<span class="comment">//public Base::show()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承同上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span>:</span> <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;</span><br><span class="line">show();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child3</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;</span><br><span class="line">show();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Child1已将基类成员继承为private，CChild1显然不可访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CChild1</span>:</span> <span class="keyword">public</span> Child1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;<span class="comment">//不可访问:private Child1::name</span></span><br><span class="line">show();<span class="comment">//不可访问:private Child1::show()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Child2是保护继承，基类非private成员均被继承为protected，CChild2显然可以访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CChild2</span>:</span> <span class="keyword">public</span> Child2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;<span class="comment">//OK:protected Child2::name</span></span><br><span class="line">show();<span class="comment">//OK:protected Child2::show()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1 c1;</span><br><span class="line">Child2 c2;</span><br><span class="line">c1.show();<span class="comment">//不可访问</span></span><br><span class="line">c2.show();<span class="comment">//不可访问</span></span><br></pre></td></tr></table></figure><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>解释方法重写前需要弄明白函数重载与方法重写的概念。函数重载发生在同一类作用域，而方法重写发生在类继承中，即使子类用不同的参数列表重写父类方法，他也不是重载，而是重写，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"base"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child c;</span><br><span class="line">c.show();<span class="comment">//Error</span></span><br><span class="line">c.show(<span class="number">0</span>);<span class="comment">//OK</span></span><br></pre></td></tr></table></figure><p>这种情况下属于重写，子类只可调用带参数版本，原版本将被子类隐藏。</p><p>派生类重写基类方法分为两种情况：虚方法和非虚方法，重写虚方法要求子类与父类保持方法签名一致，否则将变成普通方法重写，且子类隐藏父类虚方法。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"base"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child1"</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child1 virtual"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Child c;</span><br><span class="line">c.show();<span class="comment">//Error.子类重写虚方法未保持函数签名一致,退化为普通方法重写，将隐藏基类同名方法。</span></span><br><span class="line">Child1 c1;</span><br><span class="line">c1.show();<span class="comment">//OK.重写虚方法</span></span><br><span class="line">c1.show(<span class="number">0</span>);<span class="comment">//OK.构成重载</span></span><br></pre></td></tr></table></figure><p>在.NET中，MS对C++原有的继承关系做了进一步包装。首先取消了多重继承和非公有继承；其次将抽象类细化为抽象基类和接口；最后对方法重写规则做了一些额外的限制。例如对于普通方法重写，编译器要求显式指定new(<del>Shadows</del>)关键字；对于虚方法重写，要求显式指定override(<del>s</del>)关键字，否则一律视为普通方法重写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BaseCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"Base"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚方法重写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ChildCls</span>:<span class="title">BaseCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"Child"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通重写(new可省略)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">BadChildCls</span>:<span class="title">BaseCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> new <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"BadChild"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseCls a,b;</span><br><span class="line">a=<span class="keyword">new</span> ChildCls();</span><br><span class="line">b=<span class="keyword">new</span> BadChildCls();</span><br><span class="line">a.show();</span><br><span class="line">b.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">Child</span></span><br><span class="line"><span class="comment">Base</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>BadChildCls使用new重写，因此虚函数表不会记录BadChildCls的show()方法。</p><h3 id="VB-NET语法糖"><a href="#VB-NET语法糖" class="headerlink" title="VB.NET语法糖"></a>VB.NET语法糖</h3><p>相比于C#，VB.NET增加了一个额外的关键字Overloads用于显式重载函数，它也可以简化虚方法重写与重载：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> Base</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overridable</span> <span class="keyword">Sub</span> Show()</span><br><span class="line">Console.WriteLine(<span class="string">"base"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> Child:<span class="keyword">Inherits</span> Base</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overloads</span> <span class="keyword">Sub</span> Show(<span class="keyword">Byval</span> i <span class="keyword">as</span> Int32)</span><br><span class="line">Console.WriteLine(<span class="string">"child"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> c <span class="keyword">as</span> <span class="keyword">New</span> Child</span><br><span class="line">c.Show(0)//OK</span><br><span class="line">c.Show()//OK</span><br></pre></td></tr></table></figure><p>上述代码实际上可以拆分为：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> Child:<span class="keyword">Inherits</span> Base</span><br><span class="line">//虚方法重写</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overrides</span> <span class="keyword">Sub</span> Show()</span><br><span class="line"><span class="keyword">MyBase</span>.Show()</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line">//函数重载</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overloads</span> <span class="keyword">Sub</span> Show(<span class="keyword">Byval</span> i <span class="keyword">as</span> Int32)</span><br><span class="line">Console.WriteLine(<span class="string">"child"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br></pre></td></tr></table></figure><p>不过两者略有区别，通过查看IL代码，第一种写法中Child只有Show(Int32)方法，对Show()的调用直接编译为MyBase.Show()，可见.NET的编译器足够智能。</p>]]></content>
      
      
      <categories>
          
          <category> 类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR - 内存管理与垃圾回收</title>
      <link href="/2019/05/12/CLR-GC/"/>
      <url>/2019/05/12/CLR-GC/</url>
      
        <content type="html"><![CDATA[<h3 id="CLR内存分配"><a href="#CLR内存分配" class="headerlink" title="CLR内存分配"></a>CLR内存分配</h3><p>无论是C#、VB.NET或是Java，这些所谓的高级编程语言实际上都致力于解决C++中常见的内存泄露问题，方法很简单 – 那就是剥夺程序员对于物理内存空间的直接控制权，重新虚拟一层“可控”的内存空间，并由框架(.NET的CLR以及Java的JVM)自行处理内存问题。这样虽然牺牲了一点点性能以及少许灵活性，但大大提高了安全性，更不用说框架封装所带来的便利。</p><a id="more"></a><p>类似于C++，CLR中动态分配的内存存在于一个叫做“托管堆”的地方。程序集初始化时，CLR在物理内存中划出一块作为进程的托管堆，托管堆类似于数据结构中的栈，它维护一个指针，指向下一块可被分配的内存。当使用new操作符声明新对象时，CLR首先计算对象的字节大小，然后再加上一个对象类型指针和一个同步块索引，然后检查托管堆是否拥有足够的可用空间，如果空间足够，则托管堆内部指针向后移动相应距离。</p><h3 id="CLR垃圾回收"><a href="#CLR垃圾回收" class="headerlink" title="CLR垃圾回收"></a>CLR垃圾回收</h3><p>托管堆内存不足以分配新对象时(或主动调用GC)，CLR便会发起垃圾回收。垃圾回收有许多不同的实现方法，例如COM中采用的引用计数，但引用计数无法处理循环引用的问题，即对象AB互相引用，则引用计数永远不可能为0，从而引发内存泄漏。<br>.NET和Java都采用引用跟踪算法，即将对象变量看作“根”。在垃圾回收时CLR挂起整个线程以防止垃圾回收过程中的状态变化，CLR先将托管堆中所有对象标记为垃圾(将同步索引的某一位置为0)，然后以变量为根，向下搜索变量引用的对象和对象的成员所引用的对象，如果变量非NULL，则引用的对象被标记为非垃圾，如果对象已被标记为非垃圾，cLR跳过检查该对象的成员字段，防止循环引用造成的死循环。<br>标记完成后，CLR将所有非垃圾对象整合到一段连续的内存空间并移动内部指针，这样可以解决传统C++中的内存碎片化问题。但整合内存意味着对象的地址发生变化，因此垃圾清理后必须恢复变量指向的对象的地址。</p><h3 id="GC的性能优化"><a href="#GC的性能优化" class="headerlink" title="GC的性能优化"></a>GC的性能优化</h3><p>如果每次都检查并移动托管堆中的所有对象，那么会造成比较大的性能开销，因此.NET和Java都采用了基于“代”的回收机制。“分代”的原理很简单，如果某对象经过一次垃圾回收后仍存活，则代数提高一代，而垃圾回收时优先回收第0代，理由是活的越久的对象越有可能继续存活，因此优先回收第0代有更大可能回收更多的空间。<br>CLR将托管堆对象分为0、1、2三代，CLR对三块内存空间采取了动态负载的方案。垃圾回收时，如果第0代大部分对象都是垃圾，此时垃圾回收的代价很小(仅需要复制少量内存块以及修改少许指针)，CLR会相对分配较少的空间给第0代；反之，CLR分配较大的内存空间，以减少垃圾回收的次数。此策略也适用于1、2代。</p><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>CLR将对象分为大对象和小对象，大对象是大小超过85000字节左右的对象，大对象与小对象并不在同一内存空间分配，且初始即为第2代，因为在内存中移动大对象的代价过高。</p><h3 id="Finalize与Dispose"><a href="#Finalize与Dispose" class="headerlink" title="Finalize与Dispose"></a>Finalize与Dispose</h3><p>当程序集调用非托管的本机资源对象(如File或Mutex)时，CLR只能回收托管内存，造成本机内存的泄露。因此CLR为封装的本机资源对象设计了Finalize方法，拥有该方法的对象在GC执行之后才会被CLR调用该方法，如果方法内有访问对象字段的代码，则此对象的内存并不能立即被回收，这导致对象活得更久，增加了内存消耗。Finalize被设计为<strong>只能由CLR调用</strong>，托管内存由CLR负责清理，因此Finalize负责清理非托管资源，例如文件句柄。<br>然而Finalize只有当对象被标记为垃圾且在GC执行后才可能被调用，并且调用时间无法确定，因此有必要设计另一种由开发者精确控制的清理机制，对此CLR设计了IDisposeable接口，接口暴露Dispose方法，实现接口的对象可以由开发者主动调用Dispose方法立即执行非托管资源的清理。实现如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DisposablClass</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//标记是否已回收</span></span><br><span class="line">    <span class="keyword">bool</span> disposed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dispose(<span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>); <span class="comment">//移除Finalize调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~DisposableClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(disposed) <span class="keyword">return</span>; <span class="comment">//防止多次执行</span></span><br><span class="line">        <span class="keyword">if</span>(disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span>释放本对象的托管资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span>释放非托管资源</span></span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部的Dispose(bool)参数用来标识被Dispose还是Finalize调用，如果是Dispose，则需要自己清理托管资源，同时移除GC对本对象的Finalize调用。如果是Finalize，则托管资源已由GC处理，只需要清理非托管资源。<br>调用非托管资源的对象类设计原则：如果类实现了Finalize，则也应实现可控的Dispose方法，并在方法中移除GC对Finalize的调用；反之，实现了Dispose方法也应实现Finalize，以防止开发者忘记调用Dispose。</p>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 字符串转换</title>
      <link href="/2019/04/12/Leetcode-stredis/"/>
      <url>/2019/04/12/Leetcode-stredis/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">问题</a></h3><p>给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于类似第一时间想不出解法的问题，首先考虑动态规划。设dp[i][j]代表从长度i的字符串转换为长度j的字符串需要的最少操作数，若word1[i-1]==word2[j-1]，则显然最后一个字符无需任何操作，因此dp[i][j]=dp[i-1][j-1]。若word1[i-1]!=word2[j-1]，则最后一位字符需要一次操作，插入操作对应dp[i][j-1]，删除操作对应dp[i-1][j]，替换操作对应dp[i-1][j-1]，此时的状态方程为dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1。</p><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=word1.length();</span><br><span class="line"><span class="keyword">int</span> n=word2.length();</span><br><span class="line"><span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="comment">//显然需要i次删除操作</span></span><br><span class="line">dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)<span class="comment">//显然需要j次插入操作</span></span><br><span class="line">dp[<span class="number">0</span>][j]=j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//长度比次序大一</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(word1[i]==word2[j])</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]<span class="comment">//字符0对应长度1，类推</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]),dp[i][j])+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 次方取模</title>
      <link href="/2019/04/08/Leetcode-superpow/"/>
      <url>/2019/04/08/Leetcode-superpow/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/super-pow/" target="_blank" rel="noopener">问题</a></h3><p>计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接求a^b然后取模肯定不现实，但可以根据取模公式(a^b)%c=((a%c)^b)%c和(a*b)%c=(a%c*b%c)%c拆分计算，同时利用a^(km+n)=(a^m)^k*a^n公式对b进行逐位求次方。</p><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=b.size();</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> base=a%c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">temp=<span class="built_in">pow</span>(temp,<span class="number">10</span>)%c;</span><br><span class="line">temp=(temp*(<span class="built_in">pow</span>(base,b[i])%c))%c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure><p>优化：pow函数返回值为double，且数据过大时溢出。根据快速幂算法可以进一步拆分。</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpowmod</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n,<span class="keyword">int</span> vmod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> base=x%vmod;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">temp=(temp*base)%vmod;</span><br><span class="line">base=(base*base)%vmod;</span><br><span class="line">n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> base=a%c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.size();i++)<span class="comment">//高位在前</span></span><br><span class="line">&#123;</span><br><span class="line">temp=qpowmod(temp,<span class="number">10</span>,c);</span><br><span class="line">temp=(temp*qpowmod(base,b[i],c))%c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 重复元素III</title>
      <link href="/2019/04/06/Leetcode-KRangeT/"/>
      <url>/2019/04/06/Leetcode-KRangeT/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii" target="_blank" rel="noopener">问题</a></h3><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针：略过。</li><li>Set：维护一个大小为k的set，由于set自动排序的特性，可以找出不小于nums[i]-t的值，然后判断该值是否同时不大于nums[i]+t。</li><li>哈希+桶:将nums元素分散到大小为t+1的桶中，然后以桶id作为键，nums[i]作为值存入hash表，只需要查找nums[i]所在的桶和相邻的两个桶即可。</li></ol><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">1</span> || nums.size()&lt;<span class="number">2</span> || t&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> ps=s.lower_bound(nums[i]-t);<span class="comment">//不小于nums[i]-t</span></span><br><span class="line"><span class="keyword">if</span>(ps!=s.end() &amp;&amp; <span class="built_in">abs</span>((*ps)-nums[i])&lt;=t)<span class="comment">//不大于nums[i]+t</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">s.insert(nums[i]);</span><br><span class="line"><span class="keyword">if</span>(s.size()&gt;k)</span><br><span class="line">s.erase(nums[i-k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="哈希-桶"><a href="#哈希-桶" class="headerlink" title="哈希+桶"></a>哈希+桶</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> s)</span><span class="comment">//计算桶id，除法保证同一桶元素相差[0~s-1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n&lt;<span class="number">0</span>?(n+<span class="number">1</span>)/s<span class="number">-1</span>:n/s;<span class="comment">//eg:[-s+1,-1]/s=0，如果不特殊处理则与[0,s-1]桶id混淆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">1</span> || nums.size()&lt;<span class="number">2</span> || t&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">int</span> sb=t+<span class="number">1</span>;<span class="comment">//桶大小，0~t</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">n=nums[i];</span><br><span class="line">id=getid(n,sb);</span><br><span class="line"><span class="keyword">if</span>(m.count(id))<span class="comment">//同一桶必然满足条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(m.count(id<span class="number">-1</span>) &amp;&amp; n-m[id<span class="number">-1</span>]&lt;=t)<span class="comment">//左</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(m.count(id+<span class="number">1</span>) &amp;&amp; m[id+<span class="number">1</span>]-n&lt;=t)<span class="comment">//右</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">m[id]=n;</span><br><span class="line"><span class="keyword">if</span>(m.size()&gt;k)</span><br><span class="line">m.erase(m.find(getid(nums[i-k],sb)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 重复元素II</title>
      <link href="/2019/04/04/Leetcode-krepeat/"/>
      <url>/2019/04/04/Leetcode-krepeat/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">问题</a></h3><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针：时间复杂度O(kn)，k很大时退化为O(n^2)。</li><li>哈希表：时间复杂度O(n)。</li></ol><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p1=nums.cbegin();p1&lt;nums.end();p1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p2=p1+<span class="number">1</span>;p2&lt;=p1+k &amp;&amp; p2&lt;nums.end();p2++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*p2==*p1)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m.find(nums[i])!=m.end())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">m[nums[i]]=i;</span><br><span class="line"><span class="keyword">if</span>(m.size()&gt;k)</span><br><span class="line">m.erase(nums[i-k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s.find(nums[i])!=s.end())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">s.insert(nums[i]);</span><br><span class="line"><span class="keyword">if</span>(s.size()&gt;k)</span><br><span class="line">s.erase(nums[i-k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 数组等和分割</title>
      <link href="/2019/04/02/Leetcode-CanSum/"/>
      <url>/2019/04/02/Leetcode-CanSum/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">问题</a></h3><p>给定一个只包含<strong>正整数</strong>的<strong>非空</strong>数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>动态规划：数组等和分割，可以拆分成能否从数组中找出和为一半的元素，显然该问题与背包问题极其相似。设dp[i][j]为是否能从数组 <strong>0 ~ i</strong> 号元素中选出和为j。分析不难发现当前数字可以选中或不选，若选中，则结果取决于dp[i-1][j-nums[i]]，若不选，则取决于dp[i-1][j]。得出状态方程dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i]]</li><li>深度优先：每个元素要么选中要么丢弃，展开得到一个二叉树，父节点取决于两个叶子节点的结果。</li></ol><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=sum/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[N][S+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">dp[i][j]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个数(0 ~ 0)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">dp[<span class="number">0</span>][j]=(j==nums[<span class="number">0</span>]) ? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&lt;nums[i]</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j];<span class="comment">//数字超过总和，只能舍弃</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j-nums[i]] || dp[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N<span class="number">-1</span>][S];</span><br></pre></td></tr></table></figure><p>优化：稍作分析可以看出dp[i][j]只取决于dp[i-1][j]和dp[i-1][j-nums[i]]，两者相差一行，后一步dp可以直接覆盖前一步，将二维数组压缩到一维，空间复杂度降为O(S)。进一步分析可以得知，对于本题不要求给出所有可行方案的前提下，如果在前面的规划过程中得到了dp[S]为true的结果，可以直接返回。</p><h4 id="优化DP"><a href="#优化DP" class="headerlink" title="优化DP"></a>优化DP</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=sum/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[S+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//第一个元数(0 ~ 0)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">dp[j]=(j==nums[<span class="number">0</span>]) ? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//第一个元素等于S，满足等和分割，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(dp[s])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=S;j&gt;=nums[i];j--)<span class="comment">//优先规划和为S的情况。j&lt;nums[i]时dp值等于前一步，直接跳过</span></span><br><span class="line">&#123;</span><br><span class="line">dp[j]=dp[j-nums[i]] || d[j];</span><br><span class="line"><span class="keyword">if</span>(j==S &amp;&amp; dp[j])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//已有可行方案，直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[S];</span><br></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> || sum&lt;<span class="number">0</span>)<span class="comment">//边界条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(i<span class="number">-1</span>,sum) || dfs(i<span class="number">-1</span>,sum-nums[i]);<span class="comment">//左右分支</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=sum/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(N<span class="number">-1</span>,S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：如果用两个变量分别记录已选和丢弃元素的和，则可以实现左右剪枝。</p><h4 id="优化DFS-剪枝"><a href="#优化DFS-剪枝" class="headerlink" title="优化DFS - 剪枝"></a>优化DFS - 剪枝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sumL,<span class="keyword">int</span> sumR)</span><span class="comment">//左分支选中，右分支丢弃</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sumL&gt;S || sumR&gt;S || i&lt;<span class="number">0</span>)<span class="comment">//丢弃或已选元素之和超过目标，直接剪枝</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(sumL==S || sumR==S)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(i<span class="number">-1</span>,sumL+nums[i],sumR) || dfs(i<span class="number">-1</span>,sumL,sumR+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S=sum/<span class="number">2</span>;</span><br><span class="line">sort(nums.begin(),nums.end());<span class="comment">//预排序</span></span><br><span class="line"><span class="keyword">if</span>(nums.back()&gt;S)<span class="comment">//最大元素超过目标值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(N<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划 - 背包问题</title>
      <link href="/2019/03/14/DP-zoPack/"/>
      <url>/2019/03/14/DP-zoPack/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。  </p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>类似问题如果用暴力求解时间复杂度将不可接受。分析问题发现，对于选定的物品，其状态只有两种 – 拿走或放弃，这是一个很明显的动态规划问题。设dp[i][j]为<strong>剩余可选</strong>物品数量 i 和<strong>剩余空间</strong> j 时的物品价值，则很显然有状态方程：dp[i][j] = max[dp[i - 1][j], dp[i - 1][j - w[i-1]]+v[i-1]]. 前者对应放弃物品，因此背包剩余容量不变。后者对应拿走物品，背包容量减少，总价值加上选中物品价值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[S+<span class="number">1</span>][P+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pick[S];<span class="comment">//保存选中物品</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)</span><br><span class="line">pick[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= S; i++)</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= P; i++)</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//DP</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= P; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>])<span class="comment">//背包空间不足</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]] + v[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反向查找选中物品</span></span><br><span class="line"><span class="keyword">int</span> j = P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &gt;<span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; dp[i - <span class="number">1</span>][j])</span><br><span class="line">&#123;</span><br><span class="line">pick[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">j -= w[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (j&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点：从剩余物品中取时容易理解成贪心算法，每一步DP实际上是<strong>从第一个物品选到当前物品</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 两数之和</title>
      <link href="/2019/02/28/Leetcode-twoSum/"/>
      <url>/2019/02/28/Leetcode-twoSum/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">问题</a></h3><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。  </p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>先将两数相加，再提取各位数字组成新链表。<br> 优点：代码简单<br> 缺点：无法用于大数计算</p></li><li><p>边遍历边相加，同时构建链表节点。需要考虑进位问题。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">ListNode* L3 = L2;</span><br><span class="line">ListNode* cur=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L2 || L1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L2)</span><br><span class="line">&#123;</span><br><span class="line">cur = L2;<span class="comment">//保存当前位置</span></span><br><span class="line">val = cur-&gt;val + flag;</span><br><span class="line">L2 = L2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;next = L1;<span class="comment">//L2比L1短，直接链接到L1</span></span><br><span class="line">cur = L1;</span><br><span class="line">val = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1)</span><br><span class="line">&#123;</span><br><span class="line">val += L1-&gt;val;</span><br><span class="line">L1 = L1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;val = val % <span class="number">10</span>;</span><br><span class="line">(val &gt; <span class="number">9</span>) ? flag = <span class="number">1</span> : flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1 == <span class="number">0</span> &amp;&amp; L2 == <span class="number">0</span> &amp;&amp; flag == <span class="number">1</span>)</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> L3;</span><br></pre></td></tr></table></figure><h4 id="CSharp"><a href="#CSharp" class="headerlink" title="CSharp"></a>CSharp</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">ListNode L3=L2;</span><br><span class="line">ListNode cur=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>( L2!=<span class="literal">null</span>|| L1!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L2!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = L2;</span><br><span class="line">val = cur.val+flag;</span><br><span class="line">L2 = L2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur.next = L1;</span><br><span class="line">cur = L1;</span><br><span class="line">val = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L1!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">val += L1.val;</span><br><span class="line">L1 = L1.next;</span><br><span class="line">&#125;</span><br><span class="line">cur.val = val % <span class="number">10</span>;</span><br><span class="line">flag = val &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L1 == <span class="literal">null</span> &amp;&amp; L2 == <span class="literal">null</span> &amp;&amp; flag == <span class="number">1</span>)</span><br><span class="line">cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> L3;</span><br></pre></td></tr></table></figure><p>考查点：<strong>单链表</strong>、<strong>大数计算</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++泛型基础 - 模板</title>
      <link href="/2018/12/28/C-Template/"/>
      <url>/2018/12/28/C-Template/</url>
      
        <content type="html"><![CDATA[<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="隐式实例化与显式实例化"><a href="#隐式实例化与显式实例化" class="headerlink" title="隐式实例化与显式实例化"></a>隐式实例化与显式实例化</h3><p>常规的模板函数声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T arg1, T arg2)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>模板实际上并不是一个可以直接调用的函数，只有首次使用函数时，编译器才根据参数类型生成一个对应版本的函数实例，然后调用该函数，这个过程称为隐式实例化。C++ 11新增显式实例化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该语句提示编译器强制生成一个int版本的模板函数实例，而不管接下来有没有用到该版本的函数。显式实例化可以用于模板函数的声明与定义分离，例如在头文件中声明函数模板，在源文件中定义函数体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;arg1, T &amp;arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件 定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;arg1, T &amp;arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arg1=arg1^arg2;</span><br><span class="line">arg2=arg1^arg2;</span><br><span class="line">arg1=arg1^arg2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不包含此显式实例化将产生link_error</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myswap.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">myswap(a,b)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板实现文件中显式具体化后强制生成了对应函数实例，main中调用myswap函数时，编译器虽然无法访问函数定义生成main自己的函数实例，但在链接阶段找到了myswap.obj中签名相符的函数实例，因此链接通过。显式实例化避免了重复实例化，缺点是必须在模板实现文件中实例化所有需要的版本，适用于重载需求较少的模板。</p><h3 id="显式实例化与具体化"><a href="#显式实例化与具体化" class="headerlink" title="显式实例化与具体化"></a>显式实例化与具体化</h3><p>模板只能解决“普遍情况”下的问题，对于特殊参数类型，通用模板就无法工作。为了解决类似的“具体”问题，需要为对应的参数类型实现“具体化”的模板定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">char</span>* <span class="title">add</span><span class="params">(<span class="keyword">char</span>* pc1, <span class="keyword">char</span>* pc2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，具体化的模板优先级高于普通模板。如果在同一编译单元同时存在签名相同的显式实例化与具体化，且<strong>显式实例化在具体化之前</strong>，则会引发重复定义错误，原因是编译器先显式实例化生成了函数实例，但接下来的语句出现了优先级更高的具体化模板，编译器尝试以具体化模板生成函数实例，但已存在相同签名的函数实例，因此引发重复定义错误。反之编译器先以具体化模板为原型生成函数实例，则会跳过优先级较低的显式实例化，编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T arg1, T arg2)</span></span>;</span><br><span class="line"><span class="comment">//a.显式实例化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//b.相同签名的具体化模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//交换ab的次序则编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">add(a,b);<span class="comment">//使用该签名的函数引发重复定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板定义</span></span><br><span class="line"><span class="comment">/*.........</span></span><br></pre></td></tr></table></figure><h3 id="模板调用优先级"><a href="#模板调用优先级" class="headerlink" title="模板调用优先级"></a>模板调用优先级</h3><p>如果同时存在<strong>参数类型匹配</strong>的非模板函数、普通模板、具体化模板，则非模板 &gt;具体化模板 &gt;通用模板，其中具体化模板参数越具体，其优先级越高。调用时也可以强制使用模板函数，此时只考虑模板的优先级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">add(a,b);<span class="comment">//优先调用非模板add(int,int)</span></span><br><span class="line">add&lt;&gt;(a,b);<span class="comment">//强制使用模板，类型自动推断</span></span><br><span class="line">add&lt;<span class="keyword">int</span>&gt;(a,b);<span class="comment">//使用模板，显式指定模板参数类型为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>类模板与函数模板使用方法类似，不过类模板多一个偏特化(或者叫部分具体化)语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化模板，特化为指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>偏特化可以看作是对模板的进一步具体，介于完全具体与完全泛化之间。函数模板没有偏特化语法，因为可以用函数模板重载来实现一样的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非法使用显式模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MyFunc&lt;T*&gt;(T*);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OK，这是另一种具体化语法，可省略&lt;char*&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> MyFunc&lt;<span class="keyword">char</span>*&gt;(<span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OK，构成模板重载</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(T*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐。编译器将它看作显式实例化，忽略&lt;typename T&gt;以及函数定义。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure><p><em>以上代码测试结果均来自VS2013，具体情形以编译器实现为准</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
