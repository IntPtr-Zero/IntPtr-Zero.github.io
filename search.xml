<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++并发编程(1)</title>
      <link href="/2020/03/20/CppConcurrency-01/"/>
      <url>/2020/03/20/CppConcurrency-01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ - 对象模型</title>
      <link href="/2019/10/03/C-InsideOM/"/>
      <url>/2019/10/03/C-InsideOM/</url>
      
        <content type="html"><![CDATA[<h3 id="对象封装"><a href="#对象封装" class="headerlink" title="对象封装"></a>对象封装</h3><p>C++与C语言最大的区别在于C++提供了对抽象数据的封装支持，在C语言中，常见的做法是定义struct，然后使用在struct外部定义的方法操作struct中的数据，这种做法剥离了数据与方法之间的联系，不利于保持程序结构的清晰与一致性。C++将结构体的概念扩展为“对象”，使之支持成员函数与继承。初看起来C++对象的概念比C结构体臃肿，实际上现代编译器采取了一系列优化方式降低封装对内存的额外消耗。</p><a id="more"></a><h3 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><p>在C++对象中有两种成员变量：static和nonstatic以及三种成员函数：static、nonstatic和virtual。对于不同的成员，在内存中的布局形式可以有多种形式，以下举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> m_x,m_y;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_Count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单布局模型：针对对象中的每一个成员，都分配一个指针指向它。这种布局方式的对象大小与成员类型无关，只与成员数量有关，若对象的成员很多，将会消耗大量内存，因此编译器未使用这种布局方式构造对象，但将其使用在成员指针中。<br>表格模型：这种方式将成员变量与成员函数分开安排在两个表，再在对象内部设置两个指针分别指向这两个表。编译器同样未使用这种布局，但将其用在构建虚函数表。<br>C++的对象模型综合了以上两种方案，对于成员变量，将nonstatic直接放置到对象内部(非指针)，static则放置到对象外部。对于成员函数，无论是static还是nonstatic都放在对象外部，对virtual函数则特殊处理：首先将对象的虚函数提取出来构建虚函数表，然后在对象内部放置一个指向虚函数表的指针</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR - 线程同步</title>
      <link href="/2019/09/24/CLR-MTSync/"/>
      <url>/2019/09/24/CLR-MTSync/</url>
      
        <content type="html"><![CDATA[<h3 id="线程同步构造"><a href="#线程同步构造" class="headerlink" title="线程同步构造"></a>线程同步构造</h3><p>线程同步总体上分为两种构造：用户模式和内核模式。其中用户模式基于CPU指令，内核模式则基于操作系统内核对象。由于用户模式构造由硬件支持，且不发生用户-内核状态切换，因此效率较高。但线程使用基于用户模式的同步时，操作系统也无法捕捉到该线程上的阻塞。因此该线程在操作系统看来总是处于非阻塞状态，这意味着线程总是参与抢占时间片，导致线程无谓的浪费CPU时间。与之相对的是内核模式构造，线程使用操作系统提供的内核对象进行同步，每当进入同步块时，代码需要切换到内核态运行，导致巨大的性能损失。但优点是操作系统可以检测到等待同步对象的线程并将其阻塞，当同步对象可用时再唤醒线程。如果拥有“锁”的线程一直不释放，基于用户模式构造的等待线程将一直在CPU上无意义的运行，称之为“活锁”。基于内核模式构造的等待线程则一直被操作系统阻塞，称之为“死锁”。总体来说“死锁”优于“活锁”，因为前者不消耗CPU时间。</p><a id="more"></a><h3 id="用户模式构造"><a href="#用户模式构造" class="headerlink" title="用户模式构造"></a>用户模式构造</h3><p>CLR提供了两种</p>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR - 异步I/O</title>
      <link href="/2019/09/01/CLR-Async/"/>
      <url>/2019/09/01/CLR-Async/</url>
      
        <content type="html"><![CDATA[<h3 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a>同步I/O</h3><p>在Windows系统中，应用程序调用I/O函数发起的操作均发生在用户态，而用户态是无法访问I/O硬件设备的，因此Windows把用户态的I/O操作信息打包发送给内核，此时进入内核态访问对应的I/O设备。I/O设备处理请求的操作时，发起I/O请求的线程将被阻塞，只有当I/O操作完成时，才会重新唤醒线程以返回结果。如果在Socket中使用同步I/O操作，当大量客户端请求连接时，将消耗大量线程，造成性能的急剧下降。</p><a id="more"></a><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>异步I/O与同步I/O不同之处在于，当内核向I/O设备发送请求后，线程将直接返回继续执行其它任务。当设备处理完I/O请求后，Windows将处理结果放入任务队列等待线程处理，对于CLR，则是放入线程池任务队列，等待线程池线程处理。CLR异步I/O实际上是对Windows I/O完成端口的封装。</p><h3 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h3><p>.NET4.5提供了全新的async和await关键字来取代以前的Beginxxx和Endxxx系列异步方法。一个简单的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">1</span>： Console.WriteLine(<span class="string">"@Main=====Before async，线程ID:"</span>+ Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="number">2</span>： Task t = DoWorkAsync();</span><br><span class="line"><span class="number">3</span>:  Console.WriteLine(<span class="string">"@Main=====After async，线程ID:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="number">4</span>:  <span class="keyword">while</span> (!t.IsCompleted)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"@Main=====Waiting completed...，线程ID:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">5</span>:  Console.WriteLine(<span class="string">"@DoWorkAsync=====Before await，线程ID:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="number">6</span>:  <span class="keyword">await</span> Task.Run(() =&gt; &#123; Console.WriteLine(<span class="string">"Doing long-time work，线程ID:"</span> + Thread.CurrentThread.ManagedThreadId); Thread.Sleep(<span class="number">2000</span>); &#125;);</span><br><span class="line"><span class="number">7</span>:  Console.WriteLine(<span class="string">"@DoWorkAsync=====After await，线程ID:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Console.WriteLine(<span class="string">"@DoWorkAsync=====Job Done,线程ID:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">@Main=====Before async，线程ID:1</span></span><br><span class="line"><span class="comment">@DoWorkAsync=====Before await，线程ID:1</span></span><br><span class="line"><span class="comment">Doing long-time work，线程ID:3</span></span><br><span class="line"><span class="comment">@Main=====After async，线程ID:1</span></span><br><span class="line"><span class="comment">@Main=====Waiting completed...，线程ID:1</span></span><br><span class="line"><span class="comment">@Main=====Waiting completed...，线程ID:1</span></span><br><span class="line"><span class="comment">@Main=====Waiting completed...，线程ID:1</span></span><br><span class="line"><span class="comment">@DoWorkAsync=====After await，线程ID:3</span></span><br><span class="line"><span class="comment">@DoWorkAsync=====Job Done,线程ID:3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>很显然async修饰的方法并不是字面意义上的异步方法，而是被内部的await关键字分裂成为两部分。主线程调用DoWorkAsync时会以同步方式执行到await，然后将await修饰的任务交给线程池处理，并立即返回一个与之关联的Task对象。现在主线程继续执行后面的语句，与此同时耗时任务由线程池线程异步执行。等待耗时任务完成之后，线程池线程继续执行await之后的语句，此时DoWorkAsync才真正执行完毕。用序号表示的执行流程图为：</p><p><img src="/images/assets/async.jpg" alt="异步流程"></p><p>对于GUI程序而言，情况又有所不同。异步方法总是会使用GUI线程的SynchronizationContext执行await后续部分(CUI程序的同步上下文为null)，因此上述的After await部分将由主线程执行，如果不慎在主线程中以同步方式等待结果，将造成死锁。例:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyForm</span>:<span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">MyForm()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">string</span> s=GetHttpAsync().Result;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="title">GetHttpAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HttpResponseMessage msg=<span class="keyword">await</span> <span class="keyword">new</span> HttpClient().GetAsync(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"><span class="comment">//===After await===</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span>  msg.Content.ReadAsStringAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GUI线程以同步方式等待Result，此时线程被阻塞。异步执行完HttpClient().GetAsync()后需要主线程接着执行After await部分以返回结果，然而主线程被阻塞，因此造成死锁。注意例子在CUI环境下正常运行。为了防止死锁，.NET提供了Task.ConfigureAwait(bool)方法，传递false时与CUI环境行为一致。</p>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR - Task</title>
      <link href="/2019/08/18/CLR-Task/"/>
      <url>/2019/08/18/CLR-Task/</url>
      
        <content type="html"><![CDATA[<h3 id="使用Task"><a href="#使用Task" class="headerlink" title="使用Task"></a>使用Task</h3><p>使用ThreadPool可以方便的发起异步操作，但却无法知道操作在何时完成，且无法直接获取操作的返回值，为此CLR提供了对线程池的再一次包装，即Task类。Task内部实际上也是使用线程池，只不过封装了一些高级功能。</p><a id="more"></a><p>Task支持直接获取任务执行结果，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="keyword">int</span>&gt; t = <span class="keyword">new</span> Task&lt;<span class="keyword">int</span>&gt;(n=&gt;Sum(<span class="keyword">int</span> n),<span class="number">1000</span>);</span><br><span class="line">t.Start();</span><br><span class="line"><span class="comment">//执行其它操作</span></span><br><span class="line">Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//显式等待Task完成</span></span><br><span class="line"><span class="comment">//t.Wait();</span></span><br><span class="line"><span class="comment">//在需要结果的时候访问结果</span></span><br><span class="line">Console.WriteLine(t.Result);</span><br></pre></td></tr></table></figure><p>无论是等待还是访问结果，都会阻塞当前线程以等待任务运行完毕。如果此时任务还未被调度给线程池线程执行，则可能会直接分配给当前线程以提高性能。</p><p>Task的取消与ThreadPool相似，传递一个CTS即可。不同之处在于Task支持返回结果，因此Task会在取消任务时抛出异常以区别于正常结束任务。为了方便区分，推荐在任务方法中使用CT.ThrowIfCancellationRequested以抛出OperationCanceledException.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">Task t = <span class="keyword">new</span> Task&lt;<span class="keyword">int</span>&gt;(()=&gt;Sum(<span class="number">1000</span>,cts.Token),cts.Token);</span><br><span class="line">t.Start();</span><br><span class="line">Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">cts.Cancel();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(t.Result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AggregateException ex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果是取消产生的异常，则忽略</span></span><br><span class="line">x.Handle(ex=&gt;ex <span class="keyword">is</span> OperationCanceledException;</span><br><span class="line">Console.WriteLine(<span class="string">"操作取消"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Static <span class="keyword">int</span> <span class="title">Sum</span>(<span class="params"><span class="keyword">int</span> n, CancellationToken ct</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查是否已取消并抛出异常</span></span><br><span class="line">ct.ThrowIfCancellationRequested();</span><br><span class="line">sum+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延续任务"><a href="#延续任务" class="headerlink" title="延续任务"></a>延续任务</h3><p>Task支持在任务完成后继续执行其它任务，并可指定延续任务的执行条件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="keyword">int</span>&gt; t = Task.Run(()=&gt;Sum(<span class="number">1000</span>,cts.Token),cts.Token);</span><br><span class="line">t.ContinueWith(task=&gt;Console.WriteLine(task.Result,TaskContinuationOptions);</span><br></pre></td></tr></table></figure><p>其中t作为参数被传递到延续任务中</p><h3 id="父子任务"><a href="#父子任务" class="headerlink" title="父子任务"></a>父子任务</h3><p>可以在一个Task中包含若干个子任务，只有在所有子任务完成后父任务才会被标记为完成状态</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="keyword">int</span>[]&gt; parent=<span class="keyword">new</span> Task&lt;<span class="keyword">int</span>[]&gt;(()=&gt;&#123;</span><br><span class="line"><span class="keyword">var</span> results=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">new</span> Task(()=&gt;results[<span class="number">0</span>]=Sum(<span class="number">1000</span>),TaskCreationOptions.AttachedtoParent).Start();</span><br><span class="line"><span class="keyword">new</span> Task(()=&gt;results[<span class="number">1</span>]=Sum(<span class="number">2000</span>),TaskCreationOptions.AttachedtoParent).Start();</span><br><span class="line"><span class="keyword">new</span> Task(()=&gt;results[<span class="number">2</span>]=Sum(<span class="number">3000</span>),TaskCreationOptions.AttachedtoParent).Start();</span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">&#125;);</span><br><span class="line">parent.Start();</span><br></pre></td></tr></table></figure><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h3><p>Task在内部使用TaskScheduler进行任务调度，CLR内部使用了两个派生类，分别是基于线程池的线程池调度器和基于同步上下文的上下文调度器。<br>线程池调度器是Task的默认调度器，而同步上下文调度器适用于更新GUI的任务，因为.NET禁止从非GUI线程更新界面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class MyForm:Form</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> MyForm</span><br><span class="line">&#123;</span><br><span class="line">Task t=<span class="keyword">new</span> Task(()=&gt;SomeWork())</span><br><span class="line">t.ContinueWith(task =&gt; Text = <span class="string">"任务完成"</span>, CancellationToken.None, TaskContinuationOptions.None, TaskScheduler.FromCurrentSynchronizationContext);</span><br><span class="line">t.Start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR - ThreadPool</title>
      <link href="/2019/08/16/CLR-MT/"/>
      <url>/2019/08/16/CLR-MT/</url>
      
        <content type="html"><![CDATA[<h3 id="CLR线程池"><a href="#CLR线程池" class="headerlink" title="CLR线程池"></a>CLR线程池</h3><p>虽然CLR通过System.Threading名称空间提供了对Windows线程API的封装，但直接创建和销毁线程严重影响性能。过多的线程不仅浪费内存，而且会造成频繁的CPU上下文切换，更重要的是线程大部分时间都处于无所事事的状态，浪费宝贵的CPU时间。其次多线程非常容易引发滥用，特别是那些没什么多线程基础的程序员，为了所谓的“性能”无脑使用线程，即使在一些商业软件中这种现象也比比皆是。为了减少这种现象，CLR提供了原生的线程池支持。对于每个CLR，线程池线程将被所有运行中的托管程序集共享。</p><a id="more"></a><h3 id="线程池调度"><a href="#线程池调度" class="headerlink" title="线程池调度"></a>线程池调度</h3><p>CLR的初始线程池为空，每当托管程序请求使用线程池线程或执行异步任务，CLR会将程序请求的任务添加到线程池的任务记录，并分配给一个线程执行。如果没有可用线程，则创建一个新线程。与直接使用Thread相比，线程池线程完成任务后并不会销毁，而是进入线程池等待新任务。CLR线程池使用启发式的线程分配策略，当有大量任务请求时会创建较多的线程，而空闲时则销毁多余的线程以节省内存。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>CLR中每个线程都与一个执行上下文相关联，其中包括运行权限、用户标识以及区域设置等等信息，每当线程被创建时，会从被创建的线程复制一份执行上下文。对于不需要执行上下文信息的线程来说，这一操作明显影响性能。因此CLR提供了ExecutionContext类来对执行上下文进行控制。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//添加自定义信息到逻辑上下文</span></span><br><span class="line">CallContext.LogicalSetData(<span class="string">"User"</span>,<span class="string">"Admin"</span>);</span><br><span class="line"><span class="comment">//获取上下文信息--打印Admin</span></span><br><span class="line">ThreadingPool.QueueUserWorkItem((state)=&gt;Console.WriteLine(CallContext.LogicalGetData(<span class="string">"User"</span>).ToString()));</span><br><span class="line"><span class="comment">//阻止上下文流动</span></span><br><span class="line">ExecutionContext.SuppressFlow();</span><br><span class="line"><span class="comment">//打印空字符串</span></span><br><span class="line">ThreadingPool.QueueUserWorkItem((state)=&gt;Console.WriteLine(CallContext.LogicalGetData(<span class="string">"User"</span>).ToString()));</span><br><span class="line"><span class="comment">//恢复上下文流动</span></span><br><span class="line">ExecutionContext.RestoreFlow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h3><p>线程池比Thread类更好的一点是支持协作式取消以及任务超时，只需要将一个CancellatinTokenSource对象与任务相关联，即可方便的取消任务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">ThreadPool.QueueUserWorkItem(state=&gt;Count(cts.Token,<span class="number">1000000</span>));</span><br><span class="line">Console.WriteLine(<span class="string">"回车键取消..."</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line">cts.Cancel();</span><br><span class="line"><span class="comment">//超时自动取消</span></span><br><span class="line"><span class="comment">//cts.CancelAfter(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params">CancellationToken token, Int32 count</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=count;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(token.IsCancellationRequested)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"已取消"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(i);</span><br><span class="line">Thread.Sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CancellationTokenSource类"><a href="#CancellationTokenSource类" class="headerlink" title="CancellationTokenSource类"></a>CancellationTokenSource类</h3><p>以下是CTS的.NET源代码节选：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CancellationTokenSource</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//信号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ManualResetEvent m_kernelEvent;</span><br><span class="line"><span class="comment">//一个类似链表的内部类，记录CTS取消时调用的回调函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> SparselyPopulatedArray&lt;CancellationCallbackInfo&gt;[] m_registeredCallbacksLists;</span><br><span class="line"><span class="comment">//CTS状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> CANNOT_BE_CANCELED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NOT_CANCELED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NOTIFYING = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NOTIFYINGCOMPLETE = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> m_state;</span><br><span class="line"><span class="comment">//通过结构体CT暴露方法(轻量化便于传递参数？)</span></span><br><span class="line"><span class="keyword">public</span> CancellationToken token&#123;<span class="keyword">get</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">bool</span> IsCancellationRequested</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>&#123;<span class="keyword">return</span> m_state&gt;=NOTIFING;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WaitHandle是对WaitForSingleObject API函数的包装</span></span><br><span class="line"><span class="keyword">internal</span> WaitHandle WaitHandle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_kernelEvent != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> m_kernelEvent;</span><br><span class="line">                    </span><br><span class="line">        ManualResetEvent mre = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (Interlocked.CompareExchange(<span class="keyword">ref</span> m_kernelEvent, mre, <span class="literal">null</span>) != <span class="literal">null</span>)</span><br><span class="line">        &#123;    </span><br><span class="line">        ((IDisposable)mre).Dispose();</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//取消时将发出信号</span></span><br><span class="line">        <span class="keyword">if</span> (IsCancellationRequested)</span><br><span class="line">        m_kernelEvent.Set();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> m_kernelEvent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cancel</span>(<span class="params"><span class="keyword">bool</span> throwOnFirstException</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ThrowIfDisposed();</span><br><span class="line">NotifyCancellation(throwOnFirstException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NotifyCancellation</span>(<span class="params"><span class="keyword">bool</span> throwOnFirstException</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (IsCancellationRequested)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Interlocked.CompareExchange(<span class="keyword">ref</span> m_state, NOTIFYING, NOT_CANCELED) == NOT_CANCELED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//销毁内部超时计时器</span></span><br><span class="line">Timer timer = m_timer;</span><br><span class="line"><span class="keyword">if</span>(timer != <span class="literal">null</span>) timer.Dispose();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_kernelEvent != <span class="literal">null</span>)</span><br><span class="line">m_kernelEvent.Set();</span><br><span class="line"><span class="comment">//执行注册到CTS的回调函数</span></span><br><span class="line">ExecuteCallbackHandlers(throwOnFirstException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建联合CTS，其中任意CTS取消则该CTS即取消</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CancellationTokenSource <span class="title">CreateLinkedTokenSource</span>(<span class="params">CancellationToken token1, CancellationToken token2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//方法内部调用Register注册回调</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CancellationTokenRegistration <span class="title">Register</span>(<span class="params">Action&lt;Object&gt; callback, Object state, <span class="keyword">bool</span> useSynchronizationContext, <span class="keyword">bool</span> useExecutionContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="comment">//注册到CTS取消时要调用的回调函数</span></span><br><span class="line"><span class="comment">//可调用返回值的Dispose方法取消回调</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轻量化，便于作为参数传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CancellationToken</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对CTS的引用</span></span><br><span class="line"><span class="keyword">private</span> CancellationTokenSource m_source;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">bool</span> IsCancellationRequested</span><br><span class="line">&#123;<span class="keyword">get</span><span class="comment">//暴露CTS的属性&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WaitHandle WaitHandle</span><br><span class="line">&#123;<span class="keyword">get</span><span class="comment">//暴露CTS的WaitHandle&#125;</span></span><br><span class="line"><span class="comment">//暴露CTS方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CancellationTokenRegistration <span class="title">Register</span>(<span class="params">Action callback, <span class="keyword">bool</span> useSyncContext</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL - Deque</title>
      <link href="/2019/07/03/STL-Deque/"/>
      <url>/2019/07/03/STL-Deque/</url>
      
        <content type="html"><![CDATA[<h3 id="双端队列简介"><a href="#双端队列简介" class="headerlink" title="双端队列简介"></a>双端队列简介</h3><p>顾名思义，deque支持在头尾进行插入删除操作。类似于vector和array，deque也是顺序存储结构，没有了解过deque的人在主观上可能会以为deque与vector底层结构类似，实际上为了支持头部插入与删除操作，deque采用<strong>分段连续存储</strong>的数据结构，因此实现上比vector复杂得多。因为采用分段设计，deque的迭代器效率比vector低。<br>为了管理片段，STL的deque在内部定义了一个_Map成员，_Map底层实际是一个T**，也可以将_Map看作一个数组，每一个数组元素指向内存中的一段连续的元素存储空间</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VS2013 deque节选</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Deque_simple_types</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span> _Simple_types&lt;_Ty&gt;</span><br><span class="line">&#123;<span class="comment">// wraps types needed by iterators</span></span><br><span class="line"><span class="keyword">typedef</span> _Ty **_Mapptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_Mapptr _Map;</span><br></pre></td></tr></table></figure><h3 id="双端队列的迭代器"><a href="#双端队列的迭代器" class="headerlink" title="双端队列的迭代器"></a>双端队列的迭代器</h3><p>deque分类上属于顺序存储容器，因此迭代器理所应当提供随机访问迭代器的所有功能。但在内部deque是分段的，因此迭代器需要知道片段的大小以及片段的地址，以在到达片段边缘时跳转到另一个片段。SGI的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr,<span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">deque_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//省略traits定义</span></span><br><span class="line"><span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"><span class="keyword">typedef</span> _deque_iterator self;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个片段的元素容量，如果不指定，默认为512/sizeof(T)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">T*  cur;<span class="comment">//指向片段的当前可插入位置</span></span><br><span class="line">T* first;<span class="comment">//指向片段的头部</span></span><br><span class="line">T* last;<span class="comment">//指向片段的超尾</span></span><br><span class="line">map_pointer node;<span class="comment">//节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点</span></span><br><span class="line">set_node(map_pointer new_node)</span><br><span class="line">&#123;</span><br><span class="line">node=new_node;</span><br><span class="line">first=*new_node;</span><br><span class="line">last=first+difference_type(buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器之间的减法</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(self&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> difference_type(buffer_size())*(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">++cur;</span><br><span class="line"><span class="keyword">if</span>(cur==last)<span class="comment">//到达当前片段超尾</span></span><br><span class="line">&#123;</span><br><span class="line">set_node(node+<span class="number">1</span>);<span class="comment">//跳转到下一片段</span></span><br><span class="line">cur=first;<span class="comment">//指向头部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自减操作类似，略过</span></span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)</span><br><span class="line">&#123;</span><br><span class="line">difference_type offset=n+cur-first;</span><br><span class="line"><span class="comment">//判断是否在同一片段内偏移</span></span><br><span class="line"><span class="keyword">if</span>(offset&gt;=<span class="number">0</span> &amp;&amp; offset&lt;difference_type(buffer_size()))</span><br><span class="line">cur+=n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">difference_type node_offset=offset&gt;<span class="number">0</span> ? offset/difference(buffer_size()):-difference_type((-offset<span class="number">-1</span>)/buffer_size())<span class="number">-1</span>;</span><br><span class="line">set_node(node+node_offset);</span><br><span class="line">cur=first+offset-node_offset*difference_type(buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其它操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双端队列的结构"><a href="#双端队列的结构" class="headerlink" title="双端队列的结构"></a>双端队列的结构</h3><p><img src="/images/assets/deque.jpg" alt="deque结构图"><br>SGI的deque结构如上图所示，其具体实现见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础成员</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=alloc,<span class="keyword">size_t</span> BuffSize=<span class="number">0</span>&gt;</span><br><span class="line">class <span class="built_in">deque</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> _deque_iterator&lt;T,T&amp;,T*,BuffSize&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line">iterator start;<span class="comment">//头部迭代器</span></span><br><span class="line">iterator finish;<span class="comment">//尾部迭代器</span></span><br><span class="line">map_pointer <span class="built_in">map</span>;<span class="comment">//map</span></span><br><span class="line">size_type map_size;<span class="comment">//节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//头部迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line"><span class="comment">//尾部迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首元素</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *start;&#125;</span><br><span class="line"><span class="comment">//尾元素</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iterator tmp=finish;</span><br><span class="line">--tmp;</span><br><span class="line"><span class="keyword">return</span> *tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//略过其它常用接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意deque迭代器取值操作符返回*cur，start迭代器的cur总是指向首元素，finish迭代器的cur指向最后一个元素的下一位，因此需要前移。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> value_type&amp; value):start(),finish(),<span class="built_in">map</span>(<span class="number">0</span>),map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc,<span class="keyword">size_t</span> BuffSize&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n,<span class="keyword">const</span> value_type&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">create_map_and_nodes(n);</span><br><span class="line">map_pointer cur;</span><br><span class="line"><span class="keyword">for</span>(cur=start.node;cur&lt;finish.node;++cur)</span><br><span class="line">uninitialized_fill(*cur,*cur+buffer_size(),value);</span><br><span class="line"><span class="comment">//尾部片段可能还有空闲，因此单独初始化</span></span><br><span class="line">uninitialized_fill(finish.first,finish.cur,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc,<span class="keyword">size_t</span> BuffSize&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_map_and_nodes</span><span class="params">(size_type num_element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//计算初始需要分配的节点数，如果刚好占满n个片段，则额外加一</span></span><br><span class="line">size_type num_nodes=num_element/buffer_size()+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//初始节点数，最少为8。首尾各增加一个以供备用</span></span><br><span class="line">map_size=max(<span class="number">8</span>,num_nodes+<span class="number">2</span>);</span><br><span class="line"><span class="comment">//为map分配内存保存节点</span></span><br><span class="line"><span class="built_in">map</span>=map_allocator::allocate(map_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使初始占用的空间尽量居中，便于首尾插入</span></span><br><span class="line">map_pointer nstart=<span class="built_in">map</span>+(map_size-num_nodes)/<span class="number">2</span>;</span><br><span class="line">map_pointer nfinish=nstart+num_nodes<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">map_pointer cur;</span><br><span class="line"><span class="comment">//为片段分配空间</span></span><br><span class="line"><span class="keyword">for</span>(cur=nstart;cur&lt;=nfinish;++cur)</span><br><span class="line">*cur=allocate_node();</span><br><span class="line"></span><br><span class="line">start.set_node(nstart);</span><br><span class="line">finish.set_node(nfinish);</span><br><span class="line">start.cur=start.first;</span><br><span class="line">finish.cur=finish.first+num_element%buffer_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看deque在内部如何处理元素插入，以push_back为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果尾片段空余空间大于1，则直接赋值</span></span><br><span class="line"><span class="keyword">if</span>(finish.cur != finish.last <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">construct(finish.cur,t);</span><br><span class="line">++finish.cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则新分配一个片段</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">push_back_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back_aux</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value_type t_copy=t;</span><br><span class="line"><span class="comment">//判断是否需要重新分配map</span></span><br><span class="line">reserve_map_at_back();</span><br><span class="line"><span class="comment">//为下一个节点分配一个片段</span></span><br><span class="line">*(finish.node+<span class="number">1</span>)=alocate_node();</span><br><span class="line"><span class="comment">//现在finish所指的片段已满</span></span><br><span class="line">construct(finish.cur,t_copy);</span><br><span class="line"><span class="comment">//尾迭代器指向下一个片段</span></span><br><span class="line">finish.set_node(finish.node+<span class="number">1</span>);</span><br><span class="line">finish.cur=finish.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断尾部是否需要重新分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span><span class="params">(size_type node_to_add=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//尾部备用空间不足</span></span><br><span class="line"><span class="keyword">if</span>(node_to_add&gt;map_size-(finish.node-<span class="built_in">map</span>)<span class="number">-1</span>)</span><br><span class="line"><span class="comment">//false尾部分配</span></span><br><span class="line">reallocate_map(node_to_add,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头部操作类似，略过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reallocate_map</span><span class="params">(size_type node_to_add,<span class="keyword">bool</span> add_at_front)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">size_type old_num_nodes=finish.node-start.node+<span class="number">1</span>;</span><br><span class="line">size_type new_num_nodes=old_num_nodes+node_to_add;</span><br><span class="line">map_pointer new_nstart;</span><br><span class="line"><span class="comment">//对应于一端插入，另一端删除时的极端情况，此时map中只有后半段的节点被利用，不需要重新申请更大的map</span></span><br><span class="line"><span class="keyword">if</span>(map_size&gt;<span class="number">2</span>*new_num_nodes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//重新安排头部节点到中间</span></span><br><span class="line">new_nstart=<span class="built_in">map</span>+(map_size-new_num_nodes)/<span class="number">2</span>+(add_at_front?node_to_add:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(new_nstart&lt;start.node)</span><br><span class="line"><span class="comment">//先序复制防止左边被覆盖</span></span><br><span class="line">copy(start.node,finish.node+<span class="number">1</span>,new_nstart);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//后序复制防止右边被覆盖</span></span><br><span class="line">copy_backward(start.node,finish.node+<span class="number">1</span>,new_nstart+old_num_nodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应正常情况，map中空余节点不足</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">size_type new_map_size=map_size+max(map_size,node_to_add)+<span class="number">2</span>;</span><br><span class="line"><span class="comment">//申请更大的map</span></span><br><span class="line">map_pointer new_map=map_allocator::allocate(new_map_size);</span><br><span class="line"><span class="comment">//开始节点居中</span></span><br><span class="line">new_nstart=new_map+(new_map_size-new_num_nodes)/<span class="number">2</span>+(add_at_front?node_to_add:<span class="number">0</span>);</span><br><span class="line"><span class="comment">//复制原节点</span></span><br><span class="line">copy(start.node,finish.node+<span class="number">1</span>,new_start);</span><br><span class="line"><span class="comment">//释放原map</span></span><br><span class="line">map_allocator::deallocate(<span class="built_in">map</span>,map_size);</span><br><span class="line"><span class="built_in">map</span>=new_map;</span><br><span class="line">map_size=new_map_size;</span><br><span class="line">&#125;</span><br><span class="line">start.set_node(new_nstart);</span><br><span class="line">finish.set_node(new_nstart+old_num_nodes+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是删除操作，SGI的deque在片段中没有元素时会销毁片段以节省内存，具体实现如下，以pop_back为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//尾部片段有元素</span></span><br><span class="line"><span class="keyword">if</span>(finish.cur!=finish.first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意cur指向最后一个元素的下一位</span></span><br><span class="line">--finish.cur;</span><br><span class="line">destroy(finish.cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//没有元素</span></span><br><span class="line">pop_back_aux();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back_aux</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//销毁这个空片段</span></span><br><span class="line">deallocate_node(finish.first);</span><br><span class="line"><span class="comment">//跳转到上一个节点</span></span><br><span class="line">finish.set_node(finish.node<span class="number">-1</span>);</span><br><span class="line">finish.cur=finish.last<span class="number">-1</span>;</span><br><span class="line">destroy(finish.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop_front类似，略过</span></span><br></pre></td></tr></table></figure><p>接下来是clear方法，该方法清除deque所有元素并将deque初始化，SGI的deque在初始状态仍会保留一个片段，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(map_pointer node=start.node+<span class="number">1</span>;node&lt;finish.node;++node)</span><br><span class="line">&#123;<span class="comment">//析构元素</span></span><br><span class="line">destroy(*node,*node+buffer_size());</span><br><span class="line"><span class="comment">//销毁片段</span></span><br><span class="line">deallocate(*node,buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头尾不在同一个片段</span></span><br><span class="line"><span class="keyword">if</span>(start.node!=finish.node)</span><br><span class="line">&#123;</span><br><span class="line">destroy(start.cur,start.last);</span><br><span class="line">destroy(finish.first,finish.cur);</span><br><span class="line"><span class="comment">//仅销毁尾部</span></span><br><span class="line">deallocate(finish.first,buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//仅析构</span></span><br><span class="line">destroy(start.cur,finish.cur);</span><br><span class="line">finish=start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上常见的deque操作都与上面的实现类似，注意map的操作即可。</p><h3 id="MS的deque实现"><a href="#MS的deque实现" class="headerlink" title="MS的deque实现"></a>MS的deque实现</h3><p>MS与SGI的实现有较大区别，首先在deque内部成员上VS2013没有定义start和finish两个迭代器，而是定义了一个_Myoff记录头节点偏移量以及_Mysize记录元素数量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type _Myoff;</span><br><span class="line">size_type _Mysize;</span><br></pre></td></tr></table></figure><p>在内部，deque利用_Myoff计算节点下标来访问节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_type _Getblock(size_type off) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//_DEQUESIZE片段长度，_Mapsize代表map的大小</span></span><br><span class="line"><span class="keyword">return</span> ((off/_DEQUESIZE) &amp; (<span class="keyword">this</span>-&gt;_Mapsize<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，MS的deque采用倍增的扩展策略，即每次重新分配map时大小变为原来的2倍(初始为8，不可自定义)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VS2013</span></span><br><span class="line"><span class="keyword">void</span> _Growmap(size_type _Count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alpty::pointer _Blockptr;</span><br><span class="line">_Alpty _Almap(<span class="keyword">this</span>-&gt;_Getal());</span><br><span class="line">size_type _Newsize = <span class="number">0</span> &lt; <span class="keyword">this</span>-&gt;_Mapsize ? <span class="keyword">this</span>-&gt;_Mapsize : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (_Newsize - <span class="keyword">this</span>-&gt;_Mapsize &lt; _Count || _Newsize &lt; _DEQUEMAPSIZ)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//size加倍</span></span><br><span class="line">_Newsize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算需要新增的节点数量</span></span><br><span class="line">_Count = _Newsize - <span class="keyword">this</span>-&gt;_Mapsize;</span><br><span class="line"><span class="comment">//计算头节点偏移</span></span><br><span class="line">size_type _Myboff = <span class="keyword">this</span>-&gt;_Myoff / _DEQUESIZ;</span><br><span class="line"><span class="comment">//申请新的map</span></span><br><span class="line">_Mapptr _Newmap = _Almap.allocate(<span class="keyword">this</span>-&gt;_Mapsize + _Count);</span><br><span class="line"><span class="comment">//新的头节点</span></span><br><span class="line">_Mapptr _Myptr = _Newmap + _Myboff;</span><br><span class="line"><span class="comment">//复制旧节点</span></span><br><span class="line">_Myptr = _Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map + _Myboff,<span class="keyword">this</span>-&gt;_Map + <span class="keyword">this</span>-&gt;_Mapsize,_Myptr, _Almap);</span><br><span class="line"><span class="comment">//如果新增节点数量大于头节点偏移</span></span><br><span class="line"><span class="keyword">if</span> (_Myboff &lt;= _Count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//复制旧map头节点之前未使用的节点到新map的尾部(意义不明，应该是为了减少初始化次数)</span></span><br><span class="line">_Myptr = _Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map,<span class="keyword">this</span>-&gt;_Map + _Myboff,_Myptr, _Almap);</span><br><span class="line"><span class="comment">//初始化剩余的尾部节点</span></span><br><span class="line">_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,_Almap);</span><br><span class="line"><span class="comment">//初始化头部节点</span></span><br><span class="line">_Uninitialized_default_fill_n(_Newmap, _Myboff, _Almap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//复制旧map头部未使用的节点到新map尾部</span></span><br><span class="line">_Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map,<span class="keyword">this</span>-&gt;_Map + _Count,_Myptr, _Almap);</span><br><span class="line"><span class="comment">//复制剩余的旧map头部到新map头部</span></span><br><span class="line">_Myptr = _Uninitialized_copy(<span class="keyword">this</span>-&gt;_Map + _Count,</span><br><span class="line"><span class="keyword">this</span>-&gt;_Map + _Myboff,_Newmap, _Almap);</span><br><span class="line"><span class="comment">//初始化新map头部未能复制到的节点</span></span><br><span class="line">_Uninitialized_default_fill_n(_Myptr, _Count, _Almap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构旧map元素</span></span><br><span class="line">_Destroy_range(<span class="keyword">this</span>-&gt;_Map + _Myboff, <span class="keyword">this</span>-&gt;_Map + <span class="keyword">this</span>-&gt;_Mapsize, _Almap);</span><br><span class="line"><span class="comment">//释放旧map空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_Map != _Mapptr())</span><br><span class="line">_Almap.deallocate(<span class="keyword">this</span>-&gt;_Map,<span class="keyword">this</span>-&gt;_Mapsize);</span><br><span class="line"><span class="keyword">this</span>-&gt;_Map = _Newmap;<span class="comment">// point at new</span></span><br><span class="line"><span class="keyword">this</span>-&gt;_Mapsize += _Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比起来MS的实现更加复杂化，结构层次也不明显，代码质量明显比SGI差很多。最后再吐槽一下MS神奇的变量命名方式以及各种奇葩#define。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL - 迭代器</title>
      <link href="/2019/06/09/STL-Iterator/"/>
      <url>/2019/06/09/STL-Iterator/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器概念"><a href="#迭代器概念" class="headerlink" title="迭代器概念"></a>迭代器概念</h3><p>STL设计迭代器的初衷就是将容器细节与算法分离，转而用迭代器作为两者的桥梁。迭代器作为一种访问容器的结构，其本质上也是一种对指针的高级包装而已，因此对应于容器的结构特点，迭代器也分为单向迭代器(典型如单链表)、双向迭代器(如双链表)和随机访问迭代器(如vector等顺序存储容器)。</p><a id="more"></a><h3 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h3><p>作为对容器元素指针的高级包装，迭代器不可避免的会暴露容器的实现细节，因此将迭代器完全脱离容器是不现实的，故STL容器都在内部实现了对应于特定容器的迭代器。为了说明迭代器的实现原理，下面以一个自定义的容器类MyList来进行演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MYLIST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MYLIST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T _value;</span><br><span class="line">MyListNode&lt;T&gt;* _next;</span><br><span class="line"></span><br><span class="line">MyListNode():_value(<span class="number">0</span>),_next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListIter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NodeTy* ptr;</span><br><span class="line">MyListIter( NodeTy* p = <span class="literal">nullptr</span>) :ptr(p)&#123;&#125;</span><br><span class="line"></span><br><span class="line">NodeTy&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">NodeTy* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">MyListIter&amp; <span class="keyword">operator</span>++() &#123; ptr = ptr-&gt;_next; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">MyListIter <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; MyListIter tmp = (*<span class="keyword">this</span>); ++(*<span class="keyword">this</span>); <span class="keyword">return</span> tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyListIter&amp; i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr == i.ptr; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> MyListIter&amp; i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr != i.ptr; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MyListNode&lt;T&gt;* _head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_front</span><span class="params">(T v)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">MyListNode&lt;T&gt;* tmp = <span class="keyword">new</span> MyListNode&lt;T&gt;;</span><br><span class="line">tmp-&gt;_value = v;</span><br><span class="line">tmp-&gt;_next = _head-&gt;_next;</span><br><span class="line">_head-&gt;_next=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream&amp; os = <span class="built_in">std</span>::<span class="built_in">cout</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyListNode&lt;T&gt;* tmp = _head-&gt;_next;</span><br><span class="line"><span class="keyword">while</span> (tmp)</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; tmp-&gt;_value&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">tmp = tmp-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyList() </span><br><span class="line">&#123; </span><br><span class="line">_head = <span class="keyword">new</span> MyListNode&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyListIter&lt;MyListNode&lt;T&gt;&gt; begin() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MyListIter&lt;MyListNode&lt;T&gt;&gt;(_head-&gt;_next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyListIter&lt;MyListNode&lt;T&gt;&gt; end() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MyListIter&lt;MyListNode&lt;T&gt;&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy,<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function">IterTy <span class="title">find</span><span class="params">(IterTy begin,IterTy end, Ty value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyList&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)</span><br><span class="line">mylist.insert_front(i);</span><br><span class="line">mylist.display();</span><br><span class="line"><span class="keyword">auto</span> ibegin=mylist.begin();</span><br><span class="line"><span class="keyword">auto</span> iend = mylist.end();</span><br><span class="line"><span class="keyword">auto</span> result = find(ibegin, iend, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result.ptr-&gt;_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy, <span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function">IterTy <span class="title">find</span><span class="params">(IterTy begin, IterTy end, Ty value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (begin != end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (begin-&gt;_value == value)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的简单链表迭代器，我们成功实现了独立于容器的泛型算法find。上述的迭代器仅仅是个雏形，如果一个算法需要一个迭代器类型变量而返回一个迭代器指向的元素类型，在仅使用一个模板参数的情况下，上述迭代器根本不可能做到。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个参数可行</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy,<span class="keyword">typename</span> NodeTy&gt;</span><br><span class="line"><span class="function">NodeTy <span class="title">somefunc</span><span class="params">(IterTy iter,NodeTy el)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NodeTy tmp;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个参数无法完成</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy&gt;</span><br><span class="line">? somefunc(IterTy iter)</span><br><span class="line">&#123;</span><br><span class="line">? tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上以上问题在allocator中已经出现过，STL在allocator中的解决方法是rebind，简单来说就是将可能会用到的类型定义为内嵌类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListIter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> NodeTy value_type;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy&gt;</span><br><span class="line"><span class="keyword">typename</span> IterTy::<span class="function">value_type <span class="title">somefunc</span><span class="params">(IterTy iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//现在仅需要一个模板参数</span></span><br><span class="line"><span class="keyword">typename</span> IterTy::value_type tmp；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而以上技巧仅适用于迭代器类，对于无法定义内嵌类型的原生指针无能为力。泛型算法不应该仅考虑到迭代器，原生指针的行为理应与迭代器类似。</p><h3 id="Traits编程技巧"><a href="#Traits编程技巧" class="headerlink" title="Traits编程技巧"></a>Traits编程技巧</h3><p>Traits直译为“特性，特征”，即人为的赋予对象某些修饰，在需要的时候提取出来。显而易见，traits技术也只能用于类，仍然对原生指针束手无策。为了解决此问题，我们需要对原生指针进行一次包装，而包装方法就是使用模板偏特化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iter_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> IterTy::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针偏特化模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iter_traits</span>&lt;Ty*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Ty value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在无论是原生指针还是迭代器都可以使用iter_traits<t>::value_type获取指向的元素类型。根据编程经验，STL规定迭代器至少定义5种基本特性：value_type、difference_type、pointer、reference和iterator_category</t></p><ol><li>value_type:即迭代器指向的元素类型</li><li>difference_type:迭代器之间的距离</li><li>pointer:指向元素的指针</li><li>reference:元素的引用</li><li>category:迭代器类型</li></ol><p>前面提到迭代器对应于特定容器分为单向迭代器、双向迭代器和随机访问迭代器，功能上还可分为输入迭代器和输出迭代器。很显然不同迭代器可定义的操作和效率是不同的，因此区分迭代器类型有利于提升性能。以advance()函数为例，该函数将一个给定的迭代器移动给定的距离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_fiter</span><span class="params">(ForwardIter&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BidIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_biter</span><span class="params">(BidIter&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(n++)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机访问迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RndIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_rnditer</span><span class="params">(RndIter&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了区分迭代器类型而设计三个函数显然不明智，然而上述函数都是两个模板参数的模板函数，无法重载，因此需要引入另一个不同的参数达成重载条件，STL的做法是引入一个迭代器类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span><span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span><span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span><span class="keyword">public</span> bidirectional)iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIter,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">void</span> _advance(InputIter&amp; i,Distance n,input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//外部接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,Distance n&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(Iterator&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_advance(i,n,iterator_traits&lt;Iterator&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过定义几个用于标识迭代器类型的空类并作为参数启用函数重载，并在外部调用时使用traits技术获取迭代器类型，完成了不同迭代器的函数实现。并且STL迭代器类型是继承关系，利用模板协变，适用于低级迭代器的函数也可用于高级迭代器。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL - 内存分配器</title>
      <link href="/2019/06/01/STL-Allocator/"/>
      <url>/2019/06/01/STL-Allocator/</url>
      
        <content type="html"><![CDATA[<h3 id="标准内存分配器"><a href="#标准内存分配器" class="headerlink" title="标准内存分配器"></a>标准内存分配器</h3><p>定义STL容器时有一个可选参数allocator，缺省情况下使用STL自带的默认allocator类进行内存分配。allocator类在VS2013下由头文件xmemory0定义，间接由memory头文件引用。类声明节选如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Allocator_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocator类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span>:</span><span class="keyword">public</span> _Allocator_base&lt;_Ty&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//STL标准需要的类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> allocator&lt;_Ty&gt; other;</span><br><span class="line"><span class="keyword">typedef</span> _Allocator_base&lt;_Ty&gt; _Mybase;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Mybase::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type *pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *void_pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">void</span> *const_void_pointer;</span><br><span class="line"><span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个空构造函数</span></span><br><span class="line">allocator() &#123;&#125;</span><br><span class="line">allocator(<span class="keyword">const</span> allocator&lt;_Ty&gt;&amp;) &#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Other&gt;</span><br><span class="line">allocator(<span class="keyword">const</span> allocator&lt;_Other&gt;&amp;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rebind</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Other&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> allocator&lt;_Other&gt; other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其它成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中略难理解的是rebind结构，rebind只有一个other成员用来代表allocator&lt;_Other&gt;，这一步貌似有点多余，何不在需要的时候直接声明一个allocator&lt;_Other&gt;类型的分配器呢。STL的allocator是为容器服务的，要弄清楚设计者的目的，需要联系容器的实现。作为普通容器如vector和array等，它们的元素是<strong>直接</strong>存储的，而list等容器有一个中间存储结构node，且node与元素类型是有关的。在分配内存时需要为节点类型node&lt;T&gt;和元素类型T传入对应的allocator，而声明list时只传入了元素类型T，因此需要某种方法根据allocator&lt;T&gt;得到allocator&lt;node&lt;T&gt;&gt;，这时rebind的作用就体现出来了。附VS2013的部分list实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,<span class="title">class</span> _<span class="title">Alloc0</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_base_types</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _Alloc0 _Alloc;</span><br><span class="line"><span class="keyword">typedef</span> _List_base_types&lt;_Ty, _Alloc&gt; _Myt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> _Wrap_alloc&lt;_Alloc&gt; _Alty0;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向底层元素的rebind</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alty0::<span class="keyword">template</span> rebind&lt;_Ty&gt;::other _Alty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Get_voidptr&lt;_Alty, <span class="keyword">typename</span> _Alty::pointer&gt;::type</span><br><span class="line">_Voidptr;</span><br><span class="line"><span class="keyword">typedef</span> _List_node&lt;<span class="keyword">typename</span> _Alty::value_type,</span><br><span class="line">_Voidptr&gt; _Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向节点类型的rebind</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alty::<span class="keyword">template</span> rebind&lt;_Node&gt;::other _Alnod_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Alnod_type::pointer _Nodeptr;</span><br><span class="line"><span class="keyword">typedef</span> _Nodeptr&amp; _Nodepref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rebind算是一种比较巧妙的方法，在元素与中间结构之间创建某种联系，从而达到只需要一个模板参数即可创建多级内存分配器的目的。</p><p>STL标准要求的其它函数接口实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer _Ptr, size_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// deallocate object at _Ptr, ignore size</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(_Ptr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _Count)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// allocate array of _Count elements</span></span><br><span class="line"><span class="keyword">return</span> (_Allocate(_Count, (pointer)<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _Count, <span class="keyword">const</span> <span class="keyword">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// allocate array of _Count elements, ignore hint</span></span><br><span class="line"><span class="keyword">return</span> (allocate(_Count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(_Ty *_Ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// default construct object at _Ptr</span></span><br><span class="line">::<span class="keyword">new</span> ((<span class="keyword">void</span> *)_Ptr) _Ty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(_Ty *_Ptr, <span class="keyword">const</span> _Ty&amp; _Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// construct object at _Ptr with value _Val</span></span><br><span class="line">::<span class="keyword">new</span> ((<span class="keyword">void</span> *)_Ptr) _Ty(_Val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Objty</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">construct</span>(_<span class="title">Objty</span> *_<span class="title">Ptr</span>, _<span class="title">Types</span>&amp;&amp;... _<span class="title">Args</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// construct _Objty(_Types...) at _Ptr</span></span><br><span class="line">::<span class="keyword">new</span> ((<span class="keyword">void</span> *)_Ptr) _Objty(_STD forward&lt;_Types&gt;(_Args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Uty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">destroy</span>(_<span class="title">Uty</span> *_<span class="title">Ptr</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// destroy object at _Ptr</span></span><br><span class="line">_Ptr-&gt;~_Uty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与SGI的二级分配器实现相比更简单，直接调用全局的operator new和delete，没有额外的内存优化。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR - 委托与事件</title>
      <link href="/2019/05/22/CLR-Delegate/"/>
      <url>/2019/05/22/CLR-Delegate/</url>
      
        <content type="html"><![CDATA[<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托实际上可以看作对C++函数指针的高级封装，只不过委托提供了编译时的类型安全。CLR的委托本质上是一个类，对委托的声明会被编译器翻译为一个继承自MulticastDelegate的派生类，代码如下:</p><a id="more"></a><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyCallback</span>(<span class="params">Int32 v</span>)</span>;</span><br></pre></td></tr></table></figure><p>编译器实际上为上述语句生成如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyCallback:System.MulticastDelegate</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCallback</span>(<span class="params">Object obj, IntPtr method</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params">Int32 v</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IAsyncResult <span class="title">BeginInvoke</span>(<span class="params">Int32 v, AsyncCallback callback, Object obj</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndInvoke</span>(<span class="params">IAsyncResult result</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MulticastDelegate类有三个重要的字段：  </p><ol><li>_target：对象实例。回调静态方法时为null</li><li>_methodPtr：方法指针</li><li>_invocationList：委托链，单播委托为null</li></ol><p>例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params">Int32 v</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(v.ToString);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a=<span class="keyword">new</span> A;</span><br><span class="line">MyCallback mcb=<span class="keyword">new</span> MyCallback(a.Show);</span><br><span class="line">mcb(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:3</span></span><br></pre></td></tr></table></figure><p>在上述代码中_target=a，_methodPtr指向Show方法。代码中mcb(3)语句实际上是个语法糖，编译器在底层将它翻译为mcb.Invoke(3)，Invoke方法使用_target与_methodPtr共同确定要调用的方法。</p><h3 id="委托链"><a href="#委托链" class="headerlink" title="委托链"></a>委托链</h3><p>由基类MulticastDelegate的名称很容易看出支持多个委托回调。多播委托与单播委托略有区别，由于需要保存多个回调，_target和_methodPtr显然是不够用的，因此需要使用_invocationList字段。_invocationList实际上是一个委托对象集合，每次使用Delegate.Combine方法添加委托时，方法检查被合并的委托是否为null，如果为null，则直接返回原委托，否则将构建一个新的委托对象。多播委托与单播委托使用方法一样，调用Invoke方法时，依次对每一个委托数组元素调用Invoke，因此如果委托具有返回值，将只返回最后一个执行的回调函数的返回值。Invoke方法的实现大致如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params">Int32 v</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Delegate[] delegateArray = _invocationList <span class="keyword">as</span> Delagate[]</span><br><span class="line"><span class="keyword">if</span>(delegateArray != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//多播委托依次调用每一个回调方法</span></span><br><span class="line"><span class="keyword">foreach</span>(MyCallback del <span class="keyword">in</span> delgateArray)</span><br><span class="line">del.Invoke(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//单播委托直接调用回调方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以添加委托，还可以使用Delegate.Remove方法删除委托，方法查找源委托链中与目标委托签名一致的委托对象，并删除第一个匹配项。如果删除后委托链为空，则返回null。</p><h3 id="异步委托"><a href="#异步委托" class="headerlink" title="异步委托"></a>异步委托</h3><p>为了便于执行耗时较长的回调，委托类提供了BeginInvoke()方法用于异步执行，其底层实现是将回调交给线程池处理。BeginInvoke接受两个额外的参数：在异步委托完成时执行的AsyncCallback类型的回调和一个用于标识的Object参数，其返回值是一个IAsyncResult类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IAsyncResult</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//BeginInvoke的object参数将传递给该属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> AsyncState&#123;<span class="keyword">get</span>&#125;;</span><br><span class="line"><span class="comment">//内核对象，异步完成时会收到信号</span></span><br><span class="line"><span class="keyword">public</span> WaitHandle AsyncWaitHandle&#123;<span class="keyword">get</span>&#125;;</span><br><span class="line"><span class="comment">//是否是同步完成的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">bool</span> CompletedSynchronously &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"><span class="comment">//是否已执行完毕</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">bool</span> IsCompleted &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeginInvoke必须用配对的EndInvoke结束异步操作，并返回异步操作的返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> Func&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; MyAsyncWork = DoWork;</span><br><span class="line"><span class="keyword">static</span> AsyncCallback MyAsyncCallback = AfterWork;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IAsyncResult ar = MyAsyncWork.BeginInvoke(<span class="number">100</span>,MyAsyncCallback,<span class="string">"任意自定义数据"</span>);</span><br><span class="line"><span class="comment">//主线程结束后将看不到执行结果</span></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">DoWork</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AfterWork</span>(<span class="params">IAsyncResult ar</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"异步执行完毕"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"结果是："</span> + MyAsyncWork.EndInvoke(ar));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AsyncCallback的内部定义</span></span><br><span class="line"><span class="comment">//delegate void AsyncCallback(IAsyncResult);</span></span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件实际上也是基于委托的。定义事件的一般步骤如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义事件参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MailEventArgs</span>: <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mFrom;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mTo;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mContent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> From&#123;<span class="keyword">get</span>&#123;<span class="keyword">return</span> mFrom;&#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> To&#123;<span class="keyword">get</span>&#123;<span class="keyword">return</span> mTo;&#125;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Content&#123;<span class="keyword">get</span>&#123;<span class="keyword">return</span> mContent;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MailEventArgs</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">from</span>,<span class="keyword">string</span> to,<span class="keyword">string</span> content</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mFrom=<span class="keyword">from</span>; mTo=to; mContent=content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MailBox</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;MailEventArgs&gt; MailEvent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNewMail</span>(<span class="params">Object sender,MailEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EventHandler&lt;MailEventArgs&gt; temp=Volatile.Read(<span class="keyword">ref</span> MailEvent);</span><br><span class="line"><span class="keyword">if</span>(temp!=<span class="literal">null</span>) temp(sender,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NewMail</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">from</span>,<span class="keyword">string</span> to,<span class="keyword">string</span> content</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MailEventArgs e=<span class="keyword">new</span> MailEventArgs(<span class="keyword">from</span>,to,content);</span><br><span class="line">OnNewMail(<span class="keyword">this</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MailBox mb=<span class="keyword">new</span> MailBox();</span><br><span class="line">mb.MailEvent+=MyMailEvent_Handler;</span><br><span class="line">mb.NewMail(<span class="string">"C#"</span>,<span class="string">"You"</span>,<span class="string">"HelloWorld"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMailEvent_Handler</span>(<span class="params">Object sender,MailEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"收到新消息"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"From "</span>+e.From+<span class="string">" To "</span>+e.To+NewLine+e.Content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于下面这一事件定义</span></span><br><span class="line"><span class="comment">public event EventHandler&lt;MailEventArgs&gt; MailEvent;</span></span><br><span class="line"><span class="comment">编译器实际上产生以下代码</span></span><br><span class="line"><span class="comment">private EventHandler&lt;MailEventArgs&gt; MailEvent;</span></span><br><span class="line"><span class="comment">public void add_MailEvent(EventHandler&lt;MailEventArgs&gt; value)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">//注册事件回调时内部调用该方法</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">public void remove_MailEvent(EventHandler&lt;MailEventArgs&gt; value)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">//移除事件回调时内部调用该方法</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="内存优化的自定义事件"><a href="#内存优化的自定义事件" class="headerlink" title="内存优化的自定义事件"></a>内存优化的自定义事件</h3><p>不管是否订阅了事件，每个事件声明都会<strong>至少</strong>占用4个字节的内存，对于定义了大量事件的类–比如Windows控件，造成的内存浪费将非常可观。为了节省内存空间，CLR提供了EventHandlerList类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//C#</span><br><span class="line">private EventHandlerList Events=new EventHandlerList();</span><br><span class="line">//key可以是任意对象，只需要每种事件不同即可</span><br><span class="line">public event EventHandler Click</span><br><span class="line">&#123;</span><br><span class="line">add</span><br><span class="line">&#123;</span><br><span class="line">Events.AddHandler(key1,value);</span><br><span class="line">&#125;</span><br><span class="line">remove</span><br><span class="line">&#123;</span><br><span class="line">Events.RemoveHandler(key1,value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public event EventHandler KeyDown</span><br><span class="line">&#123;</span><br><span class="line">add</span><br><span class="line">&#123;</span><br><span class="line">Events.AddHandler(key2,value);</span><br><span class="line">&#125;</span><br><span class="line">remove</span><br><span class="line">&#123;</span><br><span class="line">Events.RemoveHandler(key2,value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected virtual void OnClick(Object sender,EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">EventHandler temp=(EventHandler)Events[key];</span><br><span class="line">temp(sender,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//VB.NET更加简化的Custom关键字</span><br><span class="line">Private Events As New EventHandlerList</span><br><span class="line"></span><br><span class="line">Public Custom Event Click As EventHandler</span><br><span class="line">    AddHandler(ByVal value As EventHandler)</span><br><span class="line">        Events.AddHandler(key1, value)</span><br><span class="line">    End AddHandler</span><br><span class="line">    RemoveHandler(ByVal value As EventHandler)</span><br><span class="line">        Events.RemoveHandler(key1, value)</span><br><span class="line">    End RemoveHandler</span><br><span class="line">    RaiseEvent(ByVal sender As Object, ByVal e As EventArgs)</span><br><span class="line">        CType(Events(key1), EventHandler).Invoke(sender, e)</span><br><span class="line">    End RaiseEvent</span><br><span class="line">End Event</span><br><span class="line"></span><br><span class="line">Public Custom Event KeyDown As EventHandler</span><br><span class="line">    AddHandler(ByVal value As EventHandler)</span><br><span class="line">        Events.AddHandler(key2, value)</span><br><span class="line">    End AddHandler</span><br><span class="line">    RemoveHandler(ByVal value As EventHandler)</span><br><span class="line">        Events.RemoveHandler(key2, value)</span><br><span class="line">    End RemoveHandler</span><br><span class="line">    RaiseEvent(ByVal sender As Object, ByVal e As EventArgs)</span><br><span class="line">        CType(Events(key2), EventHandler).Invoke(sender, e)</span><br><span class="line">    End RaiseEvent</span><br><span class="line">End Event</span><br></pre></td></tr></table></figure><p>EventHandlerList类底层实现基于字典或者哈希表，因此当事件项数量过多时可能会有查找性能问题。</p>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与多态 - 继承</title>
      <link href="/2019/05/18/Class-Func/"/>
      <url>/2019/05/18/Class-Func/</url>
      
        <content type="html"><![CDATA[<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p>C++支持三种不同的继承方式：private、protected和public，继承方式只影响派生类外部对基类成员的访问权限，而不影响派生类在内部对基类成员的访问权限。私有继承意味着所有基类成员将被继承为派生类的私有成员；保护继承意味着基类所有public成员被继承为protected，其它成员不受影响；公有继承则保持基类成员的原有访问控制不变。例子：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _ID;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* _Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;_ID&lt;&lt;<span class="string">": "</span>&lt;&lt;_Name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//内部访问权限不受影响，可访问基类protected和public成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;<span class="comment">//protected Base::name</span></span><br><span class="line">show();<span class="comment">//public Base::show()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承同上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span>:</span> <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;</span><br><span class="line">show();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child3</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;</span><br><span class="line">show();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Child1已将基类成员继承为private，CChild1显然不可访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CChild1</span>:</span> <span class="keyword">public</span> Child1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;<span class="comment">//不可访问:private Child1::name</span></span><br><span class="line">show();<span class="comment">//不可访问:private Child1::show()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Child2是保护继承，基类非private成员均被继承为protected，CChild2显然可以访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CChild2</span>:</span> <span class="keyword">public</span> Child2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name=<span class="string">""</span>;<span class="comment">//OK:protected Child2::name</span></span><br><span class="line">show();<span class="comment">//OK:protected Child2::show()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child1 c1;</span><br><span class="line">Child2 c2;</span><br><span class="line">c1.show();<span class="comment">//不可访问</span></span><br><span class="line">c2.show();<span class="comment">//不可访问</span></span><br></pre></td></tr></table></figure><h3 id="C-中的方法重写"><a href="#C-中的方法重写" class="headerlink" title="C++中的方法重写"></a>C++中的方法重写</h3><p>解释方法重写前需要弄明白函数重载与方法重写的概念。函数重载发生在同一类作用域，而方法重写发生在类继承中，即使子类用不同的参数列表重写父类方法，他也不是重载，而是重写，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"base"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child c;</span><br><span class="line">c.show();<span class="comment">//Error</span></span><br><span class="line">c.show(<span class="number">0</span>);<span class="comment">//OK</span></span><br></pre></td></tr></table></figure><p>发生重写时，函数的父类版本将被子类隐藏。</p><p>派生类重写基类虚方法时，要求子类保持方法签名一致，否则将变成上面的普通方法重写，子类将隐藏父类虚方法。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"base"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//签名不一致，隐藏父类show()方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写并重载</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child1"</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"child1 virtual"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Child c;</span><br><span class="line">c.show();<span class="comment">//Error.</span></span><br><span class="line">Child1 c1;</span><br><span class="line">c1.show();<span class="comment">//OK.调用Child1::show()</span></span><br><span class="line">c1.show(<span class="number">0</span>);<span class="comment">//OK.调用Child1::show(int)</span></span><br></pre></td></tr></table></figure><h3 id="NET中的函数重写"><a href="#NET中的函数重写" class="headerlink" title=".NET中的函数重写"></a>.NET中的函数重写</h3><p>当子类保持函数签名一致时，对于普通方法重写，需要显式指定new(<del>Shadows</del>)关键字；对于虚方法，需要显式指定override关键字</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BaseCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"Base"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚方法重写(省略override则默认为new)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ChildCls</span>:<span class="title">BaseCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"Child"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通重写(new可省略)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">BadChildCls</span>:<span class="title">BaseCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> new <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"BadChild"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseCls a,b;</span><br><span class="line">a=<span class="keyword">new</span> ChildCls();</span><br><span class="line">b=<span class="keyword">new</span> BadChildCls();</span><br><span class="line">a.show();</span><br><span class="line">b.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">Child</span></span><br><span class="line"><span class="comment">Base</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>当子类方法与父类函数签名不一致时，.NET将其视为重写+重载，而不是像C++一样简单的隐藏父类方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//VB.NET</span><br><span class="line"><span class="keyword">Class</span> BaseCls</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overridable</span> <span class="keyword">Sub</span> Show()</span><br><span class="line">Console.WriteLine(<span class="string">"base"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> Child:<span class="keyword">Inherits</span> BaseCls</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overloads</span> <span class="keyword">Sub</span> Show(<span class="keyword">Byval</span> i <span class="keyword">as</span> Int32)</span><br><span class="line">Console.WriteLine(<span class="string">"child"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> c <span class="keyword">as</span> <span class="keyword">New</span> Child</span><br><span class="line">c.Show(0)//OK</span><br><span class="line">c.Show()//OK</span><br><span class="line"></span><br><span class="line">//C#</span><br><span class="line"><span class="keyword">class</span> BaseCls</span><br><span class="line">&#123;</span><br><span class="line">public virtual void Show() &#123;Console.WriteLine("base");&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child: BaseCls</span><br><span class="line">&#123;</span><br><span class="line">public void Show(int i) &#123;Console.WriteLine("child");&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child c = <span class="keyword">new</span> Child();</span><br><span class="line">c.Show();//OK</span><br><span class="line">c.Show(0);//OK</span><br></pre></td></tr></table></figure><p>上述代码实际上可以拆分为：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> Child:<span class="keyword">Inherits</span> BaseCls</span><br><span class="line">//方法重写</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overrides</span> <span class="keyword">Sub</span> Show()</span><br><span class="line"><span class="keyword">MyBase</span>.Show()</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line">//函数重载</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Overloads</span> <span class="keyword">Sub</span> Show(<span class="keyword">Byval</span> i <span class="keyword">as</span> Int32)</span><br><span class="line">Console.WriteLine(<span class="string">"child"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br></pre></td></tr></table></figure><p>不过两者略有区别，通过查看生成的IL代码，第一种写法中Child只有Show(Int32)方法，对Show()的调用直接编译为MyBase.Show()，但使用反射仍然可以获取Child.Show()方法。</p>]]></content>
      
      
      <categories>
          
          <category> 类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR - 内存管理与垃圾回收</title>
      <link href="/2019/05/12/CLR-GC/"/>
      <url>/2019/05/12/CLR-GC/</url>
      
        <content type="html"><![CDATA[<h3 id="CLR内存分配"><a href="#CLR内存分配" class="headerlink" title="CLR内存分配"></a>CLR内存分配</h3><p>无论是C#、VB.NET或是Java，这些所谓的高级编程语言实际上都致力于解决C++中常见的内存泄露问题，方法很简单 – 那就是剥夺程序员对于物理内存空间的直接控制权，重新虚拟一层“可控”的内存空间，并由框架(.NET的CLR以及Java的JVM)自行处理内存问题。这样虽然牺牲了一点点性能以及少许灵活性，但大大提高了安全性，更不用说框架封装所带来的便利。</p><a id="more"></a><p>类似于C++，CLR中动态分配的内存存在于一个叫做“托管堆”的地方。程序集初始化时，CLR在物理内存中划出一块作为进程的托管堆，托管堆类似于数据结构中的栈，它维护一个指针，指向下一块可被分配的内存。当使用new操作符声明新对象时，CLR首先计算对象的字节大小，然后再加上一个对象类型指针和一个同步块索引，然后检查托管堆是否拥有足够的可用空间，如果空间足够，则托管堆内部指针向后移动相应距离。</p><h3 id="CLR垃圾回收"><a href="#CLR垃圾回收" class="headerlink" title="CLR垃圾回收"></a>CLR垃圾回收</h3><p>托管堆内存不足以分配新对象时(或主动调用GC)，CLR便会发起垃圾回收。垃圾回收有许多不同的实现方法，例如COM中采用的引用计数，但引用计数无法处理循环引用的问题，即对象AB互相引用，则引用计数永远不可能为0，从而引发内存泄漏。<br>.NET和Java都采用引用跟踪算法，即将对象变量看作“根”。在垃圾回收时CLR挂起整个线程以防止垃圾回收过程中的状态变化，CLR先将托管堆中所有对象标记为垃圾(将同步索引的某一位置为0)，然后以变量为根，向下搜索变量引用的对象和对象的成员所引用的对象，如果变量非NULL，则引用的对象被标记为非垃圾，如果对象已被标记为非垃圾，cLR跳过检查该对象的成员字段，防止循环引用造成的死循环。<br>标记完成后，CLR将所有非垃圾对象整合到一段连续的内存空间并移动内部指针，这样可以解决传统C++中的内存碎片化问题。但整合内存意味着对象的地址发生变化，因此垃圾清理后必须恢复变量指向的对象的地址。</p><h3 id="GC的性能优化"><a href="#GC的性能优化" class="headerlink" title="GC的性能优化"></a>GC的性能优化</h3><p>如果每次都检查并移动托管堆中的所有对象，那么会造成比较大的性能开销，因此.NET和Java都采用了基于“代”的回收机制。“分代”的原理很简单，如果某对象经过一次垃圾回收后仍存活，则代数提高一代，而垃圾回收时优先回收第0代，理由是活的越久的对象越有可能继续存活，因此优先回收第0代有更大可能回收更多的空间。<br>CLR将托管堆对象分为0、1、2三代，CLR对三块内存空间采取了动态负载的方案。垃圾回收时，如果第0代大部分对象都是垃圾，此时垃圾回收的代价很小(仅需要复制少量内存块以及修改少许指针)，CLR会相对分配较少的空间给第0代；反之，CLR分配较大的内存空间，以减少垃圾回收的次数。此策略也适用于1、2代。</p><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>CLR将对象分为大对象和小对象，大对象是大小超过85000字节左右的对象，大对象与小对象并不在同一内存空间分配，且初始即为第2代，因为在内存中移动大对象的代价过高。</p><h3 id="Finalize与Dispose"><a href="#Finalize与Dispose" class="headerlink" title="Finalize与Dispose"></a>Finalize与Dispose</h3><p>当程序集调用非托管的本机资源对象(如File或Mutex)时，CLR只能回收托管内存，造成本机内存的泄露。因此CLR为封装的本机资源对象设计了Finalize方法，拥有该方法的对象在GC执行之后才会被CLR调用该方法，如果方法内有访问对象字段的代码，则此对象的内存并不能立即被回收，这导致对象活得更久，增加了内存消耗。Finalize被设计为<strong>只能由CLR调用</strong>，托管内存由CLR负责清理，因此Finalize负责清理非托管资源，例如文件句柄。<br>然而Finalize只有当对象被标记为垃圾且在GC执行后才可能被调用，并且调用时间无法确定，因此有必要设计另一种由开发者精确控制的清理机制，对此CLR设计了IDisposeable接口，接口暴露Dispose方法，实现接口的对象可以由开发者主动调用Dispose方法立即执行非托管资源的清理。实现如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DisposablClass</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//标记是否已回收</span></span><br><span class="line">    <span class="keyword">bool</span> disposed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dispose(<span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>); <span class="comment">//移除Finalize调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~DisposableClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(disposed) <span class="keyword">return</span>; <span class="comment">//防止多次执行</span></span><br><span class="line">        <span class="keyword">if</span>(disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span>释放本对象的托管资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span>释放非托管资源</span></span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部的Dispose(bool)参数用来标识被Dispose还是Finalize调用，如果是Dispose，则需要自己清理托管资源，同时移除GC对本对象的Finalize调用。如果是Finalize，则托管资源已由GC处理，只需要清理非托管资源。<br>调用非托管资源的对象类设计原则：如果类实现了Finalize，则也应实现可控的Dispose方法，并在方法中移除GC对Finalize的调用；反之，实现了Dispose方法也应实现Finalize，以防止开发者忘记调用Dispose。</p>]]></content>
      
      
      <categories>
          
          <category> .NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 字符串转换</title>
      <link href="/2019/04/12/Leetcode-stredis/"/>
      <url>/2019/04/12/Leetcode-stredis/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">问题</a></h3><p>给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对字符使用插入、删除与替换。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于类似第一时间想不出解法的问题，首先考虑动态规划。设dp[i][j]代表从长度i的字符串转换为长度j的字符串需要的最少操作数，若word1[i-1]==word2[j-1]，则显然最后一个字符无需任何操作，因此dp[i][j]=dp[i-1][j-1]。若word1[i-1]!=word2[j-1]，则最后一位字符需要一次操作，插入操作对应dp[i][j-1]，删除操作对应dp[i-1][j]，替换操作对应dp[i-1][j-1]，此时的状态方程为dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1。</p><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=word1.length();</span><br><span class="line"><span class="keyword">int</span> n=word2.length();</span><br><span class="line"><span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="comment">//显然需要i次删除操作</span></span><br><span class="line">dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)<span class="comment">//显然需要j次插入操作</span></span><br><span class="line">dp[<span class="number">0</span>][j]=j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//长度比次序大一</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(word1[i]==word2[j])</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]<span class="comment">//字符0对应长度1，类推</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]),dp[i][j])+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 次方取模</title>
      <link href="/2019/04/08/Leetcode-superpow/"/>
      <url>/2019/04/08/Leetcode-superpow/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/super-pow/" target="_blank" rel="noopener">问题</a></h3><p>计算 a^b 对正整数 c 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接求a^b然后取模肯定不现实，但可以根据取模公式(a^b)%c=((a%c)^b)%c和(a*b)%c=(a%c*b%c)%c拆分计算，同时利用a^(km+n)=(a^m)^k*a^n公式对b进行逐位求次方。</p><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=b.size();</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> base=a%c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">temp=<span class="built_in">pow</span>(temp,<span class="number">10</span>)%c;</span><br><span class="line">temp=(temp*(<span class="built_in">pow</span>(base,b[i])%c))%c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure><p>优化：pow函数返回值为double，且数据过大时溢出。根据快速幂算法可以进一步拆分。</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpowmod</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n,<span class="keyword">int</span> vmod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> base=x%vmod;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">temp=(temp*base)%vmod;</span><br><span class="line">base=(base*base)%vmod;</span><br><span class="line">n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> base=a%c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.size();i++)<span class="comment">//高位在前</span></span><br><span class="line">&#123;</span><br><span class="line">temp=qpowmod(temp,<span class="number">10</span>,c);</span><br><span class="line">temp=(temp*qpowmod(base,b[i],c))%c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 重复元素III</title>
      <link href="/2019/04/06/Leetcode-KRangeT/"/>
      <url>/2019/04/06/Leetcode-KRangeT/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii" target="_blank" rel="noopener">问题</a></h3><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针：略过。</li><li>Set：维护一个大小为k的set，由于set自动排序的特性，可以找出不小于nums[i]-t的值，然后判断该值是否同时不大于nums[i]+t。</li><li>哈希+桶:将nums元素分散到大小为t+1的桶中，然后以桶id作为键，nums[i]作为值存入hash表，只需要查找nums[i]所在的桶和相邻的两个桶即可。</li></ol><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">1</span> || nums.size()&lt;<span class="number">2</span> || t&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> ps=s.lower_bound(nums[i]-t);<span class="comment">//不小于nums[i]-t</span></span><br><span class="line"><span class="keyword">if</span>(ps!=s.end() &amp;&amp; <span class="built_in">abs</span>((*ps)-nums[i])&lt;=t)<span class="comment">//不大于nums[i]+t</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">s.insert(nums[i]);</span><br><span class="line"><span class="keyword">if</span>(s.size()&gt;k)</span><br><span class="line">s.erase(nums[i-k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="哈希-桶"><a href="#哈希-桶" class="headerlink" title="哈希+桶"></a>哈希+桶</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> s)</span><span class="comment">//计算桶id，除法保证同一桶元素相差[0~s-1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n&lt;<span class="number">0</span>?(n+<span class="number">1</span>)/s<span class="number">-1</span>:n/s;<span class="comment">//eg:[-s+1,-1]/s=0，如果不特殊处理则与[0,s-1]桶id混淆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">1</span> || nums.size()&lt;<span class="number">2</span> || t&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">int</span> sb=t+<span class="number">1</span>;<span class="comment">//桶大小，0~t</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">n=nums[i];</span><br><span class="line">id=getid(n,sb);</span><br><span class="line"><span class="keyword">if</span>(m.count(id))<span class="comment">//同一桶必然满足条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(m.count(id<span class="number">-1</span>) &amp;&amp; n-m[id<span class="number">-1</span>]&lt;=t)<span class="comment">//左</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(m.count(id+<span class="number">1</span>) &amp;&amp; m[id+<span class="number">1</span>]-n&lt;=t)<span class="comment">//右</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">m[id]=n;</span><br><span class="line"><span class="keyword">if</span>(m.size()&gt;k)</span><br><span class="line">m.erase(m.find(getid(nums[i-k],sb)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 重复元素II</title>
      <link href="/2019/04/04/Leetcode-krepeat/"/>
      <url>/2019/04/04/Leetcode-krepeat/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">问题</a></h3><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j] 并且 i 和 j 的差的绝对值最大为 k。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针：时间复杂度O(kn)，k很大时退化为O(n^2)。</li><li>哈希表：时间复杂度O(n)。</li></ol><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p1=nums.cbegin();p1&lt;nums.end();p1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p2=p1+<span class="number">1</span>;p2&lt;=p1+k &amp;&amp; p2&lt;nums.end();p2++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*p2==*p1)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m.find(nums[i])!=m.end())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">m[nums[i]]=i;</span><br><span class="line"><span class="keyword">if</span>(m.size()&gt;k)</span><br><span class="line">m.erase(nums[i-k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s.find(nums[i])!=s.end())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">s.insert(nums[i]);</span><br><span class="line"><span class="keyword">if</span>(s.size()&gt;k)</span><br><span class="line">s.erase(nums[i-k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 数组等和分割</title>
      <link href="/2019/04/02/Leetcode-CanSum/"/>
      <url>/2019/04/02/Leetcode-CanSum/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">问题</a></h3><p>给定一个只包含<strong>正整数</strong>的<strong>非空</strong>数组。求是否可以将这个数组分割成两个子集，使得两个子集的元素和相等，数组由 nums 给出，返回bool。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>动态规划：数组等和分割，可以拆分成能否从数组中找出和为一半的元素，显然该问题与背包问题极其相似。设dp[i][j]为是否能从数组 <strong>0 ~ i</strong> 号元素中选出和为j。分析不难发现当前数字可以选中或不选，若选中，则结果取决于dp[i-1][j-nums[i]]，若不选，则取决于dp[i-1][j]。得出状态方程dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i]]</li><li>深度优先：每个元素要么选中要么丢弃，展开得到一个二叉树，父节点取决于两个叶子节点的结果。</li></ol><h3 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h3><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=sum/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[N][S+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">dp[i][j]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个数(0 ~ 0)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">dp[<span class="number">0</span>][j]=(j==nums[<span class="number">0</span>]) ? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&lt;nums[i]</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j];<span class="comment">//数字超过总和，只能舍弃</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j-nums[i]] || dp[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N<span class="number">-1</span>][S];</span><br></pre></td></tr></table></figure><p>优化：稍作分析可以看出dp[i][j]只取决于dp[i-1][j]和dp[i-1][j-nums[i]]，两者相差一行，后一步dp可以直接覆盖前一步，将二维数组压缩到一维，空间复杂度降为O(S)。进一步分析可以得知，对于本题不要求给出所有可行方案的前提下，如果在前面的规划过程中得到了dp[S]为true的结果，可以直接返回。</p><h4 id="优化DP"><a href="#优化DP" class="headerlink" title="优化DP"></a>优化DP</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=sum/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[S+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//第一个元数(0 ~ 0)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">dp[j]=(j==nums[<span class="number">0</span>]) ? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//第一个元素等于S，满足等和分割，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(dp[s])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=S;j&gt;=nums[i];j--)<span class="comment">//优先规划和为S的情况。j&lt;nums[i]时dp值等于前一步，直接跳过</span></span><br><span class="line">&#123;</span><br><span class="line">dp[j]=dp[j-nums[i]] || d[j];</span><br><span class="line"><span class="keyword">if</span>(j==S &amp;&amp; dp[j])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//已有可行方案，直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[S];</span><br></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> || sum&lt;<span class="number">0</span>)<span class="comment">//边界条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(i<span class="number">-1</span>,sum) || dfs(i<span class="number">-1</span>,sum-nums[i]);<span class="comment">//左右分支</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=sum/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(N<span class="number">-1</span>,S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：如果用两个变量分别记录已选和丢弃元素的和，则可以实现左右剪枝。</p><h4 id="优化DFS-剪枝"><a href="#优化DFS-剪枝" class="headerlink" title="优化DFS - 剪枝"></a>优化DFS - 剪枝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sumL,<span class="keyword">int</span> sumR)</span><span class="comment">//左分支选中，右分支丢弃</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sumL&gt;S || sumR&gt;S || i&lt;<span class="number">0</span>)<span class="comment">//丢弃或已选元素之和超过目标，直接剪枝</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(sumL==S || sumR==S)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(i<span class="number">-1</span>,sumL+nums[i],sumR) || dfs(i<span class="number">-1</span>,sumL,sumR+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=nums.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S=sum/<span class="number">2</span>;</span><br><span class="line">sort(nums.begin(),nums.end());<span class="comment">//预排序</span></span><br><span class="line"><span class="keyword">if</span>(nums.back()&gt;S)<span class="comment">//最大元素超过目标值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(N<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划 - 背包问题</title>
      <link href="/2019/03/14/DP-zoPack/"/>
      <url>/2019/03/14/DP-zoPack/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有一个背包，最大容量为P，现有数量为S的一堆物品，其大小和价值各不相同，求如何保证背包所装物品价值最高。物品大小与价值由数组w[S]和v[S]给出。  </p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>类似问题如果用暴力求解时间复杂度将不可接受。分析问题发现，对于选定的物品，其状态只有两种 – 拿走或放弃，这是一个很明显的动态规划问题。设dp[i][j]为<strong>剩余可选</strong>物品数量 i 和<strong>剩余空间</strong> j 时的物品价值，则很显然有状态方程：dp[i][j] = max[dp[i - 1][j], dp[i - 1][j - w[i-1]]+v[i-1]]. 前者对应放弃物品，因此背包剩余容量不变。后者对应拿走物品，背包容量减少，总价值加上选中物品价值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[S+<span class="number">1</span>][P+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pick[S];<span class="comment">//保存选中物品</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)</span><br><span class="line">pick[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= S; i++)</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= P; i++)</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//DP</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= P; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>])<span class="comment">//背包空间不足</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]] + v[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反向查找选中物品</span></span><br><span class="line"><span class="keyword">int</span> j = P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &gt;<span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; dp[i - <span class="number">1</span>][j])</span><br><span class="line">&#123;</span><br><span class="line">pick[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">j -= w[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (j&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点：从剩余物品中取时容易理解成贪心算法，每一步DP实际上是<strong>从第一个物品选到当前物品</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - 两数之和</title>
      <link href="/2019/02/28/Leetcode-twoSum/"/>
      <url>/2019/02/28/Leetcode-twoSum/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">问题</a></h3><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储一位数字。如果我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。  </p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>先将两数相加，再提取各位数字组成新链表。<br> 优点：代码简单<br> 缺点：无法用于大数计算</p></li><li><p>边遍历边相加，同时构建链表节点。需要考虑进位问题。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">ListNode* L3 = L2;</span><br><span class="line">ListNode* cur=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L2 || L1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L2)</span><br><span class="line">&#123;</span><br><span class="line">cur = L2;<span class="comment">//保存当前位置</span></span><br><span class="line">val = cur-&gt;val + flag;</span><br><span class="line">L2 = L2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;next = L1;<span class="comment">//L2比L1短，直接链接到L1</span></span><br><span class="line">cur = L1;</span><br><span class="line">val = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1)</span><br><span class="line">&#123;</span><br><span class="line">val += L1-&gt;val;</span><br><span class="line">L1 = L1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;val = val % <span class="number">10</span>;</span><br><span class="line">(val &gt; <span class="number">9</span>) ? flag = <span class="number">1</span> : flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1 == <span class="number">0</span> &amp;&amp; L2 == <span class="number">0</span> &amp;&amp; flag == <span class="number">1</span>)</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> L3;</span><br></pre></td></tr></table></figure><h4 id="CSharp"><a href="#CSharp" class="headerlink" title="CSharp"></a>CSharp</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">ListNode L3=L2;</span><br><span class="line">ListNode cur=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>( L2!=<span class="literal">null</span>|| L1!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L2!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = L2;</span><br><span class="line">val = cur.val+flag;</span><br><span class="line">L2 = L2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur.next = L1;</span><br><span class="line">cur = L1;</span><br><span class="line">val = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L1!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">val += L1.val;</span><br><span class="line">L1 = L1.next;</span><br><span class="line">&#125;</span><br><span class="line">cur.val = val % <span class="number">10</span>;</span><br><span class="line">flag = val &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L1 == <span class="literal">null</span> &amp;&amp; L2 == <span class="literal">null</span> &amp;&amp; flag == <span class="number">1</span>)</span><br><span class="line">cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> L3;</span><br></pre></td></tr></table></figure><p>考查点：<strong>单链表</strong>、<strong>大数计算</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++泛型基础 - 模板</title>
      <link href="/2018/12/28/C-Template/"/>
      <url>/2018/12/28/C-Template/</url>
      
        <content type="html"><![CDATA[<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="隐式实例化与显式实例化"><a href="#隐式实例化与显式实例化" class="headerlink" title="隐式实例化与显式实例化"></a>隐式实例化与显式实例化</h3><p>常规的模板函数声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T arg1, T arg2)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>模板实际上并不是一个可以直接调用的函数，只有首次使用函数时，编译器才根据参数类型生成一个对应版本的函数实例，然后调用该函数，这个过程称为隐式实例化。C++ 11新增显式实例化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该语句提示编译器强制生成一个int版本的模板函数实例，而不管接下来有没有用到该版本的函数。显式实例化可以用于模板函数的声明与定义分离，例如在头文件中声明函数模板，在源文件中定义函数体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;arg1, T &amp;arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件 定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;arg1, T &amp;arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arg1=arg1^arg2;</span><br><span class="line">arg2=arg1^arg2;</span><br><span class="line">arg1=arg1^arg2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不包含此显式实例化将产生link_error</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myswap.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">myswap(a,b)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板实现文件中显式具体化后强制生成了对应函数实例，main中调用myswap函数时，编译器虽然无法访问函数定义生成main自己的函数实例，但在链接阶段找到了myswap.obj中签名相符的函数实例，因此链接通过。显式实例化避免了重复实例化，缺点是必须在模板实现文件中实例化所有需要的版本，适用于重载需求较少的模板。</p><h3 id="显式实例化与具体化"><a href="#显式实例化与具体化" class="headerlink" title="显式实例化与具体化"></a>显式实例化与具体化</h3><p>模板只能解决“普遍情况”下的问题，对于特殊参数类型，通用模板就无法工作。为了解决类似的“具体”问题，需要为对应的参数类型实现“具体化”的模板定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">char</span>* <span class="title">add</span><span class="params">(<span class="keyword">char</span>* pc1, <span class="keyword">char</span>* pc2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，具体化的模板优先级高于普通模板。如果在同一编译单元同时存在签名相同的显式实例化与具体化，且<strong>显式实例化在具体化之前</strong>，则会引发重复定义错误，原因是编译器先显式实例化生成了函数实例，但接下来的语句出现了优先级更高的具体化模板，编译器尝试以具体化模板生成函数实例，但已存在相同签名的函数实例，因此引发重复定义错误。反之编译器先以具体化模板为原型生成函数实例，则会跳过优先级较低的显式实例化，编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T arg1, T arg2)</span></span>;</span><br><span class="line"><span class="comment">//a.显式实例化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//b.相同签名的具体化模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//交换ab的次序则编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">add(a,b);<span class="comment">//使用该签名的函数引发重复定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板定义</span></span><br><span class="line"><span class="comment">/*.........</span></span><br></pre></td></tr></table></figure><h3 id="模板调用优先级"><a href="#模板调用优先级" class="headerlink" title="模板调用优先级"></a>模板调用优先级</h3><p>如果同时存在<strong>参数类型匹配</strong>的非模板函数、普通模板、具体化模板，则非模板 &gt;具体化模板 &gt;通用模板，其中具体化模板参数越具体，其优先级越高。调用时也可以强制使用模板函数，此时只考虑模板的优先级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">add(a,b);<span class="comment">//优先调用非模板add(int,int)</span></span><br><span class="line">add&lt;&gt;(a,b);<span class="comment">//强制使用模板，类型自动推断</span></span><br><span class="line">add&lt;<span class="keyword">int</span>&gt;(a,b);<span class="comment">//使用模板，显式指定模板参数类型为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>类模板与函数模板使用方法类似，不过类模板多一个偏特化(或者叫部分具体化)语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化模板，特化为指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>偏特化可以看作是对模板的进一步具体，介于完全具体与完全泛化之间。函数模板没有偏特化语法，因为可以用函数模板重载来实现一样的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非法使用显式模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MyFunc&lt;T*&gt;(T*);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OK，这是另一种具体化语法，可省略&lt;char*&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> MyFunc&lt;<span class="keyword">char</span>*&gt;(<span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OK，构成模板重载</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(T*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐。编译器将它看作显式实例化，忽略&lt;typename T&gt;以及函数定义。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure><p><em>以上代码测试结果均来自VS2013，具体情形以编译器实现为准</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
