<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++模板与泛型 - 函数模板</title>
      <link href="/2018/12/28/C-FunTemplate/"/>
      <url>/2018/12/28/C-FunTemplate/</url>
      
        <content type="html"><![CDATA[<h3 id="隐式实例化与显式实例化"><a href="#隐式实例化与显式实例化" class="headerlink" title="隐式实例化与显式实例化"></a>隐式实例化与显式实例化</h3><p>函数模板解决的是不同参数类型的函数重载问题，常规的模板函数声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T arg1, T arg2)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>模板实际上并不是一个可以直接调用的函数，只有首次使用函数时，编译器才根据参数类型自动生成一个对应版本的函数定义，然后调用该函数，这个过程称为隐式实例化。C++ 11新增显式实例化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该语句提示编译器强制生成一个int版本的模板函数实例，而不管接下来有没有用到该版本。显式实例化可以用于模板函数的声明与定义分离，例如在头文件中声明一个函数模板，则必须同时包含其定义，否则将会产生链接错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myswap.h 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;arg1, T &amp;arg2)</span></span>;</span><br><span class="line"><span class="comment">//1.不包含定义产生link_error</span></span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">arg1=arg1^arg2;</span></span><br><span class="line"><span class="comment">arg2=arg1^arg2;</span></span><br><span class="line"><span class="comment">arg1=arg1^arg2;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//myswap.cpp 定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;arg1, T &amp;arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arg1=arg1^arg2;</span><br><span class="line">arg2=arg1^arg2;</span><br><span class="line">arg1=arg1^arg2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.不包含显式实例化产生link_error</span></span><br><span class="line"><span class="comment">/*template void myswap(int,int);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myswap.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">myswap(a,b)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于情形1，编译阶段找不到模板定义，无法生成对应的函数实例。如果在头文件包含函数定义，每个使用了myswap函数的源文件都会在自己的编译单元生成函数实例，导致执行文件变大。<br>对于情形2，在模板实现文件中仅包含定义，由于main无法访问myswap.cpp，同样产生link_error，一种解决方法是在main中包含myswap.cpp文件，这种方法有违C++的编程规范，同样无法避免重复生成函数实例的问题。<br>在模板实现文件中显式具体化后强制生成了对应函数实例，main中调用myswap函数时，编译器无法访问函数定义生成main自己的函数实例，但在链接阶段找到了myswap.obj中签名相符的函数实例，因此链接通过。显式实例化避免了重复实例化，缺点是必须在模板实现文件中实例化所有需要的版本，适用于重载需求较少的模板。</p><h3 id="显式实例化与具体化"><a href="#显式实例化与具体化" class="headerlink" title="显式实例化与具体化"></a>显式实例化与具体化</h3><p>模板只能解决“普遍情况”下的重载问题，对于特殊参数类型，例如实现指针的加法(虽然没有意义)，通用模板就无法工作，因为指针没有重载加法操作符。为了解决类似的“具体”问题，需要为对应的参数类型实现“具体化”的模板定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span>* pint1, <span class="keyword">int</span>* pint2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>*)((<span class="keyword">int</span>)pint1 + (<span class="keyword">int</span>)pint2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，具体化的模板优先级高于普通模板。如果在同一编译单元同时存在签名相同的显式实例化与具体化，且<font color="red"><strong>显式实例化在具体化之前</strong></font>，则会引发重复定义错误，原因是编译器显式实例化生成了函数实例，但接下来的语句出现了优先级更高的具体化模板，编译器尝试以具体化模板生成函数实例，但已存在相同签名的函数实例，因此引发错误。反之编译器先以具体化模板为原型生成函数实例，则会跳过优先级较低的显式实例化，编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T arg1, T arg2)</span></span>;</span><br><span class="line"><span class="comment">//a.显式实例化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//b.相同签名的具体化模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//交换ab的次序则编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">add(a,b);<span class="comment">//使用该签名的函数引发重复定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板定义</span></span><br><span class="line"><span class="comment">/*.........</span></span><br></pre></td></tr></table></figure><h3 id="函数调用优先级"><a href="#函数调用优先级" class="headerlink" title="函数调用优先级"></a>函数调用优先级</h3><p>如果同时存在<strong>相同签名</strong>的非模板函数、普通模板、具体化模板，则非模板 &gt;具体化模板 &gt;普通模板。调用时也可以指定使用模板函数，此时只考虑模板的优先级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">add&lt;<span class="keyword">int</span>&gt;(a,b);<span class="comment">//省略int将自动推断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>以上代码测试结果来自VS2013</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
